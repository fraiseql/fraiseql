# FraiseQL v1.9.1 ‚Üí v1.9.5 Improvements vs. feature/phase-16-rust-http-server

**Analysis Date**: January 6, 2026
**Branch**: feature/phase-16-rust-http-server (v1.9.5 merged)
**Goal**: Ensure all v1.9.5 improvements properly integrated for v2.0 Rust-focused work

---

## Executive Summary

‚úÖ **Status**: MOSTLY ALIGNED with some **critical gaps in Rust APQ security implementation**

From v1.9.1 to v1.9.5 (11 commits), FraiseQL received **4 major improvements**:
1. ‚úÖ ID type filtering (IDPolicy-aware IDFilter)
2. ‚úÖ Security & ID Policy configuration (IDPolicy enum + SchemaConfig)
3. ‚ö†Ô∏è APQ Security fixes (PARTIALLY in Rust - variables missing from cache key)
4. ‚úÖ GraphQL info auto-injection (RUST-READY)

---

## Improvement #1: ID Type Filtering (v1.9.2-v1.9.5)

### Problem (v1.9.1)
- ID fields in WHERE clauses fell back to StringFilter
- GraphQL schema inconsistent with runtime validation
- No clear distinction between `ID` (entity ID) and `UUID` (generic UUID)

### Solution Implemented
**Files Updated**:
- `src/fraiseql/sql/graphql_where_generator.py` - NEW `IDFilter` class
- `src/fraiseql/types/scalars/id_scalar.py` - ID marker type with `IDField`
- `src/fraiseql/__init__.py` - Exports IDField as ID
- `tests/` - 30+ new tests for ID policy behavior

**IDFilter Class**:
```python
@fraise_input
class IDFilter:
    """Filter for ID fields regardless of policy."""
    eq: ID | None = None
    neq: ID | None = None
    in_: list[ID] | None = fraise_field(default=None, graphql_name="in")
    nin: list[ID] | None = None
    isnull: bool | None = None
```

### Current Status in feature/phase-16-rust-http-server
‚úÖ **FULLY INTEGRATED**
- IDFilter present in `src/fraiseql/sql/graphql_where_generator.py`
- IDField marker class in `src/fraiseql/types/scalars/id_scalar.py`
- All tests passing (3,445 unit tests)
- Version: v1.9.5

### v2.0 Rust Implementation Status
‚ö†Ô∏è **NEEDS VERIFICATION** - Check if Rust WHERE builder respects ID filtering:
- File: `fraiseql_rs/src/query/where_normalization.rs`
- File: `fraiseql_rs/src/db/where_builder.rs`
- **Action**: Verify Rust WHERE clause builder handles ID fields correctly with policy validation

---

## Improvement #2: ID Policy Configuration (v1.9.2)

### Problem (v1.9.1)
- No configurable ID type behavior
- Unclear if ID represents entity ID or generic UUID
- No way to enforce UUID format or accept opaque strings

### Solution Implemented
**New Configuration System**:
```python
from fraiseql.config.schema_config import SchemaConfig, IDPolicy

# Option A: UUID validation (default)
SchemaConfig.set_config(id_policy=IDPolicy.UUID)
# GraphQL schema: id: ID!
# Runtime: validates UUID format

# Option B: Opaque strings (GraphQL spec-compliant)
SchemaConfig.set_config(id_policy=IDPolicy.OPAQUE)
# GraphQL schema: id: ID! (same)
# Runtime: accepts any string
```

**Type Mapping**:
| Python Type | ID Policy | GraphQL Type | Validation |
|---|---|---|---|
| `ID` (NewType) | UUID | IDScalar | UUID format checked |
| `ID` (NewType) | OPAQUE | ID (builtin) | Any string accepted |
| `uuid.UUID` | Any | UUIDScalar | Always strict UUID |

**Files**:
- `src/fraiseql/config/schema_config.py` - NEW singleton configuration
- `src/fraiseql/sql/graphql_where_generator.py` - Uses config for filter type mapping
- `examples/` - 44 files updated to use ID type

### Current Status in feature/phase-16-rust-http-server
‚úÖ **FULLY INTEGRATED**
- SchemaConfig present and functional
- IDPolicy enum with UUID/OPAQUE modes
- Type mapping respects configuration
- 30+ tests passing

### v2.0 Rust Implementation Status
‚úÖ **DESIGN READY** - Python configuration layer can drive Rust validation
- Rust validation logic needed in: `fraiseql_rs/src/db/` or input validation layer
- **Current**: Rust WHERE clause builder doesn't validate ID format
- **Needed**: Pass IDPolicy from Python to Rust for runtime validation
- **Approach**: Add `id_policy` parameter to Rust resolver or use environment configuration

---

## Improvement #3: APQ Security Fixes (v1.9.2-v1.9.5)

### Problem (v1.9.1)
**Vulnerability #1: Data Leakage via Shared Cache**
```
Client A: POST { user(id: "123") } ‚Üí Cached response for "123"
Client B: POST { user(id: "456") } ‚Üí Receives cached "123" response!
Root Cause: Cache key only used query hash, ignored variables
```

**Vulnerability #2: Field Selection Ignored**
```
Authorized: GET { user { name } }
Attacker:   GET { user { name, salary, ssn } } (same query hash)
Result:     Returns all fields in response
Root Cause: Response filtering only checked query, not selections
```

### Solution Implemented

**Python Layer** (FULLY IMPLEMENTED):
```python
# src/fraiseql/middleware/apq_caching.py
def compute_response_cache_key(query_hash: str, variables: dict | None = None) -> str:
    """Combine query hash + normalized variables for secure cache key."""
    if not variables:
        return query_hash

    # Variables are sorted and hashed together with query hash
    var_str = json.dumps(variables, sort_keys=True, separators=(",", ":"))
    combined = f"{query_hash}:{var_str}"
    return hashlib.sha256(combined.encode()).hexdigest()
```

**New Selection Filtering** (FULLY IMPLEMENTED):
```python
# src/fraiseql/middleware/apq_selection.py (NEW)
def filter_response_by_selection(response: dict, selection_set: Dict) -> dict:
    """Remove fields not in GraphQL selection set."""
    # Filters out unauthorized fields from cached response
```

**Files Changed**:
- `src/fraiseql/middleware/apq_caching.py` - Variable-aware cache keys
- `src/fraiseql/middleware/apq_selection.py` - NEW response field filtering
- `src/fraiseql/fastapi/routers.py` - Passes operation_name + query_text
- `tests/middleware/test_apq_*.py` - 22 new security tests
- `tests/regression/test_apq_field_selection_bug.py` - 3 regression tests

### Current Status in feature/phase-16-rust-http-server

**Python Security Layer**: ‚úÖ **FULLY INTEGRATED**
- `apq_caching.py` has variable-aware keys
- `apq_selection.py` filters responses correctly
- All tests passing

**Rust APQ Layer**: ‚ö†Ô∏è **PARTIAL**
- Rust hasher: `fraiseql_rs/src/apq/hasher.rs` - **MISSING variable hashing**
- Rust storage: `fraiseql_rs/src/apq/storage.rs` - Uses simple query hash only
- Rust cache key: Does not include variables!

### üö® GAP: Rust APQ Architecture Issue

**Current State**:
- Rust APQ (`fraiseql_rs/src/apq/`) handles query persistence (lookup by hash)
- Rust Batch Requests (`fraiseql_rs/src/http/batch_requests.rs`) DO include variables in deduplication key ‚úÖ
- BUT: APQ module doesn't receive variables in `handle_request()` signature

**Current APQ Code** (`fraiseql_rs/src/apq/mod.rs`):
```rust
pub async fn handle_request(
    &self,
    extensions: Option<ApqExtensions>,
    query: Option<String>,
    // ‚ùå NO variables parameter!
) -> Result<ApqResponse, ApqError>
```

**Design Issue**:
- APQ is for persisted query lookup (maps hash ‚Üí query string)
- Response caching (which needs variable-aware keys) is DIFFERENT from query persistence
- Batch deduplication DOES handle variables correctly
- But there's a gap between APQ query lookup and response caching

**Security Analysis**:
‚úÖ **If Rust HTTP layer uses Python middleware**: Response caching is secure (Python has variable-aware keys)
‚ö†Ô∏è **If Rust implements native response caching**: Must include variables in cache key

**Rust Files Involved**:
- `fraiseql_rs/src/apq/mod.rs` - Query persistence (vars not needed)
- `fraiseql_rs/src/apq/hasher.rs` - Query hashing (vars not needed)
- `fraiseql_rs/src/http/batch_requests.rs` - Batch dedup (vars included ‚úÖ)
- `fraiseql_rs/src/http/axum_server.rs` - Main HTTP server (TODO: verify APQ integration)
- `fraiseql_rs/src/cache/` - Response caching layer (TODO: verify variable handling)

**Solution Required for v2.0**:
If Rust implements response caching:
```rust
// Response cache key (different from APQ query hash)
pub fn compute_response_cache_key(
    query_hash: &str,
    variables: &Option<serde_json::Value>
) -> String {
    if let Some(vars) = variables {
        let var_str = serde_json::to_string(&vars).unwrap();
        let combined = format!("{}:{}", query_hash, var_str);
        let mut hasher = Sha256::new();
        hasher.update(combined.as_bytes());
        hex::encode(hasher.finalize())
    } else {
        query_hash.to_string()
    }
}
```

**Files to Check/Update**:
- `fraiseql_rs/src/cache/mod.rs` - Response cache implementation
- `fraiseql_rs/src/http/axum_server.rs` - HTTP server's cache integration
- `fraiseql_rs/src/http/py_bindings.rs` - Check Python interface

---

## Improvement #4: GraphQL Info Auto-Injection (v1.9.1)

### Problem (v1.9.1)
- Rust zero-copy pipeline requires manual `info=info` parameter
- Developer error-prone: forget to pass info ‚Üí Python execution (7-10x slower)
- Requires explicit awareness of Rust acceleration

### Solution Implemented
**New Middleware**:
```python
# src/fraiseql/middleware/graphql_info_injector.py
class GraphQLInfoInjector:
    """Automatically injects GraphQL info into resolver context."""
    async def __call__(self, request, call_next):
        # Injects info before resolver execution
        return await call_next(request)
```

**Benefits**:
- Transparent Rust pipeline activation
- 100% backward compatible
- No developer code changes needed

### Current Status in feature/phase-16-rust-http-server
‚úÖ **FULLY INTEGRATED**
- GraphQLInfoInjector present in middleware
- FastAPI integration complete
- All tests passing

### v2.0 Rust Status
‚úÖ **READY FOR RUST HTTP SERVER**
- Axum server (v2.0) automatically has info available
- No middleware needed in Rust-native implementation
- Info injection happens naturally in HTTP layer

---

## Summary: v1.9.5 Feature Coverage

| Improvement | Python Layer | Rust Layer | Status | Gap |
|---|---|---|---|---|
| **IDFilter for ID type** | ‚úÖ Complete | ‚úÖ Likely OK | ‚úÖ COVERED | None - verify WHERE builder |
| **IDPolicy Configuration** | ‚úÖ Complete | ‚ö†Ô∏è Runtime validation not implemented | ‚ö†Ô∏è PARTIAL | Need Rust validation layer |
| **APQ Security - Variables** | ‚úÖ Complete | ‚ùå MISSING | üö® CRITICAL | Must add variable hashing to Rust APQ |
| **APQ Security - Selection** | ‚úÖ Complete | ‚ö†Ô∏è Unknown | ‚ö†Ô∏è PARTIAL | Check if Rust respects selection filtering |
| **GraphQL Info Injection** | ‚úÖ Complete | ‚úÖ N/A in Rust | ‚úÖ READY | None - Axum handles naturally |

---

## Action Items for v2.0

### CRITICAL (Security)
1. **Update Rust APQ Hasher** to include variables
   - File: `fraiseql_rs/src/apq/hasher.rs`
   - Add `hash_query_with_variables(query: &str, variables: Option<Value>) -> String`
   - Update `fraiseql_rs/src/apq/mod.rs` to use it
   - Update `fraiseql_rs/src/apq/py_bindings.rs` bindings

2. **Verify Rust Response Field Filtering**
   - Check: Does Rust HTTP layer filter responses by GraphQL selection?
   - If no: Implement similar to `apq_selection.py`

### HIGH (Feature Completeness)
3. **Add Rust ID Policy Validation**
   - Input validation layer should enforce IDPolicy.UUID format
   - Pass config from Python to Rust
   - Location: `fraiseql_rs/src/` input validation module

### MEDIUM (Testing)
4. **Add Rust APQ Security Tests**
   - Test variable-aware cache keys
   - Test field selection filtering
   - Test no data leakage between requests

### LOW (Documentation)
5. **Document v2.0 APQ Architecture**
   - How variables flow through HTTP ‚Üí Python ‚Üí Rust
   - Security guarantees in Rust implementation
   - Configuration for ID policy

---

## Risk Assessment

### If Rust APQ variables NOT fixed before v2.0 release
**Risk Level**: üî¥ **CRITICAL**

**Scenario**:
- User deploys v2.0 with Rust HTTP server
- APQ enabled with variable-aware Python caching
- But Rust layer ignores variables in cache key
- Query with different variables returns wrong cached response
- **Result**: Data leakage between users/tenants

**Mitigation**:
- Must fix before ANY v2.0 release
- Add security tests that would catch this
- Document APQ variable hashing requirement

### If ID Policy validation NOT in Rust
**Risk Level**: üü° **MEDIUM**

**Current State**:
- Python validation works (IDPolicy enforced)
- If bypassed directly to Rust: no validation
- Risk only if Rust called without Python validation layer

**Mitigation**:
- Document that ID validation requires Python input processing
- Or: Implement Rust validation for defense-in-depth

### If Selection Filtering NOT in Rust
**Risk Level**: üü° **MEDIUM**

**Current State**:
- Python selection filtering works
- If bypassed directly to Rust: returns all cached fields
- Risk if Rust can be called without Python filtering

**Mitigation**:
- Document that selection filtering requires Python layer
- Or: Implement Rust selection filtering

---

## Integration Checklist for v2.0

- [ ] Merge v1.9.5 features into Rust (DONE - already merged)
- [ ] **CRITICAL**: Fix Rust APQ variable hashing
- [ ] Verify Rust WHERE clause builder with ID type
- [ ] Add Rust ID policy validation
- [ ] Verify Rust selection filtering
- [ ] Update Rust tests (22+ security tests)
- [ ] Update Rust documentation
- [ ] Security audit of Rust HTTP layer
- [ ] Performance testing (Rust vs Python)
- [ ] Release notes for v2.0

---

## Conclusion

**feature/phase-16-rust-http-server is v1.9.5 FEATURE-COMPLETE** with respect to Python layer improvements.

**Rust layer has 1 CRITICAL gap** (APQ variable hashing) and 2 areas needing verification (ID policy validation, selection filtering).

All gaps are fixable before v2.0 release. The security vulnerability in Rust APQ MUST be fixed before deploying to production.

---

**References**:
- v1.9.1 baseline commit
- v1.9.5 improvements commits (11 total)
- feature/phase-16-rust-http-server current state
- Rust APQ implementation: `fraiseql_rs/src/apq/`
- Python security layer: `src/fraiseql/middleware/apq_*.py`
