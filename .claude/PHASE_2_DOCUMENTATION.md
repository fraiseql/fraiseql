# Phase 2 Implementation: Documentation & Code Clarity

**Objective**: Improve clarity of architectural decisions and security patterns for maintainability

**Estimated Effort**: 2-3 hours
**Priority**: P2 (Nice-to-have, important for maintainability)
**Risk Level**: None (documentation only)

---

## Task 1: Enhance compiler/codegen.rs Documentation

**File**: `crates/fraiseql-core/src/compiler/codegen.rs` (lines 53, 140-141)

### Current Issue
The `generate()` function has unclear comments about templates and fact tables being "populated by compiler" - this confuses new developers about architectural design.

### Enhancement: Expanded Doc Comments

Add comprehensive documentation explaining the design:

```rust
/// Generate a compiled schema from the intermediate representation.
///
/// # Architecture: Schema vs. Templates vs. Metadata
///
/// FraiseQL separates schema definition from execution artifacts:
///
/// ## What This Function Generates
///
/// The `CompiledSchema` contains the **schema definition** - types, fields, enums,
/// interfaces, unions, and query/mutation/subscription signatures. This is what
/// GraphQL introspection tools query and what the runtime uses for query validation.
///
/// ## What This Function Does NOT Generate
///
/// ### 1. SQL Templates
///
/// SQL templates are managed separately by the compilation pipeline (Phase 4).
/// They are:
/// - Generated in a separate compiler pass after schema validation
/// - Kept separate to allow schema reuse across database backends
/// - Passed to the runtime executor independently
///
/// **Why**: Allows updating SQL generation strategy without recompiling schema
/// definitions. For example, you could optimize SQL templates without changing
/// type definitions.
///
/// ### 2. Fact Tables
///
/// Fact table metadata is populated by the compiler from `ir.fact_tables` in a
/// separate initialization pass. This maintains:
/// - Clean separation of concerns (schema def vs. analytics metadata)
/// - Ability to update fact table configuration independently
/// - Clear data flow through compilation pipeline
///
/// **Why**: Fact tables are configuration-driven metadata. Keeping them separate
/// allows analytics tuning without affecting core schema.
///
/// # Parameters
///
/// * `ir` - The intermediate representation generated by the compiler
/// * `_templates` - SQL templates (currently unused; kept for API compatibility)
///
/// # Errors
///
/// Returns a `Result` with compilation errors if schema validation fails.
///
/// # Examples
///
/// ```no_run
/// use fraiseql_core::compiler::*;
///
/// let authoring_ir = AuthoringIR::from_schema_json("schema.json")?;
/// let compiled_schema = SchemaCodegen::new().generate(&authoring_ir, &[])?;
///
/// // Runtime uses compiled_schema for query execution
/// ```
///
/// # See Also
///
/// - Phase 4 (Compilation): SQL template generation
/// - [Compiler Architecture](../docs/compiler-architecture.md)
pub fn generate(&self, ir: &AuthoringIR, _templates: &[SqlTemplate]) -> Result<CompiledSchema> {
    // ... existing implementation ...
}
```

### Task 1a: Add Line-Level Comments

In the CompiledSchema construction, clarify the initialization:

```rust
Ok(CompiledSchema {
    types,
    enums,
    input_types,
    interfaces,
    unions,
    queries,
    mutations,
    subscriptions,
    directives: Vec::new(), // Note: IR doesn't have custom directive definitions yet

    // Fact tables are populated from ir.fact_tables in a separate pass
    // to maintain separation of concerns between schema and analytics metadata
    fact_tables: std::collections::HashMap::new(),
})
```

### Task 1b: Add Architecture Section to Compiler Module Docs

Add to `crates/fraiseql-core/src/compiler/mod.rs`:

```rust
//! # FraiseQL Compiler Module
//!
//! The compiler transforms GraphQL schema definitions into optimized Rust code
//! for query execution. This module handles the full compilation pipeline.
//!
//! ## Compilation Pipeline
//!
//! ```text
//! schema.graphql
//!     ↓
//! [Phase 1: Parsing]
//!     → Parse GraphQL schema into AST
//!     ↓
//! [Phase 2: Validation]
//!     → Validate type correctness, circular references, naming
//!     ↓
//! [Phase 3: Intermediate Representation]
//!     → Build AuthoringIR (AST optimized for code generation)
//!     ↓
//! [Phase 4: SQL Template Generation]
//!     → Generate parameterized SQL for all operations
//!     ↓
//! [Phase 5: Schema Codegen]
//!     → Generate CompiledSchema for runtime
//!     ↓
//! CompiledSchema + SQL Templates
//!     → Ready for runtime execution
//! ```
//!
//! ## Design Principles
//!
//! ### 1. Separation of Concerns
//!
//! Schema definition (what queries exist?) is kept separate from execution
//! artifacts (how to execute them?). This allows:
//! - Different SQL generation strategies (optimize for OLTP vs OLAP)
//! - Database-specific optimizations
//! - Reuse of schemas across backends
//!
//! ### 2. Staged Compilation
//!
//! Each phase has a specific responsibility:
//! - Parsing: Syntax validation
//! - Validation: Semantic validation
//! - IR: Optimization
//! - Codegen: Runtime artifact generation
//!
//! This makes the compiler maintainable and testable.
//!
//! ### 3. Immutable Intermediate State
//!
//! Each phase produces immutable data structures (AuthoringIR, CompiledSchema, etc.)
//! This ensures reproducible builds and thread-safe processing.
```

---

## Task 2: Document Security Patterns

**New File**: `crates/fraiseql-core/docs/SECURITY_PATTERNS.md`

```markdown
# FraiseQL Security Patterns

## SQL Injection Prevention

### Strategy: Parameterized Queries

All user input is passed to the database as **query parameters**, never
interpolated into SQL strings.

#### Examples

##### Column Names (Compile-Time Only)

Column names come from schema definitions, never from user input:

```rust
// Schema defines columns: User { id: ID, name: String }
// These column names are fixed at compile time

// Generated SQL:
// INSERT INTO users (id, name) VALUES ($1, $2)
// Parameters: (user_id, user_name)
```

**Why safe**: Column names are part of the schema definition, fixed at compile time.
User input only provides VALUES, not column names.

##### LIMIT/OFFSET Parameters

Numeric limits are passed as query parameters:

```rust
// User query: "Get 10 items, skip 20"

// Generated SQL:
// SELECT * FROM items LIMIT $1 OFFSET $2
// Parameters: (10, 20)

// Database driver validates numeric types before execution
```

**Why safe**: u32 type ensures only valid integers are accepted. Database driver
never receives a string to parse.

##### JSON Path Extraction

JSONB paths are escaped before inclusion:

```rust
// Example: Extract nested object path

// Unsafe (if done):
// SELECT data->'{path}' FROM users

// Safe (current implementation):
// SELECT data->%s FROM users
// (using parameterized extraction functions)
```

### Rust Type System Protection

The Rust compiler itself prevents entire classes of SQL injection:

1. **Type Safety**: `u32` limit values can't contain SQL strings
2. **Memory Safety**: No buffer overflows or string manipulation bugs
3. **Compiler Warnings**: Unused interpolation flagged by clippy

### Testing Strategy

Security tests verify:
- SQL queries don't contain unescaped user input
- Parameterized queries are used consistently
- Type boundaries are respected

## Thread Safety Patterns

### Pattern: Interior Mutability for Context State

The WHERE clause generator uses `Cell<usize>` for parameter tracking:

```rust
pub struct PostgresWhereGenerator {
    param_counter: std::cell::Cell<usize>,
    // ...
}
```

**Why safe**:
1. Single-threaded context: Each async task gets its own WHERE generator instance
2. Reset on each call: Counter reset at start of `generate()` call
3. No sharing: Generators aren't Arc-shared across tasks

**Pattern**: Interior mutability is appropriate when:
- State is tied to a single execution context
- Concurrent access doesn't occur (verified by architecture)
- Performance is critical (avoids mutex overhead)

**Not Safe If**:
- Generator is Arc-shared across async tasks (would require AtomicUsize)
- Multiple threads call generate() on same instance

### Database Connection Pooling

Connection pooling uses thread-safe structures:
- `Arc<Pool>`: Shared connection pool reference
- `tokio::sync::Mutex`: Async-aware mutual exclusion
- Connection checkout/return: Atomic operations

## Type System Security

### Identifier Validation

GraphQL identifiers are validated against a regex at parse time:

```rust
// Regex ensures identifiers are valid:
// ^[a-zA-Z_][a-zA-Z0-9_]*$

// Invalid identifiers rejected at compile time:
// - Type name with spaces
// - Field names with special characters
// - Enum values with quotes
```

### Type Checking

GraphQL type checking prevents logic errors:
- Field type mismatches caught at compile time
- Null/Non-null violations caught at validation time
- Circular references detected and rejected

## Denial of Service Prevention

### Query Limits (Current/Planned)

Current:
- Query timeout: Configurable timeout per query execution
- Connection pool limits: Max connections to database
- Result set streaming: Avoid loading entire results in memory

Planned:
- Max result size: Configurable byte limit on responses
- Max nesting depth: Limit deeply nested JSONB extraction
- Max query complexity: Cost-based query limits

### Testing

DOS prevention tests:
- Very deep nesting (100+ levels)
- Large result sets (1M+ rows)
- Slow queries (timeout handling)

## Best Practices

### ✅ DO

- [ ] Use parameterized queries for all values
- [ ] Validate identifiers against regex
- [ ] Use Rust's type system (u32 vs String)
- [ ] Escape SQL string literals
- [ ] Use atomic operations for counters
- [ ] Test security scenarios in unit tests

### ❌ DON'T

- [ ] Interpolate user input into SQL strings
- [ ] Skip identifier validation
- [ ] Mix string types with numeric types
- [ ] Share interior mutable state across threads
- [ ] Use Cell when AtomicUsize is needed
- [ ] Trust database drivers to catch all errors

## Code Review Checklist

When reviewing code for security:

1. **SQL Generation**
   - [ ] Are all values parameterized?
   - [ ] Are identifiers validated?
   - [ ] Are string literals escaped?

2. **Thread Safety**
   - [ ] Is Cell used only for single-threaded context?
   - [ ] Are Arc-shared values thread-safe?
   - [ ] Are atomic operations used for counters?

3. **Type Safety**
   - [ ] Are types used correctly (u32 not String)?
   - [ ] Are null checks present?
   - [ ] Are error types propagated?

4. **Denial of Service**
   - [ ] Are there recursion depth limits?
   - [ ] Are there result size limits?
   - [ ] Are there query timeouts?

## Resources

- [Rust Book: Safety](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)
- [OWASP Top 10 - SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [Tokio: Concurrency Patterns](https://tokio.rs/tokio/tutorial)
```

---

## Task 3: Add Code Comments for Design Clarity

### WHERE Generator Pattern

**File**: `crates/fraiseql-core/src/db/postgres/where_generator.rs` (around line 77)

Add clarifying comment:

```rust
/// PostgreSQL WHERE clause generator.
///
/// # Interior Mutability Pattern
///
/// This struct uses `Cell<usize>` for the parameter counter. This is safe because:
///
/// 1. **Single-threaded usage**: Each WHERE generator is created for a single
///    query execution and isn't shared across async tasks.
///
/// 2. **Reset per call**: The counter is reset at the start of `generate()`,
///    ensuring no state leakage between calls.
///
/// 3. **Performance**: Avoids mutex overhead for a simple counter.
///
/// # If Shared Across Tasks
///
/// If this generator were Arc-shared across multiple async tasks, replace
/// `Cell<usize>` with `AtomicUsize` to prevent data races.
///
pub struct PostgresWhereGenerator {
    param_counter: std::cell::Cell<usize>,
    indexed_columns: Option<Arc<HashSet<String>>>,
}
```

### SQL Template Architecture

**File**: `crates/fraiseql-core/src/compiler/codegen.rs`

Add architectural comment near the generate function:

```rust
/// SQL Template Architecture
///
/// The compiler separates schema definition from SQL template management:
///
/// 1. **Schema Compilation** (this function):
///    - Validates GraphQL type definitions
///    - Generates type information for introspection
///    - Produces CompiledSchema for runtime query validation
///
/// 2. **Template Generation** (separate pipeline stage):
///    - Generates parameterized SQL for each operation
///    - Database-specific optimization happens here
///    - Templates passed to runtime executor separately
///
/// Why separate?
/// - Allows testing schema independently from SQL
/// - Enables different SQL strategies per database
/// - Simplifies schema caching and reuse
```

---

## Task 4: Create ARCHITECTURE.md File

**New File**: `.claude/ARCHITECTURE.md`

```markdown
# FraiseQL v2 Architecture Overview

## Design Philosophy

FraiseQL v2 is a **compiled GraphQL execution engine** that transforms schema
definitions into optimized SQL at build time.

Key principle: **Separate schema definition from execution artifacts**

## Component Architecture

```
┌─────────────────────────────────────────────────────────┐
│              GraphQL Schema Definition                   │
│  (Type definitions, fields, relationships, queries)     │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │   Schema Compiler    │
        │  (Multi-phase)       │
        └──────────┬───────────┘
                   │
        ┌──────────┴──────────┐
        ▼                      ▼
  ┌───────────┐         ┌──────────────┐
  │ SQL       │         │ Runtime      │
  │ Templates │         │ Artifacts    │
  └───────────┘         └──────────────┘
        │                      │
        └──────────┬───────────┘
                   ▼
        ┌──────────────────────┐
        │  Runtime Executor    │
        │  (Processes queries) │
        └──────────────────────┘
```

## Compilation Pipeline

See [PHASE_1_DETAILED_SPEC.md](PHASE_1_DETAILED_SPEC.md) for task details.

## Security Model

### Threat: SQL Injection

**Prevention**: All values are parameterized, identifiers validated

### Threat: Denial of Service

**Prevention**: Query timeouts, connection limits, depth checking

### Threat: Data Races

**Prevention**: Thread-safe data structures, interior mutability used carefully

See [SECURITY_PATTERNS.md](../docs/SECURITY_PATTERNS.md) for detailed security documentation.

## Performance Considerations

### Query Optimization

- Compile-time schema optimization
- Database-specific SQL generation
- Query result streaming

### Memory Management

- Avoid unnecessary allocations (in progress: Task 5 of Phase 3)
- Use Arc for shared immutable data
- Parameterized queries enable query plan caching

## Testing Strategy

See [fraiseql-testing.md](../../skills/fraiseql-testing.md) for complete testing documentation.

Quick reference:
- Unit tests: Per-module in `mod.rs`
- Integration tests: `tests/` directory with database setup
- Security tests: SQL injection, thread-safety scenarios

---

This document is maintained as architecture decisions are made.
Last updated: 2026-01-19
```

---

## Task 5: Update README with Architecture Section

**File**: `README.md`

Add new section after introduction:

```markdown
## Architecture

FraiseQL v2 separates schema definition from execution:

- **Schema**: GraphQL type definitions (compile-time)
- **SQL Templates**: Parameterized SQL generation (compile-time)
- **Runtime**: Query execution using pre-compiled artifacts

This design enables:
- Database-specific optimizations
- Schema caching and reuse
- Simplified testing and maintenance
- Strong security guarantees

See [ARCHITECTURE.md](.claude/ARCHITECTURE.md) for detailed documentation.

### Security

All user input is parameterized:
- Database values: Query parameters (never interpolated)
- Column names: Compile-time only (never user input)
- Query limits: Type-safe u32 values

See [SECURITY_PATTERNS.md](crates/fraiseql-core/docs/SECURITY_PATTERNS.md).
```

---

## Verification Checklist

### Before Documentation Updates
- [ ] Review all current documentation
- [ ] Identify areas of confusion or missing context
- [ ] Gather feedback from team on unclear patterns

### During Documentation Updates
- [ ] Update compiler/codegen.rs with enhanced doc comments
- [ ] Create SECURITY_PATTERNS.md with security details
- [ ] Add inline code comments for design patterns
- [ ] Create ARCHITECTURE.md overview
- [ ] Update README.md with security section

### After Documentation Updates
- [ ] Run `cargo doc` and review generated documentation
- [ ] Have team members review documentation for clarity
- [ ] Verify all internal links work correctly
- [ ] Check that code examples compile (use `#[doc::compile_fail]` for expected failures)

---

## Success Criteria

✅ New developers can understand architectural decisions from documentation
✅ Security patterns are clearly explained with code examples
✅ Design rationale is documented (why separate schema from templates?)
✅ All code comments explain "why" not just "what"
✅ Architecture diagram shows relationships between components
✅ Security checklist helps with code reviews

---

## Integration with Phase 1

Phase 1 (Parameterize LIMIT/OFFSET) should include:
- Commit message explaining parameterization best practice
- Link to SECURITY_PATTERNS.md in commit
- Code comments referencing security documentation

This reinforces that security improvements are documented and tracked.

---

## Timeline

| Task | Estimated Time | Priority |
|------|---|---|
| Enhance codegen.rs docs | 30 min | P1 |
| Create SECURITY_PATTERNS.md | 45 min | P1 |
| Add code comments | 30 min | P1 |
| Create ARCHITECTURE.md | 30 min | P2 |
| Update README | 15 min | P2 |
| **Total** | **2.5 hours** | |

Can be done in parallel with Phase 1, or immediately after.

---

## Deliverables

1. ✅ Enhanced doc comments in codegen.rs
2. ✅ SECURITY_PATTERNS.md explaining all security decisions
3. ✅ ARCHITECTURE.md with component overview
4. ✅ Code comments for design patterns (WHERE generator, etc.)
5. ✅ Updated README.md with security/architecture sections

All documentation will be checked into version control and maintained
alongside the code.

