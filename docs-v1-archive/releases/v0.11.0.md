# Release Notes - FraiseQL v0.11.0

## ✨ Composable HealthCheck Utility for Production Monitoring

### Release Date: 2025-10-08
### Type: Feature Enhancement (Minor Release)

## Summary

This release introduces a **composable HealthCheck utility** that provides a framework-level pattern for building production-ready health endpoints. Applications maintain full control over what to monitor while leveraging pre-built checks and automatic status aggregation. The implementation follows Kubernetes best practices for liveness and readiness probes.

**Key Innovation**: FraiseQL provides the pattern and helpers (database connectivity, pool statistics), but applications control what checks to include - striking the perfect balance between framework support and application flexibility.

## 🚨 Problem Solved

Before v0.11.0, FraiseQL applications had to manually implement health checks from scratch:

### Before (Manual Implementation) ❌
```python
# Every application writes custom health check logic
@app.get("/health")
async def health():
    try:
        # Custom database check logic
        async with db_pool.connection() as conn:
            await conn.execute("SELECT 1")

        # Custom pool stats logic
        stats = db_pool.get_stats()
        active = stats['pool_size'] - stats['pool_available']

        # Custom aggregation logic
        return {"status": "healthy", "checks": {...}}
    except Exception:
        return {"status": "unhealthy"}
```

**Issues:**
- ❌ Boilerplate code in every application
- ❌ No standard pattern for composing checks
- ❌ Manual exception handling
- ❌ Kubernetes patterns (liveness/readiness) not documented
- ❌ No pre-built checks for common dependencies

### After (Composable Pattern) ✅
```python
from fraiseql.monitoring import HealthCheck, check_database, check_pool_stats

# Framework provides pattern + pre-built checks
health = HealthCheck()
health.add_check("database", check_database)        # Pre-built!
health.add_check("database_pool", check_pool_stats) # Pre-built!
health.add_check("custom", my_custom_check)         # Your logic

@app.get("/health")
async def health_endpoint():
    result = await health.run_checks()
    result["service"] = "my-service"
    return result
```

**Benefits:**
- ✅ Framework provides pattern (HealthCheck class)
- ✅ Framework provides helpers (check_database, check_pool_stats)
- ✅ Application controls what to check (composable)
- ✅ Automatic exception handling and status aggregation
- ✅ Kubernetes-ready patterns documented
- ✅ Production-ready out of the box

## 🎯 What's New

### 1. Composable HealthCheck Class

**New**: `fraiseql.monitoring.HealthCheck`

A composable health check runner that allows applications to register custom checks and run them collectively:

```python
from fraiseql.monitoring import HealthCheck, CheckResult, HealthStatus

health = HealthCheck()

# Add pre-built checks
health.add_check("database", check_database)

# Add custom checks
async def check_redis() -> CheckResult:
    try:
        await redis_client.ping()
        return CheckResult(
            name="redis",
            status=HealthStatus.HEALTHY,
            message="Redis connection successful",
        )
    except Exception as e:
        return CheckResult(
            name="redis",
            status=HealthStatus.UNHEALTHY,
            message=f"Redis connection failed: {e}",
        )

health.add_check("redis", check_redis)

# Run all checks
result = await health.run_checks()
# Returns: {"status": "healthy" | "degraded", "checks": {...}}
```

**Features:**
- ✅ Register multiple health checks
- ✅ Automatic exception handling
- ✅ Status aggregation (healthy/degraded)
- ✅ Duplicate check name prevention
- ✅ Detailed results with metadata

### 2. Pre-built Health Checks

**New**: `fraiseql.monitoring.check_database()`

Database connectivity check with version detection:

```python
from fraiseql.monitoring import check_database

health.add_check("database", check_database)

# Returns:
# {
#     "status": "healthy",
#     "message": "Database connection successful (PostgreSQL 16.3)",
#     "metadata": {
#         "database_version": "16.3",
#         "full_version": "PostgreSQL 16.3 on x86_64-pc-linux-gnu"
#     }
# }
```

**What it checks:**
- Database connection availability
- Query execution (`SELECT version()`)
- PostgreSQL version information

---

**New**: `fraiseql.monitoring.check_pool_stats()`

Connection pool statistics with utilization tracking:

```python
from fraiseql.monitoring import check_pool_stats

health.add_check("pool", check_pool_stats)

# Returns:
# {
#     "status": "healthy",
#     "message": "Pool healthy (50.0% utilized - 10/20 active)",
#     "metadata": {
#         "pool_size": 10,
#         "active_connections": 10,
#         "idle_connections": 0,
#         "max_connections": 20,
#         "min_connections": 5,
#         "usage_percentage": 50.0
#     }
# }
```

**What it checks:**
- Connection pool availability
- Active vs idle connections
- Pool utilization percentage
- Warnings when utilization > 75%

### 3. Kubernetes Integration Patterns

**Documented**: Complete Kubernetes health probe patterns

```python
from fastapi import status
from fastapi.responses import JSONResponse

# Liveness Probe - is the process alive?
@app.get("/health/live")
async def liveness():
    return {"status": "ok"}  # Don't check dependencies!

# Readiness Probe - can it serve traffic?
@app.get("/ready")
async def readiness():
    result = await health.run_checks()

    if result["status"] == "degraded":
        return JSONResponse(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            content=result,
        )

    return result
```

**Kubernetes manifest example:**
```yaml
livenessProbe:
  httpGet:
    path: /health/live
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /ready
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 5
```

### 4. Production-Ready Example

**New**: `examples/health_check_example.py`

Complete production-ready example (229 lines) showing:
- Multiple endpoint patterns (`/health`, `/health/simple`, `/ready`, `/health/live`)
- Pre-built checks (database, pool)
- Custom checks (Redis, external APIs, S3)
- Kubernetes integration
- Best practices

### 5. Comprehensive Documentation

**Updated**: `docs/deployment/monitoring.md` (+440 lines)

Complete guide including:
- Overview & quick start (5-minute setup)
- Pre-built health checks documentation
- Custom health check patterns
- Kubernetes integration (liveness/readiness/startup)
- Multiple endpoints pattern
- **5 Best Practices:**
  1. Keep liveness lightweight (don't check dependencies)
  2. Use readiness for dependencies
  3. Add timeouts to external checks
  4. Include metadata for debugging
  5. Don't expose sensitive information
- Complete API reference

## 📦 Installation

```bash
pip install --upgrade fraiseql==0.11.0
```

## 🔄 Migration Guide

### No Breaking Changes!

This is a **feature addition release**. Your existing code continues to work without modification.

### Optional: Add Health Checks

If you want to use the new HealthCheck utility:

```python
# 1. Import the utilities
from fraiseql.monitoring import (
    HealthCheck,
    check_database,
    check_pool_stats,
    CheckResult,
    HealthStatus,
)

# 2. Create health check instance
health = HealthCheck()

# 3. Register checks
health.add_check("database", check_database)
health.add_check("database_pool", check_pool_stats)

# 4. Add endpoint
@app.get("/health")
async def health_endpoint():
    result = await health.run_checks()
    result["service"] = "your-service-name"
    return result

# 5. (Optional) Add Kubernetes probes
@app.get("/ready")
async def readiness():
    result = await health.run_checks()
    if result["status"] == "degraded":
        from fastapi.responses import JSONResponse
        return JSONResponse(status_code=503, content=result)
    return result

@app.get("/health/live")
async def liveness():
    return {"status": "ok"}
```

**Estimated migration time**: 5-10 minutes

## 📊 What's Better

| Aspect | Before v0.11.0 | After v0.11.0 |
|--------|----------------|---------------|
| **Health Check Pattern** | Manual implementation | Composable HealthCheck class |
| **Database Check** | Write from scratch | Pre-built `check_database()` |
| **Pool Stats** | Write from scratch | Pre-built `check_pool_stats()` |
| **Exception Handling** | Manual try/catch | Automatic handling |
| **Status Aggregation** | Manual logic | Automatic aggregation |
| **Kubernetes Patterns** | Not documented | Comprehensive guide |
| **Documentation** | Basic examples | 440-line production guide |
| **Production Example** | None | 229-line complete example |

## 🎯 Impact Summary

### Who Benefits?
- **All FraiseQL applications** - Standard health check pattern
- **Production deployments** - Kubernetes-ready monitoring
- **Multi-service architectures** - Consistent health check format
- **Development teams** - Faster implementation, less boilerplate

### Key Metrics
- **New API exports**: 6 (HealthCheck, CheckResult, HealthStatus, CheckFunction, check_database, check_pool_stats)
- **Lines of implementation**: 565 (health.py + health_checks.py + tests)
- **Test coverage**: 17 tests, 100% passing
- **Documentation**: 440 lines in monitoring.md
- **Production example**: 229 lines with best practices
- **Development time saved**: ~2-4 hours per application

### Production Readiness
- ✅ Full test coverage (17 tests)
- ✅ Type-safe (all functions typed)
- ✅ Exception handling (automatic)
- ✅ Kubernetes-ready (liveness/readiness patterns)
- ✅ Best practices documented
- ✅ Production example included

## 🔗 Documentation

### New Documentation
1. **[Health Checks Guide](../deployment/monitoring.md#health-checks)** - Complete 440-line guide
2. **[Health Check Example](../../examples/health_check_example.py)** - Production-ready example

### API Reference

**Classes:**
- `HealthCheck` - Composable health check runner
- `CheckResult` - Health check result data class
- `HealthStatus` - Enum: `HEALTHY`, `UNHEALTHY`, `DEGRADED`

**Pre-built Checks:**
- `check_database()` - Database connectivity check
- `check_pool_stats()` - Connection pool statistics

**Imports:**
```python
from fraiseql.monitoring import (
    HealthCheck,
    CheckResult,
    HealthStatus,
    CheckFunction,
    check_database,
    check_pool_stats,
)
```

## 💡 For New Users

If you're just starting with FraiseQL v0.11.0:

1. **[5-Minute Quickstart](../getting-started/quickstart.md)** - Get started with FraiseQL
2. **[Health Checks Guide](../deployment/monitoring.md#health-checks)** - Add production monitoring
3. **[Health Check Example](../../examples/health_check_example.py)** - Copy-paste ready code

## 🙏 Credits

This release was implemented using **Test-Driven Development (TDD)** methodology across 4 phases:
- **Phase 1**: Core HealthCheck class (10 tests)
- **Phase 2**: Database connectivity check (4 tests)
- **Phase 3**: Pool statistics check (3 tests)
- **Phase 4**: Integration examples and documentation

All tests passing with 100% coverage of health check functionality.

## 📝 Notes

### Version Numbering
- **0.10.4**: Documentation improvements & consistency
- **0.11.0**: HealthCheck utility & composable monitoring (this release)

### Why Minor Version Bump?
This release introduces **new public API** (`HealthCheck`, `check_database`, `check_pool_stats`) and **new functionality** (composable health check pattern) while maintaining **backward compatibility**. According to semantic versioning, this qualifies as a **minor release**.

### Implementation Approach
- ✅ **Framework provides pattern** (not opinionated endpoints)
- ✅ **Framework provides helpers** (pre-built checks)
- ✅ **Application controls composition** (what to check)
- ✅ **Follows user's existing pattern** (based on printoptim_backend)

### Future Improvements
Potential enhancements for future releases:
- Additional pre-built checks (Redis, S3, external APIs)
- Health check middleware for automatic registration
- Metrics integration (expose health check duration)
- GraphQL health query support

---

**Upgrade today for production-ready health monitoring!** 🚀

```bash
pip install --upgrade fraiseql==0.11.0
```

## 🤖 Generated

This release was developed with assistance from [Claude Code](https://claude.com/claude-code).

Co-Authored-By: Claude <noreply@anthropic.com>
