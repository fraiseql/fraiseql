/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */

interface FieldDefinition {
  type: string;
  nullable?: boolean;
  description?: string;
  requiresScope?: string;
  requiresScopes?: string[];
}

interface TypeDefinition {
  fields: Record<string, FieldDefinition>;
  description?: string;
}

interface TypeInfo {
  name: string;
  fields: Record<string, FieldDefinition>;
  description?: string;
}

/**
 * Central registry for GraphQL type definitions
 */
class SchemaRegistry {
  private static instance: SchemaRegistry;
  private types: Map<string, TypeInfo> = new Map();

  private constructor() {}

  static getInstance(): SchemaRegistry {
    if (!SchemaRegistry.instance) {
      SchemaRegistry.instance = new SchemaRegistry();
    }
    return SchemaRegistry.instance;
  }

  register(name: string, definition: TypeDefinition): void {
    this.types.set(name, {
      name,
      fields: definition.fields,
      description: definition.description,
    });
  }

  getTypeNames(): string[] {
    return Array.from(this.types.keys());
  }

  getType(name: string): TypeInfo | undefined {
    return this.types.get(name);
  }

  clear(): void {
    this.types.clear();
  }
}

/**
 * Schema API for type registration and export
 */
export class Schema {
  /**
   * Register a type definition
   * @param name The type name
   * @param definition The type definition with fields
   */
  static registerType(name: string, definition: TypeDefinition): void {
    // Validate and extract scopes from fields
    const validatedDefinition: TypeDefinition = {
      fields: {},
      description: definition.description,
    };

    for (const [fieldName, fieldConfig] of Object.entries(definition.fields)) {
      const validatedField: FieldDefinition = { ...fieldConfig };

      // Validate scope if present
      if (fieldConfig.requiresScope) {
        Schema.validateScope(fieldConfig.requiresScope, name, fieldName);
      }

      // Validate scopes array if present
      if (fieldConfig.requiresScopes) {
        if (fieldConfig.requiresScopes.length === 0) {
          throw new Error(
            `Field ${name}.${fieldName} has empty scopes array`
          );
        }
        for (const scope of fieldConfig.requiresScopes) {
          if (scope === '') {
            throw new Error(
              `Field ${name}.${fieldName} has empty scope in scopes array`
            );
          }
          Schema.validateScope(scope, name, fieldName);
        }
      }

      // Ensure not both scope and scopes
      if (fieldConfig.requiresScope && fieldConfig.requiresScopes) {
        throw new Error(
          `Field ${name}.${fieldName} cannot have both requiresScope and requiresScopes`
        );
      }

      validatedDefinition.fields[fieldName] = validatedField;
    }

    const registry = SchemaRegistry.getInstance();
    registry.register(name, validatedDefinition);
  }

  /**
   * Export minimal schema with only types (TOML workflow)
   *
   * Returns JSON containing only the "types" section.
   * All operational configuration (queries, mutations, federation, security, observers)
   * comes from fraiseql.toml and is merged during compilation.
   *
   * @param pretty Pretty-print JSON (true = formatted, false = compact)
   * @returns JSON string with types only
   */
  static exportTypes(pretty: boolean = true): string {
    const registry = SchemaRegistry.getInstance();
    const typeNames = registry.getTypeNames();

    // Build minimal schema with only types
    const types: any[] = [];
    for (const typeName of typeNames) {
      const typeInfo = registry.getType(typeName);
      if (typeInfo) {
        const typeObj: any = {
          name: typeName,
          fields: [],
        };

        if (typeInfo.description) {
          typeObj.description = typeInfo.description;
        }

        // Convert fields object to array format
        for (const [fieldName, field] of Object.entries(typeInfo.fields)) {
          const fieldObj: any = {
            name: fieldName,
            type: field.type,
            nullable: field.nullable ?? false,
          };

          // Include scope fields if present
          if (field.requiresScope) {
            fieldObj.requiresScope = field.requiresScope;
          }
          if (field.requiresScopes) {
            fieldObj.requiresScopes = field.requiresScopes;
          }

          typeObj.fields.push(fieldObj);
        }

        types.push(typeObj);
      }
    }

    const minimalSchema = {
      types,
    };

    // Export as JSON
    if (pretty) {
      return JSON.stringify(minimalSchema, null, 2);
    } else {
      return JSON.stringify(minimalSchema);
    }
  }

  /**
   * Export minimal types to a file
   *
   * @param outputPath File path for types.json
   */
  static exportTypesFile(outputPath: string): void {
    const fs = require('fs');
    const path = require('path');

    const typesJson = Schema.exportTypes(true);

    try {
      // Ensure directory exists
      const dir = path.dirname(outputPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(outputPath, typesJson, 'utf-8');

      // Print summary
      const registry = SchemaRegistry.getInstance();
      const typesCount = registry.getTypeNames().length;

      console.log(`âœ… Types exported to ${outputPath}`);
      console.log(`   Types: ${typesCount}`);
      console.log('');
      console.log('ðŸŽ¯ Next steps:');
      console.log('   1. fraiseql compile fraiseql.toml --types ' + outputPath);
      console.log('   2. This merges types with TOML configuration');
      console.log('   3. Result: schema.compiled.json with types + all config');
    } catch (error) {
      throw new Error(`Failed to write types file: ${outputPath}`);
    }
  }

  /**
   * Reset schema registry (useful for testing)
   */
  static reset(): void {
    const registry = SchemaRegistry.getInstance();
    registry.clear();
  }

  /**
   * Get all registered type names
   * @returns Array of type names
   */
  static getTypeNames(): string[] {
    const registry = SchemaRegistry.getInstance();
    return registry.getTypeNames();
  }

  /**
   * Get the registry instance (for testing purposes)
   */
  static getTypeRegistry(): SchemaRegistry {
    return SchemaRegistry.getInstance();
  }

  /**
   * Validate scope format: action:resource
   * Valid patterns:
   * - * (global wildcard)
   * - action:resource (read:user.email, write:User.salary)
   * - action:* (admin:*, read:*)
   */
  private static validateScope(
    scope: string,
    typeName: string,
    fieldName: string
  ): void {
    if (scope === '') {
      throw new Error(`Field ${typeName}.${fieldName} has empty scope`);
    }

    // Global wildcard is always valid
    if (scope === '*') {
      return;
    }

    // Must contain at least one colon
    if (!scope.includes(':')) {
      throw new Error(
        `Field ${typeName}.${fieldName} has invalid scope '${scope}' (missing colon)`
      );
    }

    const parts = scope.split(':', 2);
    if (parts.length !== 2) {
      throw new Error(
        `Field ${typeName}.${fieldName} has invalid scope '${scope}'`
      );
    }

    const action = parts[0];
    const resource = parts[1];

    // Validate action: [a-zA-Z_][a-zA-Z0-9_]*
    if (!Schema.isValidAction(action)) {
      throw new Error(
        `Field ${typeName}.${fieldName} has invalid action in scope '${scope}' (must be alphanumeric + underscore)`
      );
    }

    // Validate resource: [a-zA-Z_][a-zA-Z0-9_.]*|*
    if (!Schema.isValidResource(resource)) {
      throw new Error(
        `Field ${typeName}.${fieldName} has invalid resource in scope '${scope}' (must be alphanumeric + underscore + dot, or *)`
      );
    }
  }

  /**
   * Check if action matches [a-zA-Z_][a-zA-Z0-9_]*
   */
  private static isValidAction(action: string): boolean {
    if (action === '') {
      return false;
    }

    // First character must be letter or underscore
    const firstChar = action[0];
    if (!/[a-zA-Z_]/.test(firstChar)) {
      return false;
    }

    // Rest must be letters, digits, or underscores
    for (let i = 1; i < action.length; i++) {
      const ch = action[i];
      if (!/[a-zA-Z0-9_]/.test(ch)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Check if resource matches [a-zA-Z_][a-zA-Z0-9_.]*|*
   */
  private static isValidResource(resource: string): boolean {
    if (resource === '*') {
      return true;
    }

    if (resource === '') {
      return false;
    }

    // First character must be letter or underscore
    const firstChar = resource[0];
    if (!/[a-zA-Z_]/.test(firstChar)) {
      return false;
    }

    // Rest must be letters, digits, underscores, or dots
    for (let i = 1; i < resource.length; i++) {
      const ch = resource[i];
      if (!/[a-zA-Z0-9_.]/.test(ch)) {
        return false;
      }
    }

    return true;
  }
}
