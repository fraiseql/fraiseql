/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */

interface FieldDefinition {
  type: string;
  nullable?: boolean;
  description?: string;
}

interface TypeDefinition {
  fields: Record<string, FieldDefinition>;
  description?: string;
}

interface TypeInfo {
  name: string;
  fields: Record<string, FieldDefinition>;
  description?: string;
}

/**
 * Central registry for GraphQL type definitions
 */
class SchemaRegistry {
  private static instance: SchemaRegistry;
  private types: Map<string, TypeInfo> = new Map();

  private constructor() {}

  static getInstance(): SchemaRegistry {
    if (!SchemaRegistry.instance) {
      SchemaRegistry.instance = new SchemaRegistry();
    }
    return SchemaRegistry.instance;
  }

  register(name: string, definition: TypeDefinition): void {
    this.types.set(name, {
      name,
      fields: definition.fields,
      description: definition.description,
    });
  }

  getTypeNames(): string[] {
    return Array.from(this.types.keys());
  }

  getType(name: string): TypeInfo | undefined {
    return this.types.get(name);
  }

  clear(): void {
    this.types.clear();
  }
}

/**
 * Schema API for type registration and export
 */
export class Schema {
  /**
   * Register a type definition
   * @param name The type name
   * @param definition The type definition with fields
   */
  static registerType(name: string, definition: TypeDefinition): void {
    const registry = SchemaRegistry.getInstance();
    registry.register(name, definition);
  }

  /**
   * Export minimal schema with only types (TOML workflow)
   *
   * Returns JSON containing only the "types" section.
   * All operational configuration (queries, mutations, federation, security, observers)
   * comes from fraiseql.toml and is merged during compilation.
   *
   * @param pretty Pretty-print JSON (true = formatted, false = compact)
   * @returns JSON string with types only
   */
  static exportTypes(pretty: boolean = true): string {
    const registry = SchemaRegistry.getInstance();
    const typeNames = registry.getTypeNames();

    // Build minimal schema with only types
    const types: any[] = [];
    for (const typeName of typeNames) {
      const typeInfo = registry.getType(typeName);
      if (typeInfo) {
        const typeObj: any = {
          name: typeName,
          fields: [],
        };

        if (typeInfo.description) {
          typeObj.description = typeInfo.description;
        }

        // Convert fields object to array format
        for (const [fieldName, field] of Object.entries(typeInfo.fields)) {
          typeObj.fields.push({
            name: fieldName,
            type: field.type,
            nullable: field.nullable ?? false,
          });
        }

        types.push(typeObj);
      }
    }

    const minimalSchema = {
      types,
    };

    // Export as JSON
    if (pretty) {
      return JSON.stringify(minimalSchema, null, 2);
    } else {
      return JSON.stringify(minimalSchema);
    }
  }

  /**
   * Export minimal types to a file
   *
   * @param outputPath File path for types.json
   */
  static exportTypesFile(outputPath: string): void {
    const fs = require('fs');
    const path = require('path');

    const typesJson = Schema.exportTypes(true);

    try {
      // Ensure directory exists
      const dir = path.dirname(outputPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(outputPath, typesJson, 'utf-8');

      // Print summary
      const registry = SchemaRegistry.getInstance();
      const typesCount = registry.getTypeNames().length;

      console.log(`âœ… Types exported to ${outputPath}`);
      console.log(`   Types: ${typesCount}`);
      console.log('');
      console.log('ðŸŽ¯ Next steps:');
      console.log('   1. fraiseql compile fraiseql.toml --types ' + outputPath);
      console.log('   2. This merges types with TOML configuration');
      console.log('   3. Result: schema.compiled.json with types + all config');
    } catch (error) {
      throw new Error(`Failed to write types file: ${outputPath}`);
    }
  }

  /**
   * Reset schema registry (useful for testing)
   */
  static reset(): void {
    const registry = SchemaRegistry.getInstance();
    registry.clear();
  }

  /**
   * Get all registered type names
   * @returns Array of type names
   */
  static getTypeNames(): string[] {
    const registry = SchemaRegistry.getInstance();
    return registry.getTypeNames();
  }
}
