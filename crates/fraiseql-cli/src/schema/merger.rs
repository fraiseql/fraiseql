//! Schema merger - combines language-generated types.json with TOML configuration
//!
//! This module merges:
//! - types.json: Generated by language implementations (Python, Go, etc.)
//! - fraiseql.toml: Configuration (security, federation, observers, caching, etc.)
//!
//! Result: Complete IntermediateSchema ready for compilation

use anyhow::{Context, Result};
use serde_json::{json, Value};
use std::fs;
use std::path::Path;

use crate::config::TomlSchema;
use crate::schema::IntermediateSchema;

/// Schema merger combining language types and TOML config
pub struct SchemaMerger;

impl SchemaMerger {
    /// Merge types.json file with TOML configuration
    ///
    /// # Arguments
    /// * `types_path` - Path to types.json (from language implementation)
    /// * `toml_path` - Path to fraiseql.toml (configuration)
    ///
    /// # Returns
    /// Combined IntermediateSchema
    pub fn merge_files(types_path: &str, toml_path: &str) -> Result<IntermediateSchema> {
        // Load types.json
        let types_json = fs::read_to_string(types_path)
            .context(format!("Failed to read types.json from {types_path}"))?;
        let types_value: Value = serde_json::from_str(&types_json)
            .context("Failed to parse types.json")?;

        // Load TOML
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        // Validate TOML
        toml_schema.validate()?;

        // Merge
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge TOML-only (no types.json)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with inline type definitions
    ///
    /// # Returns
    /// IntermediateSchema from TOML definitions
    pub fn merge_toml_only(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Convert TOML to intermediate schema
        let types_value = toml_schema.to_intermediate_schema();
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge JSON types with TOML schema
    fn merge_values(types_value: &Value, toml_schema: &TomlSchema) -> Result<IntermediateSchema> {
        // Start with types from JSON
        let mut merged = serde_json::json!({
            "types": {},
            "queries": {},
            "mutations": {},
        });

        // Copy types from types.json
        if let Some(types_obj) = types_value.get("types") {
            if let Value::Object(types_map) = types_obj {
                for (type_name, type_value) in types_map {
                    merged["types"][type_name] = type_value.clone();

                    // Enrich with TOML metadata if available
                    if let Some(toml_type) = toml_schema.types.get(type_name) {
                        merged["types"][type_name]["sql_source"] = json!(toml_type.sql_source);
                        if let Some(desc) = &toml_type.description {
                            merged["types"][type_name]["description"] = json!(desc);
                        }
                    }
                }
            }
        }

        // Add types from TOML that aren't in types.json
        for (type_name, toml_type) in &toml_schema.types {
            if !merged["types"].get(type_name).is_some() {
                merged["types"][type_name] = json!({
                    "name": type_name,
                    "sql_source": toml_type.sql_source,
                    "description": toml_type.description,
                    "fields": toml_type.fields.iter().map(|(fname, fdef)| {
                        (fname.clone(), json!({
                            "type": fdef.field_type,
                            "nullable": fdef.nullable,
                            "description": fdef.description,
                        }))
                    }).collect::<serde_json::Map<String, Value>>()
                });
            }
        }

        // Copy queries from types.json
        if let Some(queries_obj) = types_value.get("queries") {
            if let Value::Object(queries_map) = queries_obj {
                for (query_name, query_value) in queries_map {
                    merged["queries"][query_name] = query_value.clone();
                }
            }
        }

        // Add queries from TOML
        for (query_name, toml_query) in &toml_schema.queries {
            merged["queries"][query_name] = json!({
                "name": query_name,
                "return_type": toml_query.return_type,
                "return_array": toml_query.return_array,
                "sql_source": toml_query.sql_source,
                "description": toml_query.description,
                "args": toml_query.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add mutations from TOML
        for (mutation_name, toml_mutation) in &toml_schema.mutations {
            merged["mutations"][mutation_name] = json!({
                "name": mutation_name,
                "return_type": toml_mutation.return_type,
                "sql_source": toml_mutation.sql_source,
                "operation": toml_mutation.operation,
                "description": toml_mutation.description,
                "args": toml_mutation.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add federation config if enabled
        if toml_schema.federation.enabled {
            merged["federation"] = json!({
                "enabled": true,
                "apollo_version": toml_schema.federation.apollo_version,
                "entities": toml_schema.federation.entities.iter().map(|e| json!({
                    "name": e.name,
                    "key_fields": e.key_fields,
                })).collect::<Vec<_>>(),
            });
        }

        // Add security configuration
        merged["security"] = json!({
            "default_policy": toml_schema.security.default_policy,
            "rules": toml_schema.security.rules.iter().map(|r| json!({
                "name": r.name,
                "rule": r.rule,
                "description": r.description,
                "cacheable": r.cacheable,
                "cache_ttl_seconds": r.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "policies": toml_schema.security.policies.iter().map(|p| json!({
                "name": p.name,
                "type": p.policy_type,
                "rule": p.rule,
                "roles": p.roles,
                "strategy": p.strategy,
                "attributes": p.attributes,
                "description": p.description,
                "cache_ttl_seconds": p.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "field_auth": toml_schema.security.field_auth.iter().map(|fa| json!({
                "type_name": fa.type_name,
                "field_name": fa.field_name,
                "policy": fa.policy,
            })).collect::<Vec<_>>(),
            "enterprise": json!({
                "rate_limiting_enabled": toml_schema.security.enterprise.rate_limiting_enabled,
                "auth_endpoint_max_requests": toml_schema.security.enterprise.auth_endpoint_max_requests,
                "auth_endpoint_window_seconds": toml_schema.security.enterprise.auth_endpoint_window_seconds,
                "audit_logging_enabled": toml_schema.security.enterprise.audit_logging_enabled,
                "audit_log_backend": toml_schema.security.enterprise.audit_log_backend,
                "audit_retention_days": toml_schema.security.enterprise.audit_retention_days,
                "error_sanitization": toml_schema.security.enterprise.error_sanitization,
                "hide_implementation_details": toml_schema.security.enterprise.hide_implementation_details,
                "constant_time_comparison": toml_schema.security.enterprise.constant_time_comparison,
                "pkce_enabled": toml_schema.security.enterprise.pkce_enabled,
            }),
        });

        // Add observers configuration if enabled
        if toml_schema.observers.enabled {
            merged["observers"] = json!({
                "enabled": true,
                "backend": toml_schema.observers.backend,
                "redis_url": toml_schema.observers.redis_url,
                "handlers": toml_schema.observers.handlers.iter().map(|h| json!({
                    "name": h.name,
                    "event": h.event,
                    "action": h.action,
                    "webhook_url": h.webhook_url,
                    "retry_strategy": h.retry_strategy,
                    "max_retries": h.max_retries,
                    "description": h.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add caching configuration if enabled
        if toml_schema.caching.enabled {
            merged["caching"] = json!({
                "enabled": true,
                "backend": toml_schema.caching.backend,
                "redis_url": toml_schema.caching.redis_url,
                "rules": toml_schema.caching.rules.iter().map(|r| json!({
                    "query": r.query,
                    "ttl_seconds": r.ttl_seconds,
                    "invalidation_triggers": r.invalidation_triggers,
                })).collect::<Vec<_>>(),
            });
        }

        // Add analytics configuration if enabled
        if toml_schema.analytics.enabled {
            merged["analytics"] = json!({
                "enabled": true,
                "queries": toml_schema.analytics.queries.iter().map(|q| json!({
                    "name": q.name,
                    "sql_source": q.sql_source,
                    "description": q.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add schema metadata
        merged["schema"] = json!({
            "name": toml_schema.schema.name,
            "version": toml_schema.schema.version,
            "description": toml_schema.schema.description,
            "database_target": toml_schema.schema.database_target,
        });

        // Convert to IntermediateSchema
        serde_json::from_value::<IntermediateSchema>(merged)
            .context("Failed to convert merged schema to IntermediateSchema")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_merge_toml_only() {
        let toml_content = r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[types.User]
sql_source = "v_user"

[types.User.fields.id]
type = "ID"

[types.User.fields.name]
type = "String"

[queries.users]
return_type = "User"
return_array = true
sql_source = "v_user"
"#;

        // Write temp file
        let temp_path = "/tmp/test_fraiseql.toml";
        std::fs::write(temp_path, toml_content).unwrap();

        // Merge
        let result = SchemaMerger::merge_toml_only(temp_path);
        assert!(result.is_ok());

        // Clean up
        let _ = std::fs::remove_file(temp_path);
    }
}
