//! Schema merger - combines language-generated types.json with TOML configuration
//!
//! This module merges:
//! - types.json: Generated by language implementations (Python, Go, etc.)
//! - fraiseql.toml: Configuration (security, federation, observers, caching, etc.)
//!
//! Result: Complete IntermediateSchema ready for compilation

use anyhow::{Context, Result};
use serde_json::{json, Value};
use std::fs;

use crate::config::TomlSchema;
use crate::schema::IntermediateSchema;

/// Schema merger combining language types and TOML config
pub struct SchemaMerger;

impl SchemaMerger {
    /// Merge types.json file with TOML configuration
    ///
    /// # Arguments
    /// * `types_path` - Path to types.json (from language implementation)
    /// * `toml_path` - Path to fraiseql.toml (configuration)
    ///
    /// # Returns
    /// Combined IntermediateSchema
    pub fn merge_files(types_path: &str, toml_path: &str) -> Result<IntermediateSchema> {
        // Load types.json
        let types_json = fs::read_to_string(types_path)
            .context(format!("Failed to read types.json from {types_path}"))?;
        let types_value: Value = serde_json::from_str(&types_json)
            .context("Failed to parse types.json")?;

        // Load TOML
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        // Validate TOML
        toml_schema.validate()?;

        // Merge
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge TOML-only (no types.json)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with inline type definitions
    ///
    /// # Returns
    /// IntermediateSchema from TOML definitions
    pub fn merge_toml_only(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Convert TOML to intermediate schema
        let types_value = toml_schema.to_intermediate_schema();
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge with TOML includes (glob patterns for schema files)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with schema.includes section
    ///
    /// # Returns
    /// IntermediateSchema from loaded files + TOML definitions
    pub fn merge_with_includes(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // If includes are specified, load and merge files
        let types_value = if !toml_schema.includes.is_empty() {
            let resolved = toml_schema
                .includes
                .resolve_globs()
                .context("Failed to resolve glob patterns in schema.includes")?;

            // Load all type files
            let type_files: Vec<std::path::PathBuf> = resolved.types;
            let mut merged_types = if !type_files.is_empty() {
                crate::schema::MultiFileLoader::load_from_paths(&type_files)
                    .context("Failed to load type files")?
            } else {
                serde_json::json!({
                    "types": [],
                    "queries": [],
                    "mutations": []
                })
            };

            // Load and merge query files
            if !resolved.queries.is_empty() {
                let query_value = crate::schema::MultiFileLoader::load_from_paths(&resolved.queries)
                    .context("Failed to load query files")?;
                if let Some(Value::Array(queries)) = query_value.get("queries") {
                    if let Some(Value::Array(existing_queries)) = merged_types.get_mut("queries") {
                        existing_queries.extend(queries.clone());
                    }
                }
            }

            // Load and merge mutation files
            if !resolved.mutations.is_empty() {
                let mutation_value =
                    crate::schema::MultiFileLoader::load_from_paths(&resolved.mutations)
                        .context("Failed to load mutation files")?;
                if let Some(Value::Array(mutations)) = mutation_value.get("mutations") {
                    if let Some(Value::Array(existing_mutations)) = merged_types.get_mut("mutations") {
                        existing_mutations.extend(mutations.clone());
                    }
                }
            }

            merged_types
        } else {
            // No includes specified, use empty schema
            serde_json::json!({
                "types": [],
                "queries": [],
                "mutations": []
            })
        };

        // Merge with TOML definitions
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge JSON types with TOML schema
    fn merge_values(types_value: &Value, toml_schema: &TomlSchema) -> Result<IntermediateSchema> {
        // Start with arrays for types, queries, mutations (not objects!)
        // This matches IntermediateSchema structure which uses Vec<T>
        let mut types_array: Vec<Value> = Vec::new();
        let mut queries_array: Vec<Value> = Vec::new();
        let mut mutations_array: Vec<Value> = Vec::new();

        // Process types from types.json (comes as array from language SDKs)
        if let Some(types_obj) = types_value.get("types") {
            match types_obj {
                // Handle array format (from language SDKs)
                Value::Array(types_list) => {
                    for type_item in types_list {
                        if let Some(type_name) = type_item.get("name").and_then(|v| v.as_str()) {
                            let mut enriched_type = type_item.clone();

                            // Enrich with TOML metadata if available
                            if let Some(toml_type) = toml_schema.types.get(type_name) {
                                enriched_type["sql_source"] = json!(toml_type.sql_source);
                                if let Some(desc) = &toml_type.description {
                                    enriched_type["description"] = json!(desc);
                                }
                            }

                            types_array.push(enriched_type);
                        }
                    }
                }
                // Handle object format (from TOML-only, for backward compatibility)
                Value::Object(types_map) => {
                    for (type_name, type_value) in types_map {
                        let mut enriched_type = type_value.clone();
                        enriched_type["name"] = json!(type_name);

                        // Convert fields from object to array format if needed
                        if let Some(Value::Object(fields_map)) = enriched_type.get("fields") {
                            let fields_array: Vec<Value> = fields_map
                                .iter()
                                .map(|(field_name, field_value)| {
                                    let mut field = field_value.clone();
                                    field["name"] = json!(field_name);
                                    field
                                })
                                .collect();
                            enriched_type["fields"] = json!(fields_array);
                        }

                        if let Some(toml_type) = toml_schema.types.get(type_name) {
                            enriched_type["sql_source"] = json!(toml_type.sql_source);
                            if let Some(desc) = &toml_type.description {
                                enriched_type["description"] = json!(desc);
                            }
                        }

                        types_array.push(enriched_type);
                    }
                }
                _ => {}
            }
        }

        // Add types from TOML that aren't already in types_array
        let existing_type_names: std::collections::HashSet<_> = types_array
            .iter()
            .filter_map(|t| t.get("name").and_then(|v| v.as_str()).map(|s| s.to_string()))
            .collect();

        for (type_name, toml_type) in &toml_schema.types {
            if !existing_type_names.contains(type_name) {
                types_array.push(json!({
                    "name": type_name,
                    "sql_source": toml_type.sql_source,
                    "description": toml_type.description,
                    "fields": toml_type.fields.iter().map(|(fname, fdef)| json!({
                        "name": fname,
                        "type": fdef.field_type,
                        "nullable": fdef.nullable,
                        "description": fdef.description,
                    })).collect::<Vec<_>>(),
                }));
            }
        }

        // Process queries (similar array-based approach)
        if let Some(queries_obj) = types_value.get("queries") {
            if let Value::Array(queries_list) = queries_obj {
                queries_array = queries_list.clone();
            }
        }

        // Add queries from TOML
        for (query_name, toml_query) in &toml_schema.queries {
            queries_array.push(json!({
                "name": query_name,
                "return_type": toml_query.return_type,
                "return_array": toml_query.return_array,
                "sql_source": toml_query.sql_source,
                "description": toml_query.description,
                "args": toml_query.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            }));
        }

        // Process mutations (similar array-based approach)
        if let Some(mutations_obj) = types_value.get("mutations") {
            if let Value::Array(mutations_list) = mutations_obj {
                mutations_array = mutations_list.clone();
            }
        }

        // Add mutations from TOML
        for (mutation_name, toml_mutation) in &toml_schema.mutations {
            mutations_array.push(json!({
                "name": mutation_name,
                "return_type": toml_mutation.return_type,
                "sql_source": toml_mutation.sql_source,
                "operation": toml_mutation.operation,
                "description": toml_mutation.description,
                "args": toml_mutation.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            }));
        }

        // Build merged schema with arrays
        let mut merged = serde_json::json!({
            "version": "2.0.0",
            "types": types_array,
            "queries": queries_array,
            "mutations": mutations_array,
        });

        // Add federation config if enabled
        if toml_schema.federation.enabled {
            merged["federation"] = json!({
                "enabled": true,
                "apollo_version": toml_schema.federation.apollo_version,
                "entities": toml_schema.federation.entities.iter().map(|e| json!({
                    "name": e.name,
                    "key_fields": e.key_fields,
                })).collect::<Vec<_>>(),
            });
        }

        // Add security configuration
        merged["security"] = json!({
            "default_policy": toml_schema.security.default_policy,
            "rules": toml_schema.security.rules.iter().map(|r| json!({
                "name": r.name,
                "rule": r.rule,
                "description": r.description,
                "cacheable": r.cacheable,
                "cache_ttl_seconds": r.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "policies": toml_schema.security.policies.iter().map(|p| json!({
                "name": p.name,
                "type": p.policy_type,
                "rule": p.rule,
                "roles": p.roles,
                "strategy": p.strategy,
                "attributes": p.attributes,
                "description": p.description,
                "cache_ttl_seconds": p.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "field_auth": toml_schema.security.field_auth.iter().map(|fa| json!({
                "type_name": fa.type_name,
                "field_name": fa.field_name,
                "policy": fa.policy,
            })).collect::<Vec<_>>(),
            "enterprise": json!({
                "rate_limiting_enabled": toml_schema.security.enterprise.rate_limiting_enabled,
                "auth_endpoint_max_requests": toml_schema.security.enterprise.auth_endpoint_max_requests,
                "auth_endpoint_window_seconds": toml_schema.security.enterprise.auth_endpoint_window_seconds,
                "audit_logging_enabled": toml_schema.security.enterprise.audit_logging_enabled,
                "audit_log_backend": toml_schema.security.enterprise.audit_log_backend,
                "audit_retention_days": toml_schema.security.enterprise.audit_retention_days,
                "error_sanitization": toml_schema.security.enterprise.error_sanitization,
                "hide_implementation_details": toml_schema.security.enterprise.hide_implementation_details,
                "constant_time_comparison": toml_schema.security.enterprise.constant_time_comparison,
                "pkce_enabled": toml_schema.security.enterprise.pkce_enabled,
            }),
        });

        // Add observers configuration if enabled
        if toml_schema.observers.enabled {
            merged["observers"] = json!({
                "enabled": true,
                "backend": toml_schema.observers.backend,
                "redis_url": toml_schema.observers.redis_url,
                "handlers": toml_schema.observers.handlers.iter().map(|h| json!({
                    "name": h.name,
                    "event": h.event,
                    "action": h.action,
                    "webhook_url": h.webhook_url,
                    "retry_strategy": h.retry_strategy,
                    "max_retries": h.max_retries,
                    "description": h.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add caching configuration if enabled
        if toml_schema.caching.enabled {
            merged["caching"] = json!({
                "enabled": true,
                "backend": toml_schema.caching.backend,
                "redis_url": toml_schema.caching.redis_url,
                "rules": toml_schema.caching.rules.iter().map(|r| json!({
                    "query": r.query,
                    "ttl_seconds": r.ttl_seconds,
                    "invalidation_triggers": r.invalidation_triggers,
                })).collect::<Vec<_>>(),
            });
        }

        // Add analytics configuration if enabled
        if toml_schema.analytics.enabled {
            merged["analytics"] = json!({
                "enabled": true,
                "queries": toml_schema.analytics.queries.iter().map(|q| json!({
                    "name": q.name,
                    "sql_source": q.sql_source,
                    "description": q.description,
                })).collect::<Vec<_>>(),
            });
        }

        // Add schema metadata
        merged["schema"] = json!({
            "name": toml_schema.schema.name,
            "version": toml_schema.schema.version,
            "description": toml_schema.schema.description,
            "database_target": toml_schema.schema.database_target,
        });

        // Convert to IntermediateSchema
        serde_json::from_value::<IntermediateSchema>(merged)
            .context("Failed to convert merged schema to IntermediateSchema")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_merge_toml_only() {
        let toml_content = r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[types.User]
sql_source = "v_user"

[types.User.fields.id]
type = "ID"

[types.User.fields.name]
type = "String"

[queries.users]
return_type = "User"
return_array = true
sql_source = "v_user"
"#;

        // Write temp file
        let temp_path = "/tmp/test_fraiseql.toml";
        std::fs::write(temp_path, toml_content).unwrap();

        // Merge
        let result = SchemaMerger::merge_toml_only(temp_path);
        assert!(result.is_ok());

        // Clean up
        let _ = std::fs::remove_file(temp_path);
    }

    #[test]
    fn test_merge_with_includes() -> Result<()> {
        let temp_dir = TempDir::new()?;

        // Create schema files
        let user_types = serde_json::json!({
            "types": [{"name": "User", "fields": []}],
            "queries": [],
            "mutations": []
        });
        fs::write(
            temp_dir.path().join("user.json"),
            user_types.to_string(),
        )?;

        let post_types = serde_json::json!({
            "types": [{"name": "Post", "fields": []}],
            "queries": [],
            "mutations": []
        });
        fs::write(
            temp_dir.path().join("post.json"),
            post_types.to_string(),
        )?;

        // Create TOML with includes
        let toml_content = format!(
            r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[includes]
types = ["{}/*.json"]
queries = []
mutations = []
"#,
            temp_dir.path().to_string_lossy()
        );

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        // Merge
        let result = SchemaMerger::merge_with_includes(toml_path.to_str().unwrap());
        assert!(result.is_ok());

        let schema = result?;
        assert_eq!(schema.types.len(), 2);

        Ok(())
    }

    #[test]
    fn test_merge_with_includes_missing_files() -> Result<()> {
        let temp_dir = TempDir::new()?;

        let toml_content = r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[schema.includes]
types = ["/nonexistent/path/*.json"]
queries = []
mutations = []
"#;

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        // Should succeed but with no files loaded (glob matches nothing)
        let result = SchemaMerger::merge_with_includes(toml_path.to_str().unwrap());
        assert!(result.is_ok());

        let schema = result?;
        assert_eq!(schema.types.len(), 0);

        Ok(())
    }
}
