//! Schema merger - combines language-generated types.json with TOML configuration
//!
//! This module merges:
//! - types.json: Generated by language implementations (Python, Go, etc.)
//! - fraiseql.toml: Configuration (security, federation, observers, caching, etc.)
//!
//! Result: Complete IntermediateSchema ready for compilation

use anyhow::{Context, Result};
use serde_json::{json, Value};
use std::fs;

use crate::config::TomlSchema;
use crate::schema::IntermediateSchema;

/// Schema merger combining language types and TOML config
pub struct SchemaMerger;

impl SchemaMerger {
    /// Merge types.json file with TOML configuration
    ///
    /// # Arguments
    /// * `types_path` - Path to types.json (from language implementation)
    /// * `toml_path` - Path to fraiseql.toml (configuration)
    ///
    /// # Returns
    /// Combined IntermediateSchema
    pub fn merge_files(types_path: &str, toml_path: &str) -> Result<IntermediateSchema> {
        // Load types.json
        let types_json = fs::read_to_string(types_path)
            .context(format!("Failed to read types.json from {types_path}"))?;
        let types_value: Value = serde_json::from_str(&types_json)
            .context("Failed to parse types.json")?;

        // Load TOML
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        // Note: TOML validation is skipped here because queries may reference types
        // from types.json (not yet loaded). Validation happens in the compiler after merge.

        // Merge
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge TOML-only (no types.json)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with inline type definitions
    ///
    /// # Returns
    /// IntermediateSchema from TOML definitions
    pub fn merge_toml_only(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Convert TOML to intermediate schema
        let types_value = toml_schema.to_intermediate_schema();
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge from directory with auto-discovery
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml (configuration)
    /// * `schema_dir` - Path to directory containing schema files
    ///
    /// # Returns
    /// IntermediateSchema from loaded files + TOML definitions
    pub fn merge_from_directory(toml_path: &str, schema_dir: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Load all files from directory
        let types_value = crate::schema::MultiFileLoader::load_from_directory(schema_dir)
            .context(format!("Failed to load schema from directory {schema_dir}"))?;

        // Merge with TOML definitions
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge explicit file lists
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml (configuration)
    /// * `type_files` - Vector of type file paths
    /// * `query_files` - Vector of query file paths
    /// * `mutation_files` - Vector of mutation file paths
    ///
    /// # Returns
    /// IntermediateSchema from loaded files + TOML definitions
    pub fn merge_explicit_files(
        toml_path: &str,
        type_files: &[String],
        query_files: &[String],
        mutation_files: &[String],
    ) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Load explicit files
        let mut types_value = serde_json::json!({
            "types": [],
            "queries": [],
            "mutations": []
        });

        // Load type files
        if !type_files.is_empty() {
            let type_paths: Vec<std::path::PathBuf> =
                type_files.iter().map(|f| std::path::PathBuf::from(f)).collect();
            let loaded = crate::schema::MultiFileLoader::load_from_paths(&type_paths)
                .context("Failed to load type files")?;
            if let Some(types_array) = loaded.get("types") {
                types_value["types"] = types_array.clone();
            }
        }

        // Load query files
        if !query_files.is_empty() {
            let query_paths: Vec<std::path::PathBuf> =
                query_files.iter().map(|f| std::path::PathBuf::from(f)).collect();
            let loaded = crate::schema::MultiFileLoader::load_from_paths(&query_paths)
                .context("Failed to load query files")?;
            if let Some(queries_array) = loaded.get("queries") {
                types_value["queries"] = queries_array.clone();
            }
        }

        // Load mutation files
        if !mutation_files.is_empty() {
            let mutation_paths: Vec<std::path::PathBuf> =
                mutation_files.iter().map(|f| std::path::PathBuf::from(f)).collect();
            let loaded = crate::schema::MultiFileLoader::load_from_paths(&mutation_paths)
                .context("Failed to load mutation files")?;
            if let Some(mutations_array) = loaded.get("mutations") {
                types_value["mutations"] = mutations_array.clone();
            }
        }

        // Merge with TOML definitions
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge from domains (domain-based organization)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with domain_discovery enabled
    ///
    /// # Returns
    /// IntermediateSchema from all domains (types.json, queries.json, mutations.json)
    pub fn merge_from_domains(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // Resolve domains from configuration
        let domains = toml_schema
            .domain_discovery
            .resolve_domains()
            .context("Failed to discover domains")?;

        if domains.is_empty() {
            // No domains found, return empty schema merged with TOML definitions
            let empty_value = serde_json::json!({
                "types": [],
                "queries": [],
                "mutations": []
            });
            return Self::merge_values(&empty_value, &toml_schema);
        }

        // Load types from all domains
        let mut all_types = Vec::new();
        let mut all_queries = Vec::new();
        let mut all_mutations = Vec::new();

        for domain in domains {
            // Load {domain}/types.json if it exists
            let types_path = domain.path.join("types.json");
            if types_path.exists() {
                let content = fs::read_to_string(&types_path)
                    .context(format!("Failed to read {}", types_path.display()))?;
                let value: Value = serde_json::from_str(&content)
                    .context(format!("Failed to parse {}", types_path.display()))?;

                if let Some(Value::Array(type_items)) = value.get("types") {
                    all_types.extend(type_items.clone());
                }
                if let Some(Value::Array(query_items)) = value.get("queries") {
                    all_queries.extend(query_items.clone());
                }
                if let Some(Value::Array(mutation_items)) = value.get("mutations") {
                    all_mutations.extend(mutation_items.clone());
                }
            }

            // Load {domain}/queries.json if it exists
            let queries_path = domain.path.join("queries.json");
            if queries_path.exists() {
                let content = fs::read_to_string(&queries_path)
                    .context(format!("Failed to read {}", queries_path.display()))?;
                let value: Value = serde_json::from_str(&content)
                    .context(format!("Failed to parse {}", queries_path.display()))?;

                if let Some(Value::Array(query_items)) = value.get("queries") {
                    all_queries.extend(query_items.clone());
                }
            }

            // Load {domain}/mutations.json if it exists
            let mutations_path = domain.path.join("mutations.json");
            if mutations_path.exists() {
                let content = fs::read_to_string(&mutations_path)
                    .context(format!("Failed to read {}", mutations_path.display()))?;
                let value: Value = serde_json::from_str(&content)
                    .context(format!("Failed to parse {}", mutations_path.display()))?;

                if let Some(Value::Array(mutation_items)) = value.get("mutations") {
                    all_mutations.extend(mutation_items.clone());
                }
            }
        }

        let types_value = serde_json::json!({
            "types": all_types,
            "queries": all_queries,
            "mutations": all_mutations,
        });

        // Merge with TOML definitions
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge with TOML includes (glob patterns for schema files)
    ///
    /// # Arguments
    /// * `toml_path` - Path to fraiseql.toml with schema.includes section
    ///
    /// # Returns
    /// IntermediateSchema from loaded files + TOML definitions
    pub fn merge_with_includes(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)
            .context(format!("Failed to load TOML from {toml_path}"))?;

        toml_schema.validate()?;

        // If includes are specified, load and merge files
        let types_value = if !toml_schema.includes.is_empty() {
            let resolved = toml_schema
                .includes
                .resolve_globs()
                .context("Failed to resolve glob patterns in schema.includes")?;

            // Load all type files
            let type_files: Vec<std::path::PathBuf> = resolved.types;
            let mut merged_types = if !type_files.is_empty() {
                crate::schema::MultiFileLoader::load_from_paths(&type_files)
                    .context("Failed to load type files")?
            } else {
                serde_json::json!({
                    "types": [],
                    "queries": [],
                    "mutations": []
                })
            };

            // Load and merge query files
            if !resolved.queries.is_empty() {
                let query_value = crate::schema::MultiFileLoader::load_from_paths(&resolved.queries)
                    .context("Failed to load query files")?;
                if let Some(Value::Array(queries)) = query_value.get("queries") {
                    if let Some(Value::Array(existing_queries)) = merged_types.get_mut("queries") {
                        existing_queries.extend(queries.clone());
                    }
                }
            }

            // Load and merge mutation files
            if !resolved.mutations.is_empty() {
                let mutation_value =
                    crate::schema::MultiFileLoader::load_from_paths(&resolved.mutations)
                        .context("Failed to load mutation files")?;
                if let Some(Value::Array(mutations)) = mutation_value.get("mutations") {
                    if let Some(Value::Array(existing_mutations)) = merged_types.get_mut("mutations") {
                        existing_mutations.extend(mutations.clone());
                    }
                }
            }

            merged_types
        } else {
            // No includes specified, use empty schema
            serde_json::json!({
                "types": [],
                "queries": [],
                "mutations": []
            })
        };

        // Merge with TOML definitions
        Self::merge_values(&types_value, &toml_schema)
    }

    /// Merge JSON types with TOML schema
    fn merge_values(types_value: &Value, toml_schema: &TomlSchema) -> Result<IntermediateSchema> {
        // Start with arrays for types, queries, mutations (not objects!)
        // This matches IntermediateSchema structure which uses Vec<T>
        let mut types_array: Vec<Value> = Vec::new();
        let mut queries_array: Vec<Value> = Vec::new();
        let mut mutations_array: Vec<Value> = Vec::new();

        // Process types from types.json (comes as array from language SDKs)
        if let Some(types_obj) = types_value.get("types") {
            match types_obj {
                // Handle array format (from language SDKs)
                Value::Array(types_list) => {
                    for type_item in types_list {
                        if let Some(type_name) = type_item.get("name").and_then(|v| v.as_str()) {
                            let mut enriched_type = type_item.clone();

                            // Enrich with TOML metadata if available
                            if let Some(toml_type) = toml_schema.types.get(type_name) {
                                enriched_type["sql_source"] = json!(toml_type.sql_source);
                                if let Some(desc) = &toml_type.description {
                                    enriched_type["description"] = json!(desc);
                                }
                            }

                            types_array.push(enriched_type);
                        }
                    }
                }
                // Handle object format (from TOML-only, for backward compatibility)
                Value::Object(types_map) => {
                    for (type_name, type_value) in types_map {
                        let mut enriched_type = type_value.clone();
                        enriched_type["name"] = json!(type_name);

                        // Convert fields from object to array format if needed
                        if let Some(Value::Object(fields_map)) = enriched_type.get("fields") {
                            let fields_array: Vec<Value> = fields_map
                                .iter()
                                .map(|(field_name, field_value)| {
                                    let mut field = field_value.clone();
                                    field["name"] = json!(field_name);
                                    field
                                })
                                .collect();
                            enriched_type["fields"] = json!(fields_array);
                        }

                        if let Some(toml_type) = toml_schema.types.get(type_name) {
                            enriched_type["sql_source"] = json!(toml_type.sql_source);
                            if let Some(desc) = &toml_type.description {
                                enriched_type["description"] = json!(desc);
                            }
                        }

                        types_array.push(enriched_type);
                    }
                }
                _ => {}
            }
        }

        // Add types from TOML that aren't already in types_array
        let existing_type_names: std::collections::HashSet<_> = types_array
            .iter()
            .filter_map(|t| t.get("name").and_then(|v| v.as_str()).map(|s| s.to_string()))
            .collect();

        for (type_name, toml_type) in &toml_schema.types {
            if !existing_type_names.contains(type_name) {
                types_array.push(json!({
                    "name": type_name,
                    "sql_source": toml_type.sql_source,
                    "description": toml_type.description,
                    "fields": toml_type.fields.iter().map(|(fname, fdef)| json!({
                        "name": fname,
                        "type": fdef.field_type,
                        "nullable": fdef.nullable,
                        "description": fdef.description,
                    })).collect::<Vec<_>>(),
                }));
            }
        }

        // Process queries (similar array-based approach)
        if let Some(queries_obj) = types_value.get("queries") {
            if let Value::Array(queries_list) = queries_obj {
                queries_array = queries_list.clone();
            }
        }

        // Add queries from TOML
        for (query_name, toml_query) in &toml_schema.queries {
            queries_array.push(json!({
                "name": query_name,
                "return_type": toml_query.return_type,
                "return_array": toml_query.return_array,
                "sql_source": toml_query.sql_source,
                "description": toml_query.description,
                "args": toml_query.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            }));
        }

        // Process mutations (similar array-based approach)
        if let Some(mutations_obj) = types_value.get("mutations") {
            if let Value::Array(mutations_list) = mutations_obj {
                mutations_array = mutations_list.clone();
            }
        }

        // Add mutations from TOML
        for (mutation_name, toml_mutation) in &toml_schema.mutations {
            mutations_array.push(json!({
                "name": mutation_name,
                "return_type": toml_mutation.return_type,
                "sql_source": toml_mutation.sql_source,
                "operation": toml_mutation.operation,
                "description": toml_mutation.description,
                "args": toml_mutation.args.iter().map(|arg| json!({
                    "name": arg.name,
                    "type": arg.arg_type,
                    "required": arg.required,
                    "default": arg.default,
                    "description": arg.description,
                })).collect::<Vec<_>>(),
            }));
        }

        // Build merged schema with arrays
        let mut merged = serde_json::json!({
            "version": "2.0.0",
            "types": types_array,
            "queries": queries_array,
            "mutations": mutations_array,
        });

        // Add security configuration if available in TOML
        merged["security"] = json!({
            "default_policy": toml_schema.security.default_policy,
            "rules": toml_schema.security.rules.iter().map(|r| json!({
                "name": r.name,
                "rule": r.rule,
                "description": r.description,
                "cacheable": r.cacheable,
                "cache_ttl_seconds": r.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "policies": toml_schema.security.policies.iter().map(|p| json!({
                "name": p.name,
                "type": p.policy_type,
                "rule": p.rule,
                "roles": p.roles,
                "strategy": p.strategy,
                "attributes": p.attributes,
                "description": p.description,
                "cache_ttl_seconds": p.cache_ttl_seconds,
            })).collect::<Vec<_>>(),
            "field_auth": toml_schema.security.field_auth.iter().map(|fa| json!({
                "type_name": fa.type_name,
                "field_name": fa.field_name,
                "policy": fa.policy,
            })).collect::<Vec<_>>(),
            "enterprise": json!({
                "rate_limiting_enabled": toml_schema.security.enterprise.rate_limiting_enabled,
                "auth_endpoint_max_requests": toml_schema.security.enterprise.auth_endpoint_max_requests,
                "auth_endpoint_window_seconds": toml_schema.security.enterprise.auth_endpoint_window_seconds,
                "audit_logging_enabled": toml_schema.security.enterprise.audit_logging_enabled,
                "audit_log_backend": toml_schema.security.enterprise.audit_log_backend,
                "audit_retention_days": toml_schema.security.enterprise.audit_retention_days,
                "error_sanitization": toml_schema.security.enterprise.error_sanitization,
                "hide_implementation_details": toml_schema.security.enterprise.hide_implementation_details,
                "constant_time_comparison": toml_schema.security.enterprise.constant_time_comparison,
                "pkce_enabled": toml_schema.security.enterprise.pkce_enabled,
            }),
        });

        // Note: Federation, caching, observers, and analytics configuration
        // are available in TOML but not included in IntermediateSchema to keep
        // it language-agnostic and focused on schema definition

        // Convert to IntermediateSchema
        serde_json::from_value::<IntermediateSchema>(merged)
            .context("Failed to convert merged schema to IntermediateSchema")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_merge_toml_only() {
        let toml_content = r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[types.User]
sql_source = "v_user"

[types.User.fields.id]
type = "ID"

[types.User.fields.name]
type = "String"

[queries.users]
return_type = "User"
return_array = true
sql_source = "v_user"
"#;

        // Write temp file
        let temp_path = "/tmp/test_fraiseql.toml";
        std::fs::write(temp_path, toml_content).unwrap();

        // Merge
        let result = SchemaMerger::merge_toml_only(temp_path);
        assert!(result.is_ok());

        // Clean up
        let _ = std::fs::remove_file(temp_path);
    }

    #[test]
    fn test_merge_with_includes() -> Result<()> {
        let temp_dir = TempDir::new()?;

        // Create schema files
        let user_types = serde_json::json!({
            "types": [{"name": "User", "fields": []}],
            "queries": [],
            "mutations": []
        });
        fs::write(
            temp_dir.path().join("user.json"),
            user_types.to_string(),
        )?;

        let post_types = serde_json::json!({
            "types": [{"name": "Post", "fields": []}],
            "queries": [],
            "mutations": []
        });
        fs::write(
            temp_dir.path().join("post.json"),
            post_types.to_string(),
        )?;

        // Create TOML with includes
        let toml_content = format!(
            r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[includes]
types = ["{}/*.json"]
queries = []
mutations = []
"#,
            temp_dir.path().to_string_lossy()
        );

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        // Merge
        let result = SchemaMerger::merge_with_includes(toml_path.to_str().unwrap());
        assert!(result.is_ok());

        let schema = result?;
        assert_eq!(schema.types.len(), 2);

        Ok(())
    }

    #[test]
    fn test_merge_with_includes_missing_files() -> Result<()> {
        let temp_dir = TempDir::new()?;

        let toml_content = r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[includes]
types = ["/nonexistent/path/*.json"]
queries = []
mutations = []
"#;

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        // Should succeed but with no files loaded (glob matches nothing)
        let result = SchemaMerger::merge_with_includes(toml_path.to_str().unwrap());
        assert!(result.is_ok());

        let schema = result?;
        assert_eq!(schema.types.len(), 0);

        Ok(())
    }

    #[test]
    fn test_merge_from_domains() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let schema_dir = temp_dir.path().join("schema");
        fs::create_dir(&schema_dir)?;

        // Create domain structure
        fs::create_dir(schema_dir.join("auth"))?;
        fs::create_dir(schema_dir.join("products"))?;

        let auth_types = serde_json::json!({
            "types": [{"name": "User", "fields": []}],
            "queries": [{"name": "getUser", "return_type": "User"}],
            "mutations": []
        });
        fs::write(schema_dir.join("auth/types.json"), auth_types.to_string())?;

        let product_types = serde_json::json!({
            "types": [{"name": "Product", "fields": []}],
            "queries": [{"name": "getProduct", "return_type": "Product"}],
            "mutations": []
        });
        fs::write(
            schema_dir.join("products/types.json"),
            product_types.to_string(),
        )?;

        // Create TOML with domain discovery (use absolute path)
        let schema_dir_str = schema_dir.to_string_lossy().to_string();
        let toml_content = format!(
            r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[domain_discovery]
enabled = true
root_dir = "{}"
"#,
            schema_dir_str
        );

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        // Merge
        let result = SchemaMerger::merge_from_domains(toml_path.to_str().unwrap());

        assert!(result.is_ok());
        let schema = result?;

        // Should have 2 types (from both domains)
        assert_eq!(schema.types.len(), 2);
        // Should have 2 queries (from both domains)
        assert_eq!(schema.queries.len(), 2);

        Ok(())
    }

    #[test]
    fn test_merge_from_domains_alphabetical_order() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let schema_dir = temp_dir.path().join("schema");
        fs::create_dir(&schema_dir)?;

        // Create domains in non-alphabetical order
        fs::create_dir(schema_dir.join("zebra"))?;
        fs::create_dir(schema_dir.join("alpha"))?;
        fs::create_dir(schema_dir.join("middle"))?;

        for domain in &["zebra", "alpha", "middle"] {
            let types = serde_json::json!({
                "types": [{"name": domain.to_uppercase(), "fields": []}],
                "queries": [],
                "mutations": []
            });
            fs::write(
                schema_dir.join(format!("{}/types.json", domain)),
                types.to_string(),
            )?;
        }

        let schema_dir_str = schema_dir.to_string_lossy().to_string();
        let toml_content = format!(
            r#"
[schema]
name = "test"
version = "1.0.0"
database_target = "postgresql"

[database]
url = "postgresql://localhost/test"

[domain_discovery]
enabled = true
root_dir = "{}"
"#,
            schema_dir_str
        );

        let toml_path = temp_dir.path().join("fraiseql.toml");
        fs::write(&toml_path, toml_content)?;

        let result = SchemaMerger::merge_from_domains(toml_path.to_str().unwrap());

        assert!(result.is_ok());
        let schema = result?;

        // Types should be loaded in alphabetical order: ALPHA, MIDDLE, ZEBRA
        let type_names: Vec<String> = schema.types.iter().map(|t| t.name.clone()).collect();

        assert_eq!(type_names[0], "ALPHA");
        assert_eq!(type_names[1], "MIDDLE");
        assert_eq!(type_names[2], "ZEBRA");

        Ok(())
    }
}
