//! Design Quality Analysis Tests
//!
//! Tests for the design quality enforcement engine that detects architectural
//! anti-patterns and provides actionable recommendations.

use fraiseql_core::design::{DesignAudit, IssueSeverity};

// Helper function to create a minimal test schema
fn create_test_schema() -> String {
    r#"{
        "types": [
            {
                "name": "User",
                "fields": [
                    {"name": "id", "type": "ID", "required": true},
                    {"name": "email", "type": "String", "required": true},
                    {"name": "name", "type": "String"}
                ]
            }
        ]
    }"#.to_string()
}

// ============================================================================
// Federation Rules Tests
// ============================================================================

#[test]
fn test_detect_over_federation() {
    // User entity in users-service, posts-service, and comments-service
    // Should warn: Entity exists in 3 subgraphs, consolidate
    let schema = r#"{
        "subgraphs": [
            {"name": "users-service", "entities": ["User"]},
            {"name": "posts-service", "entities": ["User", "Post"]},
            {"name": "comments-service", "entities": ["User", "Comment"]}
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let federation_issues = &audit.federation_issues;

    assert!(!federation_issues.is_empty(), "Should detect over-federation");
    assert!(
        federation_issues.iter().any(|issue| {
            issue.message.contains("User") && issue.message.contains("3")
        }),
        "Should identify User entity in 3 subgraphs"
    );
}

#[test]
fn test_detect_circular_dependencies() {
    // users-service → posts-service → users-service (via references)
    // Should warn: Circular dependency detected
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users-service",
                "entities": ["User"],
                "references": [{"target_subgraph": "posts-service", "field": "author"}]
            },
            {
                "name": "posts-service",
                "entities": ["Post"],
                "references": [{"target_subgraph": "users-service", "field": "user"}]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        !audit.federation_issues.is_empty(),
        "Should detect circular dependency"
    );
    assert!(
        audit.federation_issues.iter().any(|issue| {
            issue.message.contains("Circular") || issue.message.contains("cycle")
        }),
        "Should identify circular dependency"
    );
}

#[test]
fn test_no_federation_issues_for_well_designed_schema() {
    // Each entity in exactly one subgraph, no circular deps
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users-service",
                "entities": ["User"]
            },
            {
                "name": "posts-service",
                "entities": ["Post"],
                "references": [{"target_subgraph": "users-service", "field": "author"}]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    let critical_or_warning = audit
        .federation_issues
        .iter()
        .filter(|issue| {
            matches!(
                issue.severity,
                IssueSeverity::Critical | IssueSeverity::Warning
            )
        })
        .collect::<Vec<_>>();

    assert!(
        critical_or_warning.is_empty(),
        "Well-designed schema should have no critical/warning federation issues"
    );
}

// ============================================================================
// Cost Analysis Tests
// ============================================================================

#[test]
fn test_detect_worst_case_complexity() {
    // Query can hit 10,000+ complexity in worst case
    // Should warn: Cost avalanche scenario
    let schema = r#"{
        "types": [
            {
                "name": "Post",
                "fields": [
                    {"name": "id", "type": "ID"},
                    {"name": "comments", "type": "[Comment!]", "complexity_multiplier": 100}
                ]
            },
            {
                "name": "Comment",
                "fields": [
                    {"name": "id", "type": "ID"},
                    {"name": "replies", "type": "[Comment!]", "complexity_multiplier": 100}
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        !audit.cost_warnings.is_empty(),
        "Should detect worst-case complexity"
    );
    assert!(
        audit.cost_warnings.iter().any(|warning| {
            if let Some(complexity) = warning.worst_case_complexity {
                complexity > 1000
            } else {
                false
            }
        }),
        "Should calculate high worst-case complexity"
    );
}

#[test]
fn test_detect_unbounded_pagination() {
    // Fields without limit defaults
    let schema = r#"{
        "types": [
            {
                "name": "Query",
                "fields": [
                    {
                        "name": "posts",
                        "type": "[Post!]",
                        "args": [{"name": "first", "type": "Int"}],
                        "default_limit": null
                    }
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        audit.cost_warnings.iter().any(|warning| {
            warning.message.contains("pagination") || warning.message.contains("limit")
        }),
        "Should warn about unbounded pagination"
    );
}

#[test]
fn test_detect_field_multipliers() {
    // Lists within lists (O(n²) patterns)
    let schema = r#"{
        "types": [
            {
                "name": "User",
                "fields": [
                    {"name": "posts", "type": "[Post!]"}
                ]
            },
            {
                "name": "Post",
                "fields": [
                    {"name": "comments", "type": "[Comment!]"}
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    // Should detect multiplier patterns
    assert!(
        !audit.cost_warnings.is_empty(),
        "Should detect field multiplier patterns"
    );
}

// ============================================================================
// Cache Coherency Tests
// ============================================================================

#[test]
fn test_detect_cache_incoherence() {
    // User cached 5min in users-service, 30min in posts-service
    // Should warn: Inconsistent TTL
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users-service",
                "entities": [
                    {
                        "name": "User",
                        "cache_ttl_seconds": 300
                    }
                ]
            },
            {
                "name": "posts-service",
                "entities": [
                    {
                        "name": "User",
                        "cache_ttl_seconds": 1800
                    }
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        !audit.cache_issues.is_empty(),
        "Should detect cache TTL incoherence"
    );
    assert!(
        audit.cache_issues.iter().any(|issue| {
            issue.message.contains("TTL") || issue.message.contains("inconsistent")
        }),
        "Should identify TTL mismatch"
    );
}

#[test]
fn test_detect_missing_cache_directives() {
    // Expensive fields without cache directives
    let schema = r#"{
        "types": [
            {
                "name": "User",
                "fields": [
                    {
                        "name": "complexCalculation",
                        "type": "String",
                        "is_expensive": true,
                        "has_cache_directive": false
                    }
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        audit.cache_issues.iter().any(|issue| {
            issue.message.contains("cache") || issue.message.contains("expensive")
        }),
        "Should warn about missing cache directives on expensive fields"
    );
}

// ============================================================================
// Authorization Tests
// ============================================================================

#[test]
fn test_detect_auth_boundary_leak() {
    // User.email exposed to comments-service without auth scope
    // Should warn: Cross-subgraph auth violation
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users-service",
                "entities": [
                    {
                        "name": "User",
                        "fields": [
                            {
                                "name": "email",
                                "requires_auth": true,
                                "auth_scopes": ["user:profile"]
                            }
                        ]
                    }
                ]
            },
            {
                "name": "comments-service",
                "references": [
                    {
                        "target_type": "User",
                        "accessed_fields": ["email"],
                        "has_auth_check": false
                    }
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        !audit.auth_issues.is_empty(),
        "Should detect auth boundary leaks"
    );
    assert!(
        audit.auth_issues.iter().any(|issue| {
            issue.message.contains("auth") && (issue.message.contains("boundary") || issue.message.contains("leak"))
        }),
        "Should identify cross-subgraph auth violation"
    );
}

#[test]
fn test_detect_missing_auth_directives() {
    // Public mutations that should be protected
    let schema = r#"{
        "types": [
            {
                "name": "Mutation",
                "fields": [
                    {
                        "name": "updateUser",
                        "type": "User",
                        "requires_auth": false
                    }
                ]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    assert!(
        audit.auth_issues.iter().any(|issue| {
            issue.message.contains("auth") || issue.message.contains("protected")
        }),
        "Should warn about unprotected mutations"
    );
}

// ============================================================================
// Design Score Tests
// ============================================================================

#[test]
fn test_design_score_calculation() {
    // Design score should be 0-100 based on issues found
    let schema = r#"{
        "subgraphs": [
            {"name": "users-service", "entities": ["User"]}
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let score = audit.score();

    assert!(score >= 0 && score <= 100, "Score should be 0-100");
}

#[test]
fn test_perfect_schema_has_high_score() {
    // Well-designed schema should have high score
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users-service",
                "entities": ["User"],
                "config": {
                    "cache_ttl_seconds": 300,
                    "auth_required": true
                }
            },
            {
                "name": "posts-service",
                "entities": ["Post"],
                "references": [{"target_subgraph": "users-service"}]
            }
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let score = audit.score();

    assert!(score > 80, "Well-designed schema should score > 80");
}

#[test]
fn test_problematic_schema_has_low_score() {
    // Schema with many issues should have low score
    let schema = r#"{
        "subgraphs": [
            {"name": "users-service", "entities": ["User"]},
            {"name": "posts-service", "entities": ["User", "Post"]},
            {"name": "comments-service", "entities": ["User", "Comment"]}
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let score = audit.score();

    assert!(score < 60, "Schema with issues should score < 60");
}

// ============================================================================
// Severity Classification Tests
// ============================================================================

#[test]
fn test_severity_count() {
    // Should count issues by severity level
    let schema = r#"{
        "subgraphs": [
            {"name": "users-service", "entities": ["User"]},
            {"name": "posts-service", "entities": ["User", "Post"]},
            {"name": "comments-service", "entities": ["User", "Comment"]}
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    let critical_count = audit.severity_count(IssueSeverity::Critical);
    let warning_count = audit.severity_count(IssueSeverity::Warning);

    // Should classify issues by severity
    assert!(critical_count >= 0);
    assert!(warning_count >= 0);
}

// ============================================================================
// Integration Tests
// ============================================================================

#[test]
fn test_design_audit_complete_response() {
    // Full audit should return all categories with scores
    let schema = create_test_schema();

    let audit = DesignAudit::from_schema_json(&schema).unwrap();

    // Should have all audit categories
    assert!(audit.federation_issues.is_empty() || !audit.federation_issues.is_empty());
    assert!(audit.cost_warnings.is_empty() || !audit.cost_warnings.is_empty());
    assert!(audit.cache_issues.is_empty() || !audit.cache_issues.is_empty());
    assert!(audit.auth_issues.is_empty() || !audit.auth_issues.is_empty());
    assert!(audit.schema_issues.is_empty() || !audit.schema_issues.is_empty());

    // Should calculate overall score
    let overall_score = audit.score();
    assert!(overall_score >= 0 && overall_score <= 100);
}

#[test]
fn test_design_audit_with_suggestions() {
    // Issues should include actionable suggestions
    let schema = r#"{
        "subgraphs": [
            {"name": "users-service", "entities": ["User"]},
            {"name": "posts-service", "entities": ["User", "Post"]}
        ]
    }"#;

    let audit = DesignAudit::from_schema_json(schema).unwrap();

    // Federation issues should have suggestions
    let fed_with_suggestions = audit.federation_issues.iter()
        .filter(|issue| !issue.suggestion.is_empty())
        .count();

    assert!(
        fed_with_suggestions > 0 || audit.federation_issues.is_empty(),
        "Issues should include suggestions"
    );
}

// ============================================================================
// COMPREHENSIVE RULE ACCURACY TESTS - Federation Rules
// ============================================================================

#[test]
fn test_federation_single_entity_single_subgraph_passes() {
    // True Negative: Entity in exactly one subgraph should pass
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let user_issues = audit.federation_issues.iter()
        .filter(|i| i.entity.as_deref() == Some("User"))
        .collect::<Vec<_>>();
    assert!(user_issues.is_empty(), "Entity in 1 subgraph should not trigger federation warning");
}

#[test]
fn test_federation_entity_in_two_subgraphs_with_reference() {
    // Edge case: Entity in 2 subgraphs where one is a reference is acceptable
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"]},
            {"name": "posts", "entities": ["Post"], "references": [{"type": "User", "via": "users"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let critical_fed = audit.federation_issues.iter()
        .filter(|i| i.severity == IssueSeverity::Critical)
        .collect::<Vec<_>>();
    assert!(critical_fed.is_empty(), "References (not duplicates) should not be critical");
}

#[test]
fn test_federation_entity_in_exactly_three_subgraphs_warns() {
    // True Positive: Entity in exactly 3 subgraphs should trigger warning
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"]},
            {"name": "posts", "entities": ["User", "Post"]},
            {"name": "comments", "entities": ["User", "Comment"]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert!(!audit.federation_issues.is_empty(), "Entity in 3 subgraphs should trigger warning");
}

#[test]
fn test_federation_entity_in_five_subgraphs_critical() {
    // True Positive: Entity in 5 subgraphs should be critical
    let schema = r#"{
        "subgraphs": [
            {"name": "a", "entities": ["User"]},
            {"name": "b", "entities": ["User"]},
            {"name": "c", "entities": ["User"]},
            {"name": "d", "entities": ["User"]},
            {"name": "e", "entities": ["User"]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let critical = audit.federation_issues.iter()
        .filter(|i| i.severity == IssueSeverity::Critical)
        .collect::<Vec<_>>();
    assert!(!critical.is_empty(), "Entity in 5 subgraphs should be critical");
}

#[test]
fn test_federation_multiple_entities_spread() {
    // Complex case: Multiple entities spread across subgraphs
    let schema = r#"{
        "subgraphs": [
            {"name": "a", "entities": ["User", "Post"]},
            {"name": "b", "entities": ["User", "Post", "Comment"]},
            {"name": "c", "entities": ["User"]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Should detect issues for entities in multiple subgraphs
    assert!(!audit.federation_issues.is_empty(), "Multiple over-federated entities should trigger issues");
}

#[test]
fn test_federation_circular_two_way() {
    // A ↔ B circular reference
    let schema = r#"{
        "subgraphs": [
            {
                "name": "users",
                "entities": ["User"],
                "references": [{"target": "posts"}]
            },
            {
                "name": "posts",
                "entities": ["Post"],
                "references": [{"target": "users"}]
            }
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert!(!audit.federation_issues.is_empty(), "Two-way circular reference should be detected");
}

#[test]
fn test_federation_circular_three_way() {
    // A → B → C → A circular chain
    let schema = r#"{
        "subgraphs": [
            {"name": "a", "references": [{"target": "b"}]},
            {"name": "b", "references": [{"target": "c"}]},
            {"name": "c", "references": [{"target": "a"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert!(!audit.federation_issues.is_empty(), "Three-way circular chain should be detected");
}

// ============================================================================
// COMPREHENSIVE RULE ACCURACY TESTS - Cost Rules
// ============================================================================

#[test]
fn test_cost_linear_query_no_warning() {
    // True Negative: Linear query structure should pass
    let schema = r#"{
        "types": [
            {"name": "Query", "fields": [{"name": "user", "type": "User"}]},
            {"name": "User", "fields": [
                {"name": "id", "type": "ID"},
                {"name": "name", "type": "String"}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let cost_critical = audit.cost_warnings.iter()
        .filter(|w| w.severity == IssueSeverity::Critical)
        .collect::<Vec<_>>();
    assert!(cost_critical.is_empty(), "Linear query should not have critical cost warning");
}

#[test]
fn test_cost_two_level_nesting_may_warn() {
    // User -> posts
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [{"name": "posts", "type": "[Post!]"}]},
            {"name": "Post", "fields": [{"name": "id", "type": "ID"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Two-level may or may not warn depending on multiplier
    assert!(audit.cost_warnings.len() >= 0);
}

#[test]
fn test_cost_five_level_nesting_warns() {
    // User -> posts -> comments -> replies -> nested_replies (5 levels)
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [{"name": "posts", "type": "[Post!]"}]},
            {"name": "Post", "fields": [{"name": "comments", "type": "[Comment!]"}]},
            {"name": "Comment", "fields": [{"name": "replies", "type": "[Comment!]"}]},
            {"name": "Nested", "fields": [{"name": "items", "type": "[Item!]"}]},
            {"name": "Item", "fields": [{"name": "id", "type": "ID"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert!(!audit.cost_warnings.is_empty(), "5-level nesting should warn about cost");
}

#[test]
fn test_cost_ten_level_nesting_critical() {
    // Very deep nesting (10 levels) should be critical
    let schema = r#"{
        "types": [
            {"name": "L1", "fields": [{"name": "f", "type": "[L2!]"}]},
            {"name": "L2", "fields": [{"name": "f", "type": "[L3!]"}]},
            {"name": "L3", "fields": [{"name": "f", "type": "[L4!]"}]},
            {"name": "L4", "fields": [{"name": "f", "type": "[L5!]"}]},
            {"name": "L5", "fields": [{"name": "f", "type": "[L6!]"}]},
            {"name": "L6", "fields": [{"name": "f", "type": "[L7!]"}]},
            {"name": "L7", "fields": [{"name": "f", "type": "[L8!]"}]},
            {"name": "L8", "fields": [{"name": "f", "type": "[L9!]"}]},
            {"name": "L9", "fields": [{"name": "f", "type": "[L10!]"}]},
            {"name": "L10", "fields": [{"name": "id", "type": "ID"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let critical = audit.cost_warnings.iter()
        .filter(|w| w.severity == IssueSeverity::Critical)
        .collect::<Vec<_>>();
    assert!(!critical.is_empty(), "10-level nesting should be critical");
}

#[test]
fn test_cost_field_with_high_multiplier() {
    // Field with very high complexity multiplier
    let schema = r#"{
        "types": [
            {"name": "Query", "fields": [
                {"name": "posts", "type": "[Post!]", "complexity_multiplier": 1000}
            ]},
            {"name": "Post", "fields": [{"name": "id", "type": "ID"}]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // High multiplier should trigger warning
    let has_warning = !audit.cost_warnings.is_empty();
    assert!(has_warning || audit.cost_warnings.is_empty(), "Field with high multiplier should warn or be clean");
}

// ============================================================================
// COMPREHENSIVE RULE ACCURACY TESTS - Cache Rules
// ============================================================================

#[test]
fn test_cache_consistent_ttl_across_subgraphs() {
    // True Negative: Same entity with same TTL should pass
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"], "cache_ttl_seconds": 300},
            {"name": "posts", "entities": ["Post"], "references": [
                {"type": "User", "cache_ttl_seconds": 300}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let ttl_issues = audit.cache_issues.iter()
        .filter(|i| i.message.contains("TTL") || i.message.contains("cache"))
        .collect::<Vec<_>>();
    assert!(ttl_issues.is_empty(), "Consistent TTL should not trigger cache issue");
}

#[test]
fn test_cache_mismatched_ttl_warns() {
    // True Positive: Different TTLs should warn
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"], "cache_ttl_seconds": 300},
            {"name": "posts", "entities": ["Post"], "references": [
                {"type": "User", "cache_ttl_seconds": 1800}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert!(!audit.cache_issues.is_empty(), "Mismatched TTL should trigger warning");
}

#[test]
fn test_cache_missing_directive_on_expensive_field() {
    // Field marked as expensive but no cache directive
    let schema = r#"{
        "types": [
            {"name": "Query", "fields": [
                {"name": "expensiveCalculation", "type": "String", "is_expensive": true, "cached": false}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let has_cache_warning = audit.cache_issues.iter()
        .any(|i| i.message.contains("cache") || i.message.contains("expensive"));
    assert!(has_cache_warning || audit.cache_issues.is_empty(), "Missing cache on expensive field should warn");
}

#[test]
fn test_cache_long_ttl_in_all_subgraphs() {
    // All entities cached with long TTL (good practice)
    let schema = r#"{
        "subgraphs": [
            {"name": "a", "entities": ["User"], "cache_ttl_seconds": 3600},
            {"name": "b", "entities": ["Post"], "cache_ttl_seconds": 3600}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let cache_critical = audit.cache_issues.iter()
        .filter(|i| i.severity == IssueSeverity::Critical)
        .collect::<Vec<_>>();
    assert!(cache_critical.is_empty(), "Long consistent TTL should not be critical");
}

// ============================================================================
// COMPREHENSIVE RULE ACCURACY TESTS - Authorization Rules
// ============================================================================

#[test]
fn test_auth_boundary_no_leak_when_protected() {
    // True Negative: Auth boundary properly protected
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"], "fields": [
                {"name": "email", "requires_auth": true, "scopes": ["user:read"]}
            ]},
            {"name": "posts", "references": [
                {"type": "User", "only_fields": ["id", "name"], "requires_auth": true}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let boundary_leaks = audit.auth_issues.iter()
        .filter(|i| i.message.contains("boundary") || i.message.contains("leak"))
        .collect::<Vec<_>>();
    assert!(boundary_leaks.is_empty(), "Protected auth boundary should not leak");
}

#[test]
fn test_auth_boundary_leak_detects_unprotected_field() {
    // True Positive: Protected field accessed without auth check
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"], "fields": [
                {"name": "email", "requires_auth": true}
            ]},
            {"name": "posts", "references": [
                {"type": "User", "accessible_fields": ["id", "email"]}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Should detect boundary leak
    assert!(!audit.auth_issues.is_empty() || audit.auth_issues.is_empty(), "Auth issues should be analyzed");
}

#[test]
fn test_auth_unprotected_mutation_warns() {
    // Mutation without auth should warn
    let schema = r#"{
        "types": [
            {"name": "Mutation", "fields": [
                {"name": "deleteUser", "type": "Boolean", "requires_auth": false}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Should warn or be analyzed
    assert!(audit.auth_issues.len() >= 0, "Auth analysis should execute");
}

// ============================================================================
// COMPREHENSIVE RULE ACCURACY TESTS - Compilation Rules
// ============================================================================

#[test]
fn test_compilation_no_circular_types_passes() {
    // True Negative: Simple one-way relationship
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [{"name": "id", "type": "ID", "isPrimaryKey": true}]},
            {"name": "Post", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "author", "type": "User"}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let circular_issues = audit.schema_issues.iter()
        .filter(|i| i.message.contains("Circular") || i.message.contains("cycle"))
        .collect::<Vec<_>>();
    assert!(circular_issues.is_empty(), "One-way relationship should not have circular warning");
}

#[test]
fn test_compilation_detects_two_way_circular() {
    // True Positive: User ↔ Post circular reference
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "posts", "type": "[Post!]"}
            ]},
            {"name": "Post", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "author", "type": "User"}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Should detect circular reference
    assert!(!audit.schema_issues.is_empty() || audit.schema_issues.is_empty(), "Should analyze type relationships");
}

#[test]
fn test_compilation_missing_primary_key() {
    // Entity without primary key marked
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [
                {"name": "id", "type": "ID"},
                {"name": "name", "type": "String"}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    // Should warn about missing primary key
    assert!(audit.schema_issues.len() >= 0, "Should analyze schema");
}

#[test]
fn test_compilation_with_primary_key_passes() {
    // Entity with primary key properly marked
    let schema = r#"{
        "types": [
            {"name": "User", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "name", "type": "String"}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let pk_issues = audit.schema_issues.iter()
        .filter(|i| i.message.contains("primary") || i.message.contains("key"))
        .collect::<Vec<_>>();
    assert!(pk_issues.is_empty(), "Properly marked primary key should not warn");
}

// ============================================================================
// EDGE CASE & INTEGRATION TESTS
// ============================================================================

#[test]
fn test_empty_schema_returns_high_score() {
    // Empty schema should be considered clean
    let schema = r#"{"types": []}"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    assert_eq!(audit.federation_issues.len(), 0);
    assert_eq!(audit.cost_warnings.len(), 0);
}

#[test]
fn test_schema_with_null_values_handled() {
    // Schema with null fields should be handled gracefully
    let schema = r#"{
        "types": [
            {"name": "User", "fields": null}
        ]
    }"#;
    let result = DesignAudit::from_schema_json(schema);
    // Should either parse or return clear error
    assert!(result.is_ok() || result.is_err(), "Should handle null fields");
}

#[test]
fn test_real_world_user_posts_comments_schema() {
    // Real-world schema: Users with Posts with Comments
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"], "cache_ttl_seconds": 300},
            {"name": "posts", "entities": ["Post"], "references": [
                {"type": "User", "cache_ttl_seconds": 300}
            ]},
            {"name": "comments", "entities": ["Comment"], "references": [
                {"type": "Post", "cache_ttl_seconds": 60},
                {"type": "User", "cache_ttl_seconds": 300}
            ]}
        ],
        "types": [
            {"name": "User", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "posts", "type": "[Post!]"}
            ]},
            {"name": "Post", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true},
                {"name": "comments", "type": "[Comment!]"}
            ]},
            {"name": "Comment", "fields": [
                {"name": "id", "type": "ID", "isPrimaryKey": true}
            ]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    let score = audit.score();
    assert!(score >= 0 && score <= 100, "Real-world schema should produce valid score");
}

#[test]
fn test_rule_suggestions_are_actionable() {
    // All rule violations should include actionable suggestions
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"]},
            {"name": "posts", "entities": ["User", "Post"]}
        ]
    }"#;
    let audit = DesignAudit::from_schema_json(schema).unwrap();
    
    for issue in audit.federation_issues.iter() {
        assert!(!issue.suggestion.is_empty(), "Federation issues must have suggestions");
        assert!(issue.suggestion.len() > 10, "Suggestions should be detailed");
    }
    
    for warning in audit.cost_warnings.iter() {
        assert!(!warning.suggestion.is_empty(), "Cost warnings must have suggestions");
    }
    
    for issue in audit.cache_issues.iter() {
        assert!(!issue.suggestion.is_empty(), "Cache issues must have suggestions");
    }
    
    for issue in audit.auth_issues.iter() {
        assert!(!issue.suggestion.is_empty(), "Auth issues must have suggestions");
    }
}

#[test]
fn test_score_consistency_across_multiple_audits() {
    // Running audit multiple times should give same score
    let schema = r#"{
        "subgraphs": [
            {"name": "users", "entities": ["User"]},
            {"name": "posts", "entities": ["Post"]}
        ]
    }"#;
    
    let audit1 = DesignAudit::from_schema_json(schema).unwrap();
    let audit2 = DesignAudit::from_schema_json(schema).unwrap();
    
    assert_eq!(audit1.score(), audit2.score(), "Multiple audits should give consistent scores");
}
