# PostgreSQL-Only Observer Configuration
# ==========================================
#
# This is the simplest deployment:
# - PostgreSQL LISTEN/NOTIFY for event sourcing (default)
# - No Redis (no deduplication, no caching)
# - No NATS (single-database only)
#
# Best for:
# - Single PostgreSQL database
# - Low event volume (<1000 events/sec)
# - Simple deployment (no additional infrastructure)

# Example observer: Send email when order is shipped
[[observers]]
condition = "data.status == 'shipped'"
entity = "Order"
event_type = "UPDATE"

[[observers.actions]]
body_template = "Order #{{ data.id }} is on its way."
subject = "Your order has shipped!"
to_template = "{{ data.customer_email }}"
type = "email"

[observers.on_failure]

[observers.retry]
backoff_strategy = "exponential"
initial_delay_ms = 100
max_attempts = 3
max_delay_ms = 30000

# Performance features (all disabled without Redis)
[performance]
backlog_alert_threshold = 500
# Runtime settings
channel_capacity = 1000
concurrent_timeout_ms = 30000
enable_caching = false  # No action result caching
enable_concurrent = true  # Still use concurrent action execution
enable_dedup = false  # No deduplication (at-most-once delivery)
max_concurrency = 50
max_concurrent_actions = 10
overflow_policy = "drop"
shutdown_timeout = "30s"

# Transport configuration
[transport]
run_bridge = false  # No NATS bridge
run_executors = true  # Run observers in-process
# Use PostgreSQL LISTEN/NOTIFY (default)
transport = "postgres"

# Log errors (no DLQ without Redis)
