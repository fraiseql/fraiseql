<?php

declare(strict_types=1);

namespace FraiseQL;

use FraiseQL\Security\AuthzPolicyConfig;

/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */
final class Schema
{
    private static SchemaRegistry $registry;

    /**
     * Initialize schema (called once at startup)
     */
    public static function init(): void
    {
        self::$registry = SchemaRegistry::getInstance();
    }

    /**
     * Register a type for types.json export
     *
     * @param string $name Type name
     * @param TypeInfo $typeInfo Type definition with fields
     * @return void
     */
    public static function registerType(string $name, TypeInfo $typeInfo): void
    {
        if (!isset(self::$registry)) {
            self::init();
        }

        // Store type in registry
        self::$registry->registerTypeInfo($name, $typeInfo);
    }

    /**
     * Export minimal schema with only types (TOML workflow)
     *
     * Returns JSON containing only the "types" section.
     * All operational configuration (queries, mutations, federation, security, observers)
     * comes from fraiseql.toml and is merged during compilation.
     *
     * @param bool $pretty Pretty-print JSON (true = formatted, false = compact)
     * @return string JSON string with types only
     */
    public static function exportTypes(bool $pretty = true): string
    {
        if (!isset(self::$registry)) {
            self::init();
        }

        // Get all registered types
        $types = self::$registry->getRegisteredTypes();

        // Build minimal schema with only types
        $minimalSchema = [
            'types' => $types,
        ];

        // Export as JSON
        $flags = JSON_UNESCAPED_SLASHES;
        if ($pretty) {
            $flags |= JSON_PRETTY_PRINT;
        }

        return json_encode($minimalSchema, $flags);
    }

    /**
     * Export minimal types to a file
     *
     * @param string $outputPath File path for types.json
     * @return void
     */
    public static function exportTypesFile(string $outputPath): void
    {
        $typesJson = self::exportTypes(true);

        $result = file_put_contents($outputPath, $typesJson);
        if ($result === false) {
            throw new FraiseQLException("Failed to write types file: $outputPath");
        }

        // Print summary
        if (!isset(self::$registry)) {
            self::init();
        }
        $typesCount = count(self::$registry->getRegisteredTypes());

        echo "âœ… Types exported to $outputPath\n";
        echo "   Types: $typesCount\n";
        echo "\nðŸŽ¯ Next steps:\n";
        echo "   1. fraiseql compile fraiseql.toml --types $outputPath\n";
        echo "   2. This merges types with TOML configuration\n";
        echo "   3. Result: schema.compiled.json with types + all config\n";
    }

    /**
     * Reset schema registry (useful for testing)
     */
    public static function reset(): void
    {
        // Get fresh singleton instance
        self::$registry = SchemaRegistry::getInstance();
        self::$registry->reset();
    }

    /**
     * Get all registered types
     *
     * @return array Array of type definitions
     */
    public static function getTypes(): array
    {
        if (!isset(self::$registry)) {
            self::init();
        }

        return self::$registry->getRegisteredTypes();
    }
}
