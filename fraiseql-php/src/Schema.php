<?php

declare(strict_types=1);

namespace FraiseQL;

/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */
final class Schema
{
    /**
     * Register a type from a PHP class
     *
     * @param string $className Fully qualified class name
     * @return void
     */
    public static function registerType(string $className): void
    {
        $registry = SchemaRegistry::getInstance();
        $registry->register($className);
    }

    /**
     * Export minimal schema with only types (TOML workflow)
     *
     * Returns JSON containing only the "types" section.
     * All operational configuration (queries, mutations, federation, security, observers)
     * comes from fraiseql.toml and is merged during compilation.
     *
     * @param bool $pretty Pretty-print JSON (true = formatted, false = compact)
     * @return string JSON string with types only
     */
    public static function exportTypes(bool $pretty = true): string
    {
        $registry = SchemaRegistry::getInstance();
        $typeNames = $registry->getTypeNames();

        // Build minimal schema with only types
        $types = [];
        foreach ($typeNames as $typeName) {
            $fields = $registry->getTypeFields($typeName);
            $types[] = [
                'name' => $typeName,
                'fields' => array_map(function (FieldDefinition $field) {
                    return [
                        'name' => $field->name,
                        'type' => $field->type,
                        'nullable' => $field->nullable,
                    ];
                }, $fields),
            ];
        }

        $minimalSchema = [
            'types' => $types,
        ];

        // Export as JSON
        $flags = JSON_UNESCAPED_SLASHES;
        if ($pretty) {
            $flags |= JSON_PRETTY_PRINT;
        }

        return json_encode($minimalSchema, $flags);
    }

    /**
     * Export minimal types to a file
     *
     * @param string $outputPath File path for types.json
     * @return void
     */
    public static function exportTypesFile(string $outputPath): void
    {
        $typesJson = self::exportTypes(true);

        $result = file_put_contents($outputPath, $typesJson);
        if ($result === false) {
            throw new FraiseQLException("Failed to write types file: $outputPath");
        }

        // Print summary
        $registry = SchemaRegistry::getInstance();
        $typesCount = count($registry->getTypeNames());

        echo "âœ… Types exported to $outputPath\n";
        echo "   Types: $typesCount\n";
        echo "\nðŸŽ¯ Next steps:\n";
        echo "   1. fraiseql compile fraiseql.toml --types $outputPath\n";
        echo "   2. This merges types with TOML configuration\n";
        echo "   3. Result: schema.compiled.json with types + all config\n";
    }

    /**
     * Reset schema registry (useful for testing)
     */
    public static function reset(): void
    {
        $registry = SchemaRegistry::getInstance();
        $registry->clear();
    }

    /**
     * Get all registered type names
     *
     * @return array Array of type names
     */
    public static function getTypeNames(): array
    {
        $registry = SchemaRegistry::getInstance();
        return $registry->getTypeNames();
    }
}
