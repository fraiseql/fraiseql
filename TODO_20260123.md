# FraiseQL Development TODO - January 23, 2026

## Context

This file provides context for continuing FraiseQL observer system development.

**Branch**: `feature/phase-1-foundation`
**Last Commits**:
- `e1c5fd75` - feat(phase-7): Observer Runtime - Server integration and execution loop
- `d931ffbe` - feat(phase-6): Observer Management API - CRUD endpoints and database schema

---

## What Has Been Completed

### NATS Integration (Phases 1-3) ✅
- PostgreSQL bridge with LISTEN/NOTIFY
- MySQL bridge with binlog polling
- SQL Server bridge with tiberius crate
- Event transport abstraction layer
- Checkpoint persistence for exactly-once semantics

### Phase 6: Observer Management API ✅
- Database schema: `tb_observer`, `tb_observer_log` (trinity pattern)
- Migration: `06_create_observer_management.sql`
- Full CRUD REST API:
  - `GET/POST /api/observers`
  - `GET/PATCH/DELETE /api/observers/:id`
  - `POST /api/observers/:id/enable|disable`
  - `GET /api/observers/stats`, `/api/observers/:id/stats`
  - `GET /api/observers/logs`, `/api/observers/:id/logs`
- Feature-gated with `observers` flag

### Phase 7: Observer Runtime ✅
- `ObserverRuntime` component that:
  - Loads observers from `tb_observer`
  - Converts to `ObserverDefinition` for `EventMatcher`
  - Polls `tb_entity_change_log` via `ChangeLogListener`
  - Routes events through `ObserverExecutor`
  - Manages lifecycle (start/stop)
- Health check endpoints:
  - `GET /api/observers/runtime/health`
  - `POST /api/observers/runtime/reload`
- In-memory Dead Letter Queue

---

## What Needs To Be Done Next

### Priority 1: End-to-End Integration Testing

The runtime is implemented but needs real-world testing:

1. **Create E2E test file**: `tests/e2e_observer_test.rs`
   - Test: INSERT into a table → observer webhook fires
   - Test: UPDATE with condition → observer executes only when condition matches
   - Test: Multiple observers on same entity type
   - Test: Retry logic on webhook failure
   - Test: DLQ population on permanent failure

2. **Performance benchmarks**:
   - Latency: mutation → action execution < 100ms
   - Throughput: 1000+ events/sec
   - Memory stability under load

### Priority 2: Server Startup Integration

The `ObserverRuntime` exists but isn't wired into server startup yet.

**File to modify**: `crates/fraiseql-server/src/server.rs` or `runtime_server.rs`

```rust
// Example integration pattern:
impl Server {
    pub async fn start(&mut self) -> Result<()> {
        // ... existing startup ...

        #[cfg(feature = "observers")]
        {
            let runtime_config = ObserverRuntimeConfig::new(self.pool.clone());
            let mut runtime = ObserverRuntime::new(runtime_config);
            runtime.start().await?;
            self.observer_runtime = Some(runtime);
        }
    }
}
```

### Priority 3: Production DLQ Implementation

Replace `InMemoryDlq` with PostgreSQL-backed DLQ:

**File to create**: `crates/fraiseql-server/src/observers/dlq.rs`

- Store failed actions in `tb_observer_dlq` table
- Support manual retry via API endpoint
- Retention policy (auto-delete after X days)

### Priority 4: WebSocket Support for Real-Time Notifications

Add WebSocket endpoint for clients to receive observer events:

- `WS /api/observers/ws` - Subscribe to observer execution events
- Filter by entity_type, event_type
- Use for real-time UI updates

### Priority 5: Phase 8 Features (from roadmap)

According to `.claude/PHASE_7_INTEGRATION_PLAN.md`, Phase 8 includes:
- **8A**: Full-text search integration (Elasticsearch/Meilisearch)
- **8B**: Caching & performance optimization (Redis)
- **8C**: Job queues & scheduling for long-running tasks

---

## Key Files Reference

### Observer System
```
crates/fraiseql-server/src/observers/
├── mod.rs          # Module exports
├── config.rs       # ObserverManagementConfig
├── repository.rs   # Database CRUD operations
├── handlers.rs     # HTTP handlers
├── routes.rs       # Axum routes
└── runtime.rs      # ObserverRuntime execution loop
```

### fraiseql-observers Crate
```
crates/fraiseql-observers/src/
├── listener/       # ChangeLogListener, LISTEN/NOTIFY
├── executor.rs     # ObserverExecutor
├── matcher.rs      # EventMatcher
├── actions*.rs     # Webhook, Email, Slack, SMS, etc.
├── condition.rs    # DSL parser
└── transport/      # NATS, PostgreSQL, MySQL, MSSQL bridges
```

### Database Migrations
```
crates/fraiseql-observers/migrations/
├── 06_create_observer_management.sql  # tb_observer, tb_observer_log
└── ...
```

---

## How to Build & Test

```bash
# Check compilation with observers feature
cargo check -p fraiseql-server --features "observers"

# Run tests
cargo test -p fraiseql-server --features "observers"

# Run all observers crate tests
cargo test -p fraiseql-observers

# Full workspace check
cargo check --workspace
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    fraiseql-server                          │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────────────────┐│
│  │ GraphQL API │  │ Observer    │  │ ObserverRuntime      ││
│  │ /graphql    │  │ CRUD API    │  │ - ChangeLogListener  ││
│  │             │  │ /api/obs    │  │ - ObserverExecutor   ││
│  └──────┬──────┘  └──────┬──────┘  └──────────┬───────────┘│
│         │                │                     │            │
│         ▼                ▼                     ▼            │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    PostgreSQL                           ││
│  │  tb_entity_change_log ──► tb_observer ──► Actions       ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   NATS / Redis  │
                    │  (optional)     │
                    └─────────────────┘
```

---

## Notes & Gotchas

1. **Feature flag**: Observer module is gated behind `--features "observers"`

2. **Debezium envelope**: `tb_entity_change_log.object_data` uses Debezium format:
   ```json
   {
     "op": "c",  // c=create, u=update, d=delete
     "before": {...},
     "after": {...},
     "source": {...}
   }
   ```

3. **Trinity pattern**: All tables use `pk_<table>` for primary key, `fk_<table>` for foreign keys

4. **Multi-tenancy**: `fk_customer_org` column for tenant isolation

5. **Soft delete**: Observers use `deleted_at` timestamp, not hard delete

---

## Questions for Tomorrow's Session

1. Should the observer runtime auto-start with the server, or be manually triggered?
2. What's the desired DLQ retention policy?
3. Should WebSocket notifications include full event payload or just metadata?
4. Any priority on Phase 8 features (search vs caching vs job queues)?

---

## Commit History (Recent)

```
e1c5fd75 feat(phase-7): Observer Runtime - Server integration and execution loop
d931ffbe feat(phase-6): Observer Management API - CRUD endpoints and database schema
f1e660ec chore(phase-10): Update INDEX.md with Phase 10 documentation overview
4aca9689 feat(phase-10.7): FAQ and Advanced Topics
...
```

---

*Last updated: 2026-01-22 by Claude (Opus 4.5)*
