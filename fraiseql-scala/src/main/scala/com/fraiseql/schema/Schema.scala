package com.fraiseql.schema

import ujson.*
import scala.io.Source
import java.nio.file.{Files, Paths}
import scala.jdk.CollectionConverters.*
import scala.util.matching.Regex

/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This object provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this object)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */

case class FieldDefinition(
  name: String,
  `type`: String,
  nullable: Boolean = false,
  description: Option[String] = None,
  scope: Option[String] = None,
  scopes: Option[List[String]] = None
)

/**
 * Validator for field-level scope format and patterns
 *
 * Scope format: action:resource
 * Examples: read:user.email, admin:*, write:Post.*
 *
 * Rules:
 * - Action: [a-zA-Z_][a-zA-Z0-9_]*
 * - Resource: [a-zA-Z_][a-zA-Z0-9_.]*|*
 */
object ScopeValidator {
  private val actionPattern: Regex = "^[a-zA-Z_][a-zA-Z0-9_]*$".r
  private val resourcePattern: Regex = "^([a-zA-Z_][a-zA-Z0-9_.]*|\\*)$".r

  /**
   * Validates scope format: action:resource
   *
   * @param scope The scope string to validate
   * @return true if valid, false otherwise
   */
  def validate(scope: String): Boolean = {
    if (scope.isEmpty) return false
    if (scope == "*") return true

    val parts = scope.split(':')
    if (parts.length != 2) return false

    val action = parts(0)
    val resource = parts(1)

    if (action.isEmpty || resource.isEmpty) return false

    actionPattern.matches(action) && resourcePattern.matches(resource)
  }

  /**
   * Validates a list of scopes
   *
   * @param scopes The list of scopes to validate
   * @return true if all are valid, false otherwise
   */
  def validateAll(scopes: List[String]): Boolean = {
    scopes.nonEmpty && scopes.forall(validate)
  }
}

case class TypeInfo(
  name: String,
  fields: Map[String, Map[String, Any]],
  description: Option[String] = None
)

/**
 * Central registry for GraphQL type definitions
 */
object SchemaRegistry {
  private var types: Map[String, TypeInfo] = Map()

  def register(name: String, info: TypeInfo): Unit = {
    types = types + (name -> info)
  }

  def getTypeNames: List[String] = types.keys.toList

  def getType(name: String): Option[TypeInfo] = types.get(name)

  def clear(): Unit = {
    types = Map()
  }
}

/**
 * Schema API for type registration and export
 */
object Schema {
  /**
   * Register a type definition
   * @param name The type name
   * @param fields Map of field name to field definition
   * @param description Optional type description
   */
  def registerType(name: String, fields: Map[String, Any], description: Option[String] = None): Unit = {
    val typeInfo = TypeInfo(name, fields, description)
    SchemaRegistry.register(name, typeInfo)
  }

  /**
   * Export minimal schema with only types (TOML workflow)
   *
   * Returns JSON containing only the "types" section.
   * All operational configuration (queries, mutations, federation, security, observers)
   * comes from fraiseql.toml and is merged during compilation.
   *
   * @param pretty Pretty-print JSON (true = formatted, false = compact)
   * @return JSON string with types only
   */
  def exportTypes(pretty: Boolean = true): String = {
    val typeNames = SchemaRegistry.getTypeNames

    // Build minimal schema with only types
    val typesArray = typeNames.flatMap { typeName =>
      SchemaRegistry.getType(typeName).map { typeInfo =>
        val fieldsArray = typeInfo.fields.map { case (fieldName, fieldConfig) =>
          val fieldMap = fieldConfig.asInstanceOf[Map[String, Any]]
          val field = Obj(
            "name" -> fieldName,
            "type" -> fieldMap.getOrElse("type", "String").asInstanceOf[String],
            "nullable" -> fieldMap.getOrElse("nullable", false).asInstanceOf[Boolean]
          )

          // Add scope if present
          fieldMap.get("scope").foreach { scope =>
            field("scope") = scope.asInstanceOf[String]
          }

          // Add scopes if present
          fieldMap.get("scopes").foreach { scopes =>
            val scopesList = scopes.asInstanceOf[List[String]]
            field("scopes") = Arr(scopesList.map(Str(_)): _*)
          }

          field
        }.toList

        val typeObj = Obj("name" -> typeName)
        typeObj("fields") = Arr(fieldsArray: _*)

        typeInfo.description.foreach { desc =>
          typeObj("description") = desc
        }

        typeObj
      }
    }

    val minimalSchema = Obj("types" -> Arr(typesArray: _*))

    // Export as JSON
    if (pretty) {
      ujson.write(minimalSchema, indent = 2)
    } else {
      ujson.write(minimalSchema)
    }
  }

  /**
   * Export minimal types to a file
   *
   * @param outputPath File path for types.json
   */
  def exportTypesFile(outputPath: String): Unit = {
    try {
      val typesJson = exportTypes(true)

      // Ensure directory exists
      val path = Paths.get(outputPath)
      if (path.getParent != null) {
        Files.createDirectories(path.getParent)
      }

      // Write file
      Files.writeString(path, typesJson)

      // Print summary
      val typesCount = SchemaRegistry.getTypeNames.length
      println(s"âœ… Types exported to $outputPath")
      println(s"   Types: $typesCount")
      println()
      println("ðŸŽ¯ Next steps:")
      println(s"   1. fraiseql compile fraiseql.toml --types $outputPath")
      println("   2. This merges types with TOML configuration")
      println("   3. Result: schema.compiled.json with types + all config")
    } catch {
      case e: Exception =>
        throw new RuntimeException(s"Failed to write types file: $outputPath")
    }
  }

  /**
   * Reset schema registry (useful for testing)
   */
  def reset(): Unit = {
    SchemaRegistry.clear()
  }

  /**
   * Get all registered type names
   * @return List of type names
   */
  def getTypeNames: List[String] = {
    SchemaRegistry.getTypeNames
  }
}
