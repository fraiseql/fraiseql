# FraiseQL Test Suite Remediation - Phase 1.5: Integration Test Infrastructure

**Date**: December 12, 2025
**Status**: Planning
**Priority**: HIGH (blocks native error arrays feature testing)
**Estimated Effort**: 6-8 hours

---

## Problem Statement

Integration tests in `test_native_error_arrays.py` are failing because:

1. **Dynamic Function Creation**: Tests create PostgreSQL functions at runtime
2. **Static Schema**: GraphQL schema is built once at app startup
3. **No Schema Refresh**: Schema doesn't discover new mutations after dynamic function creation
4. **Result**: `Cannot query field 'testAutoError' on type 'Mutation'`

### Affected Tests (4 tests, WP-034 feature)

```
tests/integration/graphql/mutations/test_native_error_arrays.py
‚îú‚îÄ‚îÄ TestAutoGeneratedErrors::test_auto_generated_errors_from_status ‚ùå
‚îú‚îÄ‚îÄ TestAutoGeneratedErrors::test_auto_generated_errors_multiple_status_formats ‚ùå
‚îú‚îÄ‚îÄ TestExplicitErrors::test_explicit_errors_override_auto_generation ‚ùå
‚îî‚îÄ‚îÄ TestBackwardCompatibility::test_backward_compatibility_with_mutation_result_base ‚ùå
```

**Error**: `Cannot query field 'testAutoError' on type 'Mutation'`

---

## Root Cause Analysis

### Current Test Pattern

```python
async def test_auto_generated_errors_from_status(self, blog_simple_graphql_client, blog_simple_db_connection):
    db = blog_simple_db_connection

    # Step 1: Create mutation function dynamically
    await db.execute("""
        CREATE OR REPLACE FUNCTION test_auto_error()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$ ... $$;
    """)

    # Step 2: Try to query the mutation (FAILS - not in schema)
    query = """
        mutation {
            testAutoError {  # ‚ùå Field doesn't exist in GraphQL schema
                code
                message
            }
        }
    """
    result = await blog_simple_graphql_client.execute(query)  # FAILS HERE
```

### Why This Fails

1. **Schema Registration Flow**:
   ```
   FastAPI App Startup
   ‚îî‚îÄ‚îÄ Initialize FraiseQL Schema
       ‚îî‚îÄ‚îÄ Discover mutations from database functions
           ‚îî‚îÄ‚îÄ Build GraphQL Schema (STATIC)
               ‚îî‚îÄ‚îÄ Schema is cached/frozen

   Test Execution
   ‚îî‚îÄ‚îÄ Create new database function
       ‚îî‚îÄ‚îÄ GraphQL Schema NOT updated ‚ùå
           ‚îî‚îÄ‚îÄ New mutation NOT discoverable
   ```

2. **FraiseQL Schema Registry**: Global singleton, initialized once
   - `fraiseql.fastapi.app.py:514`: Schema registry initialized successfully
   - `fraiseql.fastapi.app.py:521`: "Re-initialization is not allowed"
   - Log shows: "Schema registry is already initialized"

3. **Fixture Scope**:
   ```python
   @pytest_asyncio.fixture(scope="function")
   async def blog_simple_graphql_client(blog_simple_client) -> None:
       # Uses blog_simple_client which is class-scoped
       # FastAPI app already started, schema already built
   ```

---

## Solution Options

### Option A: Pre-Create Test Functions (RECOMMENDED) ‚úÖ

**Strategy**: Create all test mutation functions in a fixture BEFORE schema initialization

**Advantages**:
- ‚úÖ Simple and clean
- ‚úÖ No FraiseQL code changes needed
- ‚úÖ Tests actual production behavior (static schema)
- ‚úÖ Follows existing test patterns
- ‚úÖ Fast execution

**Disadvantages**:
- ‚ö†Ô∏è Test functions exist for entire class scope
- ‚ö†Ô∏è Need to ensure unique function names

**Implementation**:

```python
# tests/integration/graphql/mutations/conftest.py (NEW FILE)

import pytest
import pytest_asyncio
from tests.fixtures.examples.database_manager import get_database_manager


@pytest_asyncio.fixture(scope="class")
async def native_error_arrays_mutations(blog_simple_db_connection):
    """
    Pre-create mutation functions for native error arrays tests.

    These functions must be created BEFORE the GraphQL schema is built,
    so they're discovered during schema introspection.
    """
    db = blog_simple_db_connection

    # Create all test mutation functions
    await db.execute("""
        -- Test 1: test_auto_generated_errors_from_status
        CREATE OR REPLACE FUNCTION test_auto_error()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN mutation_validation_error(
                'Validation failed',
                'User',
                NULL
            );
        END;
        $$;

        -- Test 2: test_auto_generated_errors_multiple_status_formats
        CREATE OR REPLACE FUNCTION test_status_validation()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN (
                'failed:validation',
                'Test message',
                NULL,
                'TestType',
                NULL,
                NULL,
                NULL,
                NULL
            )::mutation_response;
        END;
        $$;

        CREATE OR REPLACE FUNCTION test_status_not_found()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN (
                'noop:not_found',
                'Test message',
                NULL,
                'TestType',
                NULL,
                NULL,
                NULL,
                NULL
            )::mutation_response;
        END;
        $$;

        CREATE OR REPLACE FUNCTION test_status_authorization()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN (
                'failed:authorization',
                'Test message',
                NULL,
                'TestType',
                NULL,
                NULL,
                NULL,
                NULL
            )::mutation_response;
        END;
        $$;

        CREATE OR REPLACE FUNCTION test_status_general_error()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN (
                'failed',
                'Test message',
                NULL,
                'TestType',
                NULL,
                NULL,
                NULL,
                NULL
            )::mutation_response;
        END;
        $$;

        -- Test 3: test_explicit_errors_override_auto_generation
        CREATE OR REPLACE FUNCTION test_explicit_errors()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN (
                'failed:validation',
                'Multiple validation errors',
                NULL,
                'User',
                NULL,
                NULL,
                NULL,
                jsonb_build_object(
                    'errors', jsonb_build_array(
                        jsonb_build_object(
                            'code', 400,
                            'identifier', 'email_invalid',
                            'message', 'Email format is invalid',
                            'details', jsonb_build_object('field', 'email')
                        ),
                        jsonb_build_object(
                            'code', 400,
                            'identifier', 'password_weak',
                            'message', 'Password must be at least 8 characters',
                            'details', jsonb_build_object('field', 'password')
                        )
                    )
                )
            )::mutation_response;
        END;
        $$;

        -- Test 4: test_backward_compatibility_with_mutation_result_base
        CREATE OR REPLACE FUNCTION test_with_base()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN mutation_validation_error(
                'Validation failed',
                'User',
                NULL
            );
        END;
        $$;
    """)

    yield  # Tests run here with functions available

    # Cleanup (optional - database is dropped anyway)
    # await db.execute("DROP FUNCTION IF EXISTS test_auto_error();")
    # ... etc


@pytest.fixture(scope="class", autouse=True)
def use_native_error_arrays_mutations(native_error_arrays_mutations):
    """Auto-use the fixture for all tests in test_native_error_arrays.py"""
    return native_error_arrays_mutations
```

**Updated Test File**:

```python
# tests/integration/graphql/mutations/test_native_error_arrays.py

class TestAutoGeneratedErrors:
    """Test automatic error array generation from status strings."""

    @pytest.mark.asyncio
    async def test_auto_generated_errors_from_status(
        self,
        blog_simple_graphql_client,
        # Remove: blog_simple_db_connection (no longer create function here)
    ):
        """
        Test that error responses automatically include errors array.

        Note: test_auto_error() function is pre-created by the
        native_error_arrays_mutations fixture.
        """
        # REMOVE: Dynamic function creation
        # db = blog_simple_db_connection
        # await db.execute("""CREATE OR REPLACE FUNCTION test_auto_error() ...""")

        # Execute mutation (function already exists in schema)
        query = """
            mutation {
                testAutoError {  # ‚úÖ Now in schema
                    code
                    status
                    message
                    errors {
                        code
                        identifier
                        message
                        details
                    }
                }
            }
        """
        result = await blog_simple_graphql_client.execute(query)

        # Assertions (unchanged)
        assert result.get("errors") is None
        data = result["data"]["testAutoError"]
        assert data["code"] == 400
        # ... rest of assertions
```

---

### Option B: Schema Refresh Mechanism (Advanced)

**Strategy**: Add ability to refresh GraphQL schema dynamically

**Advantages**:
- ‚úÖ Tests actual dynamic mutation creation
- ‚úÖ More flexible for future use cases

**Disadvantages**:
- ‚ùå Requires FraiseQL framework changes
- ‚ùå Schema registry is intentionally singleton
- ‚ùå May introduce race conditions
- ‚ùå Not representative of production usage
- ‚ùå Much more complex (20+ hours vs 6-8 hours)

**Decision**: **NOT RECOMMENDED** - Production apps don't dynamically add mutations at runtime

---

### Option C: Use Different Example App with Pre-Created Functions

**Strategy**: Create a dedicated test example app with mutation functions

**Advantages**:
- ‚úÖ Clean separation of concerns
- ‚úÖ Could be reused for other mutation tests

**Disadvantages**:
- ‚ùå Overkill for 4 tests
- ‚ùå Need to maintain another example app
- ‚ùå More setup complexity

**Decision**: **NOT RECOMMENDED** - Too much overhead

---

## Recommended Implementation Plan

### Phase 1.5: Integration Test Infrastructure Fix (6-8 hours)

#### Step 1: Create Mutation Fixture (2 hours)

**File**: `tests/integration/graphql/mutations/conftest.py` (NEW)

1. Create class-scoped fixture that pre-creates all test mutations
2. Ensure fixture runs BEFORE `blog_simple_client` initializes
3. Add proper cleanup (optional, as DB is dropped anyway)
4. Document why functions must be pre-created

**Verification**:
```bash
# Fixture should create functions before schema is built
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py::TestAutoGeneratedErrors::test_auto_generated_errors_from_status -v -s
# Check logs - should see functions created BEFORE "Schema registry initialized"
```

#### Step 2: Update Test Classes (2 hours)

**File**: `tests/integration/graphql/mutations/test_native_error_arrays.py`

1. Remove dynamic `CREATE FUNCTION` statements from all 4 test methods
2. Remove `blog_simple_db_connection` parameter from test signatures
3. Update docstrings to explain pre-created functions
4. Keep all assertions unchanged

**Changes**:
- `TestAutoGeneratedErrors::test_auto_generated_errors_from_status`
- `TestAutoGeneratedErrors::test_auto_generated_errors_multiple_status_formats`
- `TestExplicitErrors::test_explicit_errors_override_auto_generation`
- `TestBackwardCompatibility::test_backward_compatibility_with_mutation_result_base`

#### Step 3: Fix Fixture Dependency Order (1 hour)

Ensure fixtures run in correct order:

```
1. blog_simple_db_url (session)
2. blog_simple_db_connection (class)
3. native_error_arrays_mutations (class) ‚Üê Creates functions
4. blog_simple_client (class) ‚Üê Initializes schema (discovers functions)
5. blog_simple_graphql_client (function) ‚Üê Uses client
```

**Investigation needed**: Check current fixture scopes and dependencies

#### Step 4: Handle Test Case Variations (1 hour)

The `test_auto_generated_errors_multiple_status_formats` test creates 4 different functions in a loop. Options:

**Option A**: Pre-create all 4 variations
```python
# In fixture
CREATE FUNCTION test_status_validation() ...
CREATE FUNCTION test_status_not_found() ...
CREATE FUNCTION test_status_authorization() ...
CREATE FUNCTION test_status_general_error() ...
```

**Option B**: Single parameterized function
```python
# In fixture
CREATE FUNCTION test_status_code(p_status text) ...

# In test
for status in ["failed:validation", "noop:not_found", ...]:
    query = f"mutation {{ testStatusCode(status: \"{status}\") {{ ... }} }}"
```

**Recommendation**: Option A (simpler, matches test intent)

#### Step 5: Verify and Document (1-2 hours)

1. Run all 4 tests and verify they pass
2. Add comments explaining the fixture pattern
3. Update test docstrings
4. Create README in `tests/integration/graphql/mutations/` explaining the pattern

**Verification**:
```bash
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py -v
# Expected: 4 tests PASS
```

---

## Implementation Code Examples

### Example: conftest.py

```python
"""
Fixtures for GraphQL mutation integration tests.

IMPORTANT: Functions must be created BEFORE schema initialization
"""

import pytest
import pytest_asyncio


@pytest_asyncio.fixture(scope="class")
async def native_error_arrays_mutations(blog_simple_db_connection):
    """
    Pre-create mutation functions for native error arrays tests.

    Why pre-create? FraiseQL's GraphQL schema is built at app startup
    by introspecting database functions. Dynamic function creation
    after schema initialization won't register new mutations.

    Scope: class - Functions persist for all tests in the class,
    but are cleaned up when database is dropped.
    """
    db = blog_simple_db_connection

    await db.execute("""
        -- WP-034: Native error arrays feature tests

        CREATE OR REPLACE FUNCTION test_auto_error()
        RETURNS mutation_response
        LANGUAGE plpgsql
        AS $$
        BEGIN
            RETURN mutation_validation_error(
                'Validation failed',
                'User',
                NULL
            );
        END;
        $$;

        -- Add other functions...
    """)

    yield


# Make fixture auto-use for all tests in test_native_error_arrays.py
# This could be in the test file itself with pytest.mark.usefixtures
```

### Example: Updated Test

```python
class TestAutoGeneratedErrors:
    """Test automatic error array generation from status strings."""

    # Ensure fixture runs for this class
    pytestmark = pytest.mark.usefixtures("native_error_arrays_mutations")

    @pytest.mark.asyncio
    async def test_auto_generated_errors_from_status(self, blog_simple_graphql_client):
        """
        Test that error responses automatically include errors array.

        Prerequisites:
        - test_auto_error() function pre-created by native_error_arrays_mutations fixture
        - Function discovered during schema initialization
        """
        # No dynamic function creation - already exists

        query = """
            mutation {
                testAutoError {
                    code
                    status
                    message
                    errors {
                        code
                        identifier
                        message
                        details
                    }
                }
            }
        """
        result = await blog_simple_graphql_client.execute(query)

        # Assertions unchanged
        assert result.get("errors") is None
        data = result["data"]["testAutoError"]
        assert data["code"] == 400
        assert data["status"] == "failed:validation"
        assert data["message"] == "Validation failed"

        assert "errors" in data
        assert data["errors"] is not None
        assert len(data["errors"]) == 1
        assert data["errors"][0]["code"] == 400
        assert data["errors"][0]["identifier"] == "validation"
```

---

## Acceptance Criteria

- [ ] All 4 tests in `test_native_error_arrays.py` pass
- [ ] No dynamic `CREATE FUNCTION` statements in test methods
- [ ] Fixture creates functions before schema initialization
- [ ] Clear documentation explaining the pattern
- [ ] No FraiseQL framework changes needed
- [ ] Tests validate WP-034 feature correctly

---

## Verification Commands

```bash
# Step 1: Run single test
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py::TestAutoGeneratedErrors::test_auto_generated_errors_from_status -v

# Step 2: Run all tests in file
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py -v

# Step 3: Verify fixture order (with debug logging)
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py -v -s --log-cli-level=INFO

# Expected output sequence:
# 1. "Creating test mutation functions"
# 2. "Schema registry initialized successfully"
# 3. Tests execute successfully
```

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Fixture order wrong | MEDIUM | HIGH | Test fixture dependencies carefully |
| Functions not discovered | LOW | HIGH | Log when functions created vs schema built |
| Cleanup issues | LOW | LOW | Database is dropped anyway |
| Test flakiness | LOW | MEDIUM | Use class scope, not function scope |

---

## Timeline

- **Week 1 (Current)**: Phase 1 complete ‚úÖ
- **Week 1 (Day 2-3)**: Phase 1.5 - Integration test infrastructure (6-8 hours)
- **Week 2**: Phase 2 - SQL rendering infrastructure (16-20 hours)
- **Week 3**: Phase 3 - SQL generation bugs (10-20 hours)
- **Week 4**: Phase 4 - Cleanup (4-6 hours)

**Updated Total**: 36-44 hours (was 30 hours)

---

## Alternative: Mark Tests as Skipped (Quick Fix)

If Phase 1.5 is too complex, temporarily skip these tests:

```python
@pytest.mark.skip(reason="WP-034: Requires schema refresh mechanism - tracked separately")
class TestAutoGeneratedErrors:
    ...
```

**Pros**: Quick (5 minutes)
**Cons**: Feature not tested, technical debt

**Recommendation**: **Implement Phase 1.5** - Tests are important for WP-034 feature

---

## Success Metrics

**Before Phase 1.5**:
- Failed: 4 tests (schema registration issues)

**After Phase 1.5**:
- Failed: 0 tests ‚úÖ
- WP-034 feature fully tested ‚úÖ
- Pattern documented for future mutation tests ‚úÖ

---

**Phase 1.5 Status**: üìã **PLANNED**
**Recommended Start**: After Phase 1 completion
**Priority**: HIGH (WP-034 feature untested)

**Next Actions**:
1. Review this plan
2. Approve Phase 1.5 approach
3. Implement conftest.py fixture
4. Update test file
5. Verify all 4 tests pass
