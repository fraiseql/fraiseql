# Quick Reference: FraiseQL Security Vulnerabilities
**14 Issues Identified** | **CVSS Scores: 1.5 - 9.8** | **Fix Time: 40 hours**

---

## ğŸ“Š Summary by Severity

| Severity | Count | CVSS Range | GA Blocking | Phase |
|----------|-------|-----------|------------|-------|
| ğŸ”´ CRITICAL | 2 | 9.2-9.8 | YES | 11.1, 11.2 |
| ğŸŸ  HIGH | 3 | 7.5-8.1 | YES* | 11.3-11.5 |
| ğŸŸ¡ MEDIUM | 4 | 4.3-5.5 | NO | 11.6 |
| ğŸ”µ LOW | 5 | 1.5-3.1 | NO | 11.7 |
| âœ… POSITIVE | 6 | - | - | - |

*HIGH priority: May block GA depending on deployment (distributed systems require Phase 11.5)

---

## ğŸ”´ CRITICAL (GA BLOCKING)

### #1: TLS Certificate Validation Bypass
```
CVSS:     9.8 (CRITICAL)
Severity: ğŸ”´ğŸ”´ğŸ”´ Highest possible
Phase:    11.1 (2 hours)
File:     crates/fraiseql-server/src/tls/mod.rs
```

**The Problem**:
```rust
pub struct NoVerifier;
impl ServerCertVerifier for NoVerifier {
    fn verify_server_cert(...) -> Result<ServerCertVerified> {
        Ok(ServerCertVerified::assertion())  // ğŸ”“ ACCEPTS ANY CERT
    }
}
```

**The Risk**:
- Attacker can intercept ALL TLS connections without valid certificate
- Man-in-the-middle attacks on database connections
- Complete compromise of database traffic

**The Fix**:
```rust
pub fn initialize_tls_config(config: &TlsConfig) -> Result<ServerConfig> {
    if config.danger_accept_invalid_certs {
        #[cfg(not(debug_assertions))]
        {
            panic!("ğŸš¨ TLS validation bypass blocked in release");
        }
    }
    // ... rest of implementation
}
```

**Impact if Not Fixed**:
- âŒ Cannot be used in production
- âŒ Immediate security incident if deployed
- âŒ All credentials/data exposed

---

### #2: SQL Injection via JSON Paths
```
CVSS:     9.2 (CRITICAL)
Severity: ğŸ”´ğŸ”´ğŸ”´ Highest possible
Phase:    11.2 (4 hours)
File:     crates/fraiseql-core/src/db/sql_builder.rs
```

**The Problem**:
```rust
fn build_json_path(path: &[String]) -> String {
    if path.len() == 1 {
        format!("data->>'{}'", path[0])  // âŒ NO ESCAPING
    }
}

// Attack: field_name = "data' OR '1'='1"
// Result: data->>'data' OR '1'='1'   â† SQL injection
```

**The Risk**:
- Complete database compromise via malicious field names
- Attacker can extract, modify, or delete any data
- Application users can escalate to admin

**The Fix**:
```rust
fn escape_field_name(name: &str) -> String {
    name.replace("'", "''")  // SQL escape: ' â†’ ''
}

fn build_json_path(path: &[String]) -> String {
    if path.len() == 1 {
        let escaped = escape_field_name(&path[0]);
        format!("data->>'{}' ", escaped)  // âœ… SAFE
    }
}
```

**Impact if Not Fixed**:
- âŒ Cannot be used in production
- âŒ Immediate security incident if exploited
- âŒ All database data at risk

---

## ğŸŸ  HIGH (SHOULD FIX BEFORE GA)

### #3: Plaintext Password Storage in Memory
```
CVSS:     8.1 (HIGH)
Severity: ğŸŸ ğŸŸ ğŸŸ  Very High
Phase:    11.3 (3 hours)
File:     crates/fraiseql-wire/src/client/connection_string.rs
```

**The Problem**:
```rust
// VULNERABLE: Standard Rust String doesn't zero memory
let password = String::from("super_secret_123");
// When dropped: memory contains plaintext password forever
```

**The Risk**:
- Memory dump attacks (RCE, VM escape)
- Attacker can recover plaintext passwords from heap
- All database credentials compromised
- Affects: AWS, Azure, VMs with memory access

**The Fix**:
```toml
# Add to Cargo.toml
zeroize = { version = "1.6", features = ["std", "derive"] }
```

```rust
// âœ… SAFE: Automatically zeroed on drop
let password = Zeroizing::new(password_string);
// When dropped: memory is securely zeroed
```

**Impact if Not Fixed**:
- âš ï¸ Passwords recoverable from memory
- âš ï¸ Affects regulated deployments (HIPAA, PCI-DSS, GDPR)
- âš ï¸ High-risk environments (untrusted hosts)

---

### #4: OIDC Token Cache Poisoning
```
CVSS:     7.8 (HIGH)
Severity: ğŸŸ ğŸŸ ğŸŸ  Very High
Phase:    11.4 (4 hours)
File:     crates/fraiseql-core/src/security/oidc.rs:629-667
```

**The Problem**:
```rust
// Cache TTL: 3600 seconds (1 hour)
const JWKS_CACHE_TTL: Duration = Duration::from_secs(3600);

// Scenario:
// 1. User logs in â†’ Token cached (valid)
// 2. User logs out â†’ Token revoked on server
// 3. Attacker uses old token
// 4. System checks cache â†’ Still valid for up to 1 hour!
```

**The Risk**:
- Revoked tokens accepted for 1 hour after key rotation
- Users can impersonate each other with old tokens
- Sessions cannot be terminated immediately
- Affects: OAuth 2.0, OIDC flows

**The Fix**:
```rust
// Reduce cache TTL to 5 minutes
const JWKS_CACHE_TTL: Duration = Duration::from_secs(300);  // âœ… 5 min

// Add key rotation detection
pub fn key_rotation_detected(&self, new_jwks: &JsonWebKeySet) -> bool {
    let cached = self.jwks_cache.read();
    if let Some(ref cached) = *cached {
        let old_kids: HashSet<_> = cached.jwks.kids().collect();
        let new_kids: HashSet<_> = new_jwks.kids().collect();
        !old_kids.is_subset(&new_kids)  // Detect removed keys
    } else {
        false
    }
}

// Invalidate cache on key miss
pub async fn get_decoding_key(&self, kid: &str) -> Result<DecodingKey> {
    if let Some(key) = self.get_key_from_cache(kid) {
        return Ok(key);
    }
    // Cache miss â†’ Fetch fresh, prevents poisoning
    self.get_key_and_update_cache(kid).await
}
```

**Impact if Not Fixed**:
- âš ï¸ Revoked sessions still usable for 1 hour
- âš ï¸ Cannot terminate sessions immediately
- âš ï¸ High-risk for regulated deployments

---

### #5: CSRF Token Validation in Distributed Systems
```
CVSS:     7.5 (HIGH)
Severity: ğŸŸ ğŸŸ ğŸŸ  Very High
Phase:    11.5 (6 hours)
File:     crates/fraiseql-server/src/auth/handlers.rs:25
```

**The Problem**:
```rust
// VULNERABLE: In-memory state store
// Instance 1: Create OAuth state
// state = CSRF_TOKENS.insert("abc123", nonce)
//
// Instance 2 (load balanced): Validate callback
// CSRF_TOKENS.get("abc123")  â† NOT FOUND (different memory space)
// âœ… Returns: None  â† CSRF check bypassed!
```

**The Risk**:
- CSRF validation fails in load-balanced deployments
- Attacker can bypass CSRF protection
- OAuth flow vulnerability
- Affects: Multi-instance deployments, Kubernetes, Docker Swarm

**The Fix**:
```toml
# Add to Cargo.toml
redis = { version = "0.24", features = ["aio", "tokio-comp"] }
```

```rust
// âœ… SAFE: Persistent Redis backend
pub struct RedisStateStore {
    client: redis::Client,
}

impl StateStore for RedisStateStore {
    async fn create_state(&self, nonce: String) -> Result<OAuthState> {
        let state = generate_random_string(32);
        self.client
            .set_ex(&format!("oauth:state:{}", state), &nonce, 600)
            .await?;  // Redis: shared across instances
        Ok(OAuthState { token: state, nonce })
    }
}
```

**Impact if Not Fixed**:
- âš ï¸ CSRF bypassed in production (multi-instance)
- âš ï¸ OAuth flow completely broken
- âš ï¸ Requires single-instance workaround

---

## ğŸŸ¡ MEDIUM (SHOULD FIX THIS QUARTER)

### #6: Error Message Information Leakage
```
CVSS:     4.3 (MEDIUM)
Severity: ğŸŸ¡ğŸŸ¡ Moderate
Phase:    11.6 (2 hours)
Issue:    1 of 4 in Phase 11.6
```

**The Problem**:
```
Error: Column 'user_id' does not exist
                â†‘ Attacker learns schema structure
        â†‘ Database operation reveals internal details
```

**The Risk**:
- Reconnaissance: Attacker learns schema structure
- Information disclosure: Internal implementation details exposed
- Aids attack planning

**The Fix**:
```rust
pub fn to_string_in_profile(&self, profile: &SecurityProfile) -> String {
    match profile {
        SecurityProfile::Standard => self.to_string(),
        SecurityProfile::Regulated => match self {
            Error::DatabaseError(_) => "Database error occurred".to_string(),
            Error::ValidationError(_) => "Invalid request".to_string(),
            // âœ… Generic messages, no details
        }
    }
}
```

---

### #7: Bearer Token Timing Attack
```
CVSS:     4.7 (MEDIUM)
Severity: ğŸŸ¡ğŸŸ¡ Moderate
Phase:    11.6 (1 hour)
Issue:    2 of 4 in Phase 11.6
```

**The Problem**:
```rust
fn verify_token(provided: &str, expected: &str) -> bool {
    for i in 0..provided.len() {
        if provided[i] != expected[i] {
            return false;  // âŒ Early exit: varies by where mismatch is
        }
    }
    true
}

// Attack: Time how long it takes to reject tokens
// Different timing = different positions of mismatch
// = Attacker can infer token structure
```

**The Risk**:
- Timing-based token inference
- Attacker learns token structure through timing
- Reduces token entropy effectively

**The Fix**:
```toml
# Add to Cargo.toml
subtle = "2.4"
```

```rust
use subtle::ConstantTimeComparison;

fn verify_token(provided: &str, expected: &str) -> bool {
    provided.ct_eq(expected).into()  // âœ… Constant-time
}
```

---

### #8: Incomplete Field Masking
```
CVSS:     5.2 (MEDIUM)
Severity: ğŸŸ¡ğŸŸ¡ Moderate
Phase:    11.6 (1 hour)
Issue:    3 of 4 in Phase 11.6
```

**The Problem**:
```rust
// Current: Only 6 patterns masked
const SENSITIVE_FIELDS: &[&str] = &[
    "password", "secret", "token", "ssn", "creditcard", "pin"
];

// Missing: 30+ common PII fields
// Examples:
// - email, phone, address, zip
// - dob, birthdate, social_security
// - medical, health, diagnosis
// - salary, balance, account_number
```

**The Risk**:
- Sensitive PII fields exposed in logs/errors
- GDPR/HIPAA violations
- Privacy breaches

**The Fix**:
```rust
const SENSITIVE_FIELD_PATTERNS: &[&str] = &[
    // Authentication
    "password", "secret", "token", "pin",
    // PII
    "ssn", "phone", "address", "email",
    "dob", "birthdate", "zip",
    // Financial
    "creditcard", "balance", "salary", "account_number",
    // Healthcare
    "medical", "health", "diagnosis",
    // Employment
    "hire_date", "termination_date",
    // ... 30+ total patterns
];
```

---

### #9: JSON Variable Ordering in APQ Cache
```
CVSS:     5.5 (MEDIUM)
Severity: ğŸŸ¡ğŸŸ¡ Moderate
Phase:    11.6 (2 hours)
Issue:    4 of 4 in Phase 11.6
```

**The Problem**:
```rust
// VULNERABLE: Different key orders = different hashes
let vars1 = json!({"z": 1, "a": 2});
let vars2 = json!({"a": 2, "z": 1});

hash(query, vars1) != hash(query, vars2)  // âŒ Different cache keys!

// Attack: Reorder variables to bypass APQ cache
// Same query, same variables, different cache key
// Cache evasion possible
```

**The Risk**:
- APQ (Automatic Persisted Queries) cache evasion
- Repeated queries not cached
- DoS via repeated unique-looking queries

**The Fix**:
```rust
fn sort_json_keys(value: &Value) -> Value {
    match value {
        Value::Object(map) => {
            let mut sorted = serde_json::Map::new();
            let mut keys: Vec<_> = map.keys().cloned().collect();
            keys.sort();  // âœ… Sort keys first

            for key in keys {
                sorted.insert(key.clone(), sort_json_keys(&map[&key]));
            }
            Value::Object(sorted)
        }
        // ... handle arrays recursively
    }
}

pub fn hash_query_with_variables(query: &str, variables: &Value) -> String {
    let sorted_vars = sort_json_keys(variables);  // âœ… Always sorted
    let variables_json = serde_json::to_string(&sorted_vars)?;
    let combined = format!("{}:{}", sha256_hash(query), variables_json);
    sha256_hash(&combined)
}
```

---

## ğŸ”µ LOW (NICE TO HAVE)

### #10: Query Depth/Complexity Limits
```
CVSS:     2.7 (LOW)
Severity: ğŸ”µ Low
Phase:    11.7 (3 hours)
Item:     1 of 5 in Phase 11.7
```

**The Risk**: DoS via deeply nested queries

**The Fix**: Add MAX_QUERY_DEPTH and MAX_QUERY_COMPLEXITY constants

---

### #11: Rate Limiting Key Extraction
```
CVSS:     3.1 (LOW)
Severity: ğŸ”µ Low
Phase:    11.7 (1 hour)
Item:     2 of 5 in Phase 11.7
```

**The Risk**: Rate limiting implementation verification needed

**The Fix**: Document rate limiting strategy (IP-based, user-based)

---

### #12: SCRAM Authentication Version
```
CVSS:     1.5 (LOW)
Severity: ğŸ”µ Low
Phase:    11.7 (1 hour)
Item:     3 of 5 in Phase 11.7
```

**The Risk**: Unclear PostgreSQL version requirements

**The Fix**: Document SCRAM-SHA-256 requirements (PostgreSQL 10+)

---

### #13: Audit Log Integrity
```
CVSS:     2.1 (LOW)
Severity: ğŸ”µ Low
Phase:    11.7 (4 hours)
Item:     4 of 5 in Phase 11.7
```

**The Risk**: Tampering with audit logs undetected

**The Fix**: Implement hash chain for audit log entries

```rust
pub struct AuditLogEntry {
    hash_prev: String,      // Hash of previous entry
    hash_current: String,   // Hash of this entry
}

pub fn verify_audit_log_integrity(entries: &[AuditLogEntry]) -> bool {
    for i in 1..entries.len() {
        if entries[i].hash_prev != entries[i-1].hash_current {
            return false;  // âœ… Tampering detected
        }
    }
    true
}
```

---

### #14: ID Enumeration Prevention
```
CVSS:     2.1 (LOW)
Severity: ğŸ”µ Low
Phase:    11.7 (3 hours)
Item:     5 of 5 in Phase 11.7
```

**The Risk**: Sequential IDs allow user enumeration

**The Fix**: Implement opaque ID generation

```rust
pub fn generate_opaque_id(prefix: &str) -> String {
    let random_bytes: [u8; 12] = rng.gen();
    let encoded = base64::encode(&random_bytes);
    format!("{}_{}", prefix, encoded)  // e.g., usr_abc123xyz
}

// Results in non-enumerable IDs:
// user_1, user_2, user_3         â† Enumerable âŒ
// usr_abc123, usr_xyz789, ...    â† Not enumerable âœ…
```

---

## âœ… POSITIVE: SECURITY STRENGTHS

### What's Already Secure

**#1: SQL Value Injection Prevention** âœ…
- Values properly parameterized
- Database drivers handle escaping
- No direct SQL interpolation

**#2: Type-Safe Database Interface** âœ…
- Strongly typed queries
- Compile-time schema validation
- No dynamic query building

**#3: SCRAM Authentication** âœ…
- RFC 5802 compliant
- Strong password hashing
- Supports SCRAM-SHA-256-PLUS with channel binding

**#4: OIDC/JWT Token Validation** âœ…
- Proper signature validation
- Expiration checking
- Key rotation support (needs short TTL)

**#5: Field-Level Access Control** âœ…
- Per-field authorization checks
- Prevents unauthorized data access
- Works across all query types

**#6: Comprehensive Audit Logging** âœ…
- All operations logged
- User tracking enabled
- Action context captured

---

## ğŸ“‹ Quick Reference Table

| # | Issue | CVSS | Type | Phase | Hours | GA Blocking |
|---|-------|------|------|-------|-------|-------------|
| 1 | TLS Cert Bypass | 9.8 | CRITICAL | 11.1 | 2 | âœ… YES |
| 2 | SQL Injection | 9.2 | CRITICAL | 11.2 | 4 | âœ… YES |
| 3 | Password Memory | 8.1 | HIGH | 11.3 | 3 | âš ï¸ YES* |
| 4 | OIDC Cache | 7.8 | HIGH | 11.4 | 4 | âš ï¸ YES* |
| 5 | CSRF Distributed | 7.5 | HIGH | 11.5 | 6 | âš ï¸ YES* |
| 6 | Error Leakage | 4.3 | MEDIUM | 11.6 | 2 | âŒ NO |
| 7 | Token Timing | 4.7 | MEDIUM | 11.6 | 1 | âŒ NO |
| 8 | Field Masking | 5.2 | MEDIUM | 11.6 | 1 | âŒ NO |
| 9 | JSON Ordering | 5.5 | MEDIUM | 11.6 | 2 | âŒ NO |
| 10 | Query Depth | 2.7 | LOW | 11.7 | 3 | âŒ NO |
| 11 | Rate Limit | 3.1 | LOW | 11.7 | 1 | âŒ NO |
| 12 | SCRAM Doc | 1.5 | LOW | 11.7 | 1 | âŒ NO |
| 13 | Audit Log | 2.1 | LOW | 11.7 | 4 | âŒ NO |
| 14 | ID Enum | 2.1 | LOW | 11.7 | 3 | âŒ NO |

*GA Blocking for: #3 regulated deployments, #4 & #5 distributed systems

---

## ğŸ¯ Implementation Priority

### Immediate (Block GA)
1. âœ… Phase 11.1: TLS (2h)
2. âœ… Phase 11.2: SQL Injection (4h)

### This Sprint (Strongly Recommended)
3. ğŸ”§ Phase 11.3: Password Security (3h)
4. ğŸ”§ Phase 11.4: OIDC Cache (4h)
5. ğŸ”§ Phase 11.5: CSRF Distributed (6h)

### This Quarter (Important)
6. ğŸ“… Phase 11.6: Data Protection (9h)

### Next Quarter (Nice to Have)
7. ğŸ“… Phase 11.7: Enhancements (12h)

---

## ğŸ“Œ Key Takeaways

âœ… **Good News**:
- Foundational security features already present
- All issues have clear, documented fixes
- No architectural rewrites needed
- Total 40 hours to full security hardening

âš ï¸ **Urgent**:
- 2 CRITICAL issues must be fixed before any production use
- Cannot be worked around or mitigated
- Blocks GA release completely

ğŸ”§ **High Priority**:
- 3 HIGH issues affect specific deployments
- Essential for regulated environments (HIPAA, PCI-DSS, GDPR)
- Essential for distributed deployments (K8s, multi-instance)

ğŸ“ˆ **Recommended**:
- Fix all 5 HIGH + 4 MEDIUM issues before major release
- LOW items can be phased in over next quarter
- Results in security-hardened, production-ready system

---

**See also**: `INDEX.md` for implementation tracking, `IMPLEMENTATION_ROADMAP.md` for detailed roadmap
