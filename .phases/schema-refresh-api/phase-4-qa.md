# Phase 4: Schema Refresh API - QA Phase

**Phase**: QA (Integration & Documentation)
**Objective**: Unblock WP-034 tests and document the schema refresh feature
**Status**: Not Started
**Estimated Effort**: 1.5-2 hours

---

## Context

Phases 1-3 implemented and refined the `refresh_schema()` API. This QA phase:

1. **Enables WP-034 tests** - Remove skips from native error array tests
2. **Updates integration test fixtures** - Use refresh API properly
3. **Documents the feature** - Add testing guide and examples
4. **Validates end-to-end** - Ensure original blocker is resolved

**Success Criteria**: WP-034 tests pass without modification (except removing `@pytest.mark.skip`)

---

## Files to Modify

### Modify
- `tests/integration/graphql/mutations/conftest.py` - Update fixture to use refresh API
- `tests/integration/graphql/mutations/test_native_error_arrays.py` - Remove skip decorators
- `docs/testing.md` - Add schema refresh documentation (CREATE if missing)

### Remove
- `/tmp/fraiseql-phase1.5-blocker-analysis.md` - Issue resolved, blocker removed

---

## Implementation Steps

### Step 1: Update Integration Test Fixture

Modify `tests/integration/graphql/mutations/conftest.py`:

**Current state**: File has attempted fixture implementation that doesn't work (documented blocker)

**New implementation**:

```python
"""Fixtures for GraphQL mutation integration tests.

Provides database seeding and schema refresh for tests that require
dynamically created mutation functions.
"""

import psycopg
import pytest


@pytest.fixture
async def blog_simple_app_with_native_errors(blog_simple_app, blog_simple_db_url):
    """Blog app with native error array test mutations.

    Creates database functions for testing WP-034 native error arrays feature,
    then refreshes the schema to discover them.

    This fixture demonstrates using app.refresh_schema() to test features
    that require dynamically created database functions.
    """
    # Create test mutation functions
    async with await psycopg.AsyncConnection.connect(blog_simple_db_url) as conn:
        # Test function 1: Simple native error
        await conn.execute("""
            CREATE OR REPLACE FUNCTION test_native_error()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error('TestError', 'User', NULL);
            END;
            $$;
        """)

        # Test function 2: Multiple errors
        await conn.execute("""
            CREATE OR REPLACE FUNCTION test_multiple_native_errors()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error(
                    ARRAY['Error1', 'Error2'],
                    'User',
                    NULL
                );
            END;
            $$;
        """)

        # Test function 3: Field-specific error
        await conn.execute("""
            CREATE OR REPLACE FUNCTION test_field_native_error()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error('FieldError', 'User.email', NULL);
            END;
            $$;
        """)

        # Test function 4: Auto-generated error identifier
        await conn.execute("""
            CREATE OR REPLACE FUNCTION test_auto_error_identifier()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error(
                    'This is a test error',
                    'User',
                    NULL
                );
            END;
            $$;
        """)

        await conn.commit()

    # Refresh schema to discover new mutations
    await blog_simple_app.refresh_schema()

    yield blog_simple_app

    # Cleanup happens automatically via database fixture
```

### Step 2: Remove Skip Decorators from WP-034 Tests

Modify `tests/integration/graphql/mutations/test_native_error_arrays.py`:

**Find and remove** all `@pytest.mark.skip` decorators (there should be 4 classes):

```python
# BEFORE (Phase 1.5):
@pytest.mark.skip(reason="WP-034: Requires dynamic schema discovery - see fraiseql-phase1.5-blocker-analysis.md")
class TestAutoGeneratedErrors:
    ...

# AFTER (Phase 4):
class TestAutoGeneratedErrors:
    ...
```

**Update** each test class to use the new fixture:

```python
# BEFORE:
class TestAutoGeneratedErrors:
    async def test_auto_identifier(self, blog_simple_graphql_client):
        ...

# AFTER:
class TestAutoGeneratedErrors:
    async def test_auto_identifier(
        self,
        blog_simple_app_with_native_errors,
        blog_simple_graphql_client,
    ):
        # Note: blog_simple_app_with_native_errors ensures schema is refreshed
        ...
```

**Repeat** for all 4 test classes:
1. `TestAutoGeneratedErrors`
2. `TestMultipleNativeErrors`
3. `TestFieldSpecificErrors`
4. `TestNativeErrorIdentifiers`

### Step 3: Run WP-034 Tests to Verify

```bash
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py -v
```

**Expected Output**:
```
test_auto_identifier PASSED
test_multiple_errors PASSED
test_field_specific_error PASSED
test_native_error_identifier PASSED

====== 4 passed in 3.20s ======
```

**If tests fail**: Debug the specific assertion, check that:
- Mutation functions created correctly
- Schema refresh discovered them
- GraphQL client can execute mutations
- Response format matches expectations

### Step 4: Create Testing Documentation

Create or update `docs/testing.md` with schema refresh guidance:

```markdown
# FraiseQL Testing Guide

## Dynamic Schema Refresh

### Problem

FraiseQL builds its GraphQL schema once during app initialization. This makes it challenging to test features that require dynamically created database functions or views.

### Solution: `app.refresh_schema()`

The `refresh_schema()` method rebuilds the schema after database changes:

```python
@pytest.fixture
async def app_with_custom_mutations(app, db_url):
    """App with dynamically created mutations."""
    # Create database functions
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        await conn.execute("""
            CREATE FUNCTION my_test_mutation()
            RETURNS mutation_response
            LANGUAGE plpgsql AS $$
            BEGIN
                RETURN mutation_success(NULL::integer);
            END;
            $$;
        """)
        await conn.commit()

    # Refresh schema to discover new function
    await app.refresh_schema()

    yield app
```

### When to Use

**Use schema refresh when**:
- Testing features that create database functions dynamically
- Creating test-specific mutations that shouldn't be in production schema
- Verifying auto-discovery behavior

**Don't use schema refresh when**:
- Testing existing schema (no dynamic functions needed)
- Performance is critical (refresh adds ~50-200ms overhead)
- Functions can be added to example app's `init.sql` instead

### Performance Considerations

Schema refresh is expensive:
- Database introspection queries
- GraphQL schema rebuilding
- Rust registry re-initialization

**Recommended**: Use class-scoped fixtures to refresh once per test class, not per test function.

```python
@pytest.fixture(scope="class")  # ← Class scope
async def app_with_mutations(app, db_url):
    await app.refresh_schema()
    yield app
```

### Example: WP-034 Native Error Arrays

See `tests/integration/graphql/mutations/test_native_error_arrays.py` for a complete example of using schema refresh to test dynamically created mutation functions.

## Schema Testing Utilities

FraiseQL provides utilities in `fraiseql.testing` for schema manipulation:

### `clear_fraiseql_caches()`

Clears all internal caches (Python, Rust, type registries):

```python
from fraiseql.testing import clear_fraiseql_caches

clear_fraiseql_caches()
# All caches cleared, ready to rebuild schema
```

### `clear_fraiseql_state()`

Complete cleanup including caches and FastAPI dependencies:

```python
from fraiseql.testing import clear_fraiseql_state

@pytest.fixture(scope="session", autouse=True)
def cleanup_after_tests():
    yield
    clear_fraiseql_state()
```

### `validate_schema_refresh()`

Verify schema refresh preserved existing elements:

```python
from fraiseql.testing import validate_schema_refresh

old_schema = app.state.graphql_schema
await app.refresh_schema()
new_schema = app.state.graphql_schema

result = validate_schema_refresh(old_schema, new_schema)
assert len(result["lost_types"]) == 0  # No types lost
assert len(result["new_types"]) > 0    # New types discovered
```

## Best Practices

1. **Minimize refresh calls** - Use class-scoped fixtures
2. **Create functions before refresh** - Schema won't discover functions created after
3. **Clean up is automatic** - Database fixtures handle cleanup
4. **Validate in debug mode** - Enable DEBUG logging to see validation results

```python
import logging
logging.getLogger("fraiseql").setLevel(logging.DEBUG)
```
```

### Step 5: Update Blocker Analysis Document

Since the blocker is now resolved, update `/tmp/fraiseql-phase1.5-blocker-analysis.md`:

Add a **RESOLVED** section at the top:

```markdown
# ✅ BLOCKER RESOLVED

**Resolution Date**: December 12, 2025
**Solution**: Schema Refresh API (Phases 1-4)
**Implementation**: `app.refresh_schema()` method in `src/fraiseql/fastapi/app.py`

The schema refresh API enables dynamic schema updates after database changes,
unblocking all WP-034 native error array tests.

**Phase Implementation**:
- Phase 1 (RED): Test-first approach - `tests/unit/fastapi/test_schema_refresh.py`
- Phase 2 (GREEN): Implementation - `app.refresh_schema()` method
- Phase 3 (REFACTOR): Extracted utilities - `fraiseql.testing.schema_utils`
- Phase 4 (QA): Integration - WP-034 tests now passing

**Documentation**: See `docs/testing.md` for usage guide

---

# [Original Analysis Below]
# Phase 1.5 Execution - Blocker Analysis
...
```

---

## Verification Commands

### Run WP-034 tests (primary goal)
```bash
uv run pytest tests/integration/graphql/mutations/test_native_error_arrays.py -v
```

**Expected**: 4/4 PASSED ✅

### Run all mutation integration tests
```bash
uv run pytest tests/integration/graphql/mutations/ -v
```

**Expected**: All mutation tests pass

### Run full integration test suite
```bash
uv run pytest tests/integration/ -v
```

**Expected**: No regressions

### Verify schema refresh tests still pass
```bash
uv run pytest tests/unit/fastapi/test_schema_refresh.py -v
```

**Expected**: 3/3 PASSED ✅

### Check documentation renders correctly
```bash
# If using mkdocs or similar
mkdocs serve
# Navigate to testing.md page
```

---

## Acceptance Criteria

- [ ] WP-034 test fixture updated to use `refresh_schema()`
- [ ] All 4 `@pytest.mark.skip` decorators removed
- [ ] All 4 WP-034 test classes pass without modification
- [ ] Testing documentation created with examples
- [ ] Blocker analysis updated with resolution
- [ ] No regressions in integration tests
- [ ] Documentation is clear and includes best practices

---

## DO NOT

- ❌ Modify test assertions (tests should pass as-written)
- ❌ Skip documenting the feature (future developers need this)
- ❌ Leave skip decorators in place (defeats the purpose)
- ❌ Forget to test integration (this is QA phase!)

---

## Success Metrics

### Before (Phase 1.5 Blocked)
```
tests/integration/graphql/mutations/test_native_error_arrays.py
  4 tests SKIPPED
  Reason: "Requires dynamic schema discovery"

WP-034 feature: UNTESTED ❌
```

### After (Phase 4 Complete)
```
tests/integration/graphql/mutations/test_native_error_arrays.py
  4 tests PASSED ✅

WP-034 feature: TESTED AND WORKING ✅
Schema refresh API: DOCUMENTED ✅
```

---

## Edge Cases to Test

### 1. Multiple Schema Refreshes
```python
await app.refresh_schema()  # First refresh
# Create more functions
await app.refresh_schema()  # Second refresh
# Should work without issues
```

### 2. Refresh with No New Functions
```python
await app.refresh_schema()
# Should preserve existing schema, no errors
```

### 3. Refresh After Function Deletion
```python
# Create and discover function
await app.refresh_schema()
# Drop function
await conn.execute("DROP FUNCTION my_test_mutation()")
await app.refresh_schema()
# Should not error, just remove mutation from schema
```

**Note**: These edge cases are implicitly tested by the Phase 1-3 tests.

---

## Documentation Checklist

Ensure `docs/testing.md` includes:

- [ ] **Problem statement** - Why refresh is needed
- [ ] **Solution overview** - `app.refresh_schema()` method
- [ ] **Code examples** - Complete fixture example
- [ ] **When to use** - Decision criteria
- [ ] **Performance notes** - Class-scoped fixtures
- [ ] **Utilities reference** - All 3 testing utilities
- [ ] **Best practices** - Do's and don'ts
- [ ] **Real example** - Link to WP-034 tests

---

## Integration Test Pattern

**Standard pattern** for dynamic mutation testing:

```python
# 1. Create fixture with refresh
@pytest.fixture
async def app_with_test_mutations(app, db_url):
    # Create functions
    async with await psycopg.AsyncConnection.connect(db_url) as conn:
        await conn.execute("CREATE FUNCTION ...")
        await conn.commit()

    # Refresh schema
    await app.refresh_schema()
    yield app

# 2. Use fixture in tests
class TestDynamicMutations:
    async def test_mutation(
        self,
        app_with_test_mutations,  # ← Ensures refresh happened
        graphql_client,
    ):
        result = await graphql_client.execute(...)
        assert result.data["myMutation"] is not None
```

This pattern is now **proven and documented** for future use.

---

## Phase Completion

**Definition of Done**:
- WP-034 tests pass (original blocker resolved)
- Feature documented with examples
- No regressions in test suite
- Blocker analysis updated
- Ready for production use

**Commit Message**:
```bash
test(mutations): enable WP-034 native error array tests [QA]

Unblock and enable WP-034 integration tests using schema refresh API.
All 4 test classes now pass without modification.

Changes:
- Update conftest to use app.refresh_schema()
- Remove @pytest.mark.skip decorators from WP-034 tests
- Add comprehensive testing documentation
- Mark original blocker as resolved

The schema refresh API successfully resolves the architectural
constraint that prevented testing dynamically created mutations.

WP-034 Feature Status: TESTED AND VERIFIED ✅

Closes: Phase 4 of schema refresh API implementation
Resolves: /tmp/fraiseql-phase1.5-blocker-analysis.md blocker
```

---

## Post-QA Validation

After this phase completes, validate:

1. ✅ **Feature works**: WP-034 tests pass
2. ✅ **Documentation exists**: `docs/testing.md` has refresh guide
3. ✅ **No regressions**: Full test suite passes
4. ✅ **Blocker removed**: Original issue resolved

**Ready for**: Merge to dev branch, update changelog, close related issues.
