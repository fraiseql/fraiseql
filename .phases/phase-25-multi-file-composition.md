# Phase 25: Multi-File Schema Composition

## Objective

Enable flexible schema composition from monolithic single files to deeply nested directory structures, supporting complex domain models while maintaining a unified compilation pipeline.

## Background

**Current State** (Phase 24):
- Schema merger handles single `types.json` + `fraiseql.toml`
- IntermediateSchema uses Vec-based arrays (merge-friendly)
- Validator performs comprehensive cross-reference checking
- CLI: `fraiseql compile fraiseql.toml --types types.json`

**Limitation**: No support for splitting schema across multiple files or organizing by domain/module.

**User Vision**:
> "we should be able to compose the json files (and sdk files) as we see fit, from a single schema.json to very deeply nested tree of files when the model domain is ultra-complex"

**Key Architectural Principle**:
- TOML only for operational config (security, database, federation, observers, caching, analytics)
- JSON files from language SDKs contain schema definitions (types, queries, mutations)
- **No schema duplication** between JSON and TOML

## Composition Strategies

### Strategy 1: Directory-Based Auto-Discovery

**Pattern**: Recursive scanning with conventional directory structure

```
schema/
├── types/
│   ├── user.json
│   ├── post.json
│   └── comment.json
├── queries/
│   ├── user_queries.json
│   └── post_queries.json
├── mutations/
│   └── mutations.json
└── fraiseql.toml
```

**CLI Usage**:
```bash
fraiseql compile schema/fraiseql.toml --schema-dir schema/
```

**Advantages**:
- Zero configuration overhead
- Natural organization by domain
- Clear separation of types/queries/mutations
- IDE-friendly (navigate by file)

**Implementation**:
1. Recursive directory traversal using `walkdir` crate
2. Collect all `*.json` files
3. Parse and merge into Vec arrays
4. Alphabetical ordering for determinism

**Edge Cases**:
- Duplicate type names → Error with file locations
- Circular references → Validation detects and reports
- Empty directories → Ignored silently

---

### Strategy 2: Explicit Manifest

**Pattern**: Optional `schema.manifest.json` for explicit ordering

```
schema/
├── schema.manifest.json
├── core/
│   ├── primitives.json
│   └── base_types.json
├── domain/
│   ├── users.json
│   └── posts.json
└── fraiseql.toml
```

**Manifest Format**:
```json
{
  "include": [
    "core/primitives.json",
    "core/base_types.json",
    "domain/users.json",
    "domain/posts.json"
  ],
  "order": "explicit"
}
```

**CLI Usage**:
```bash
fraiseql compile schema/fraiseql.toml --manifest schema/schema.manifest.json
```

**Advantages**:
- Explicit control over merge order
- Can express dependencies (load base types first)
- Self-documenting schema structure
- Supports glob patterns: `"domain/**/*.json"`

**Implementation**:
1. Parse manifest file
2. Resolve globs and paths
3. Load files in specified order
4. Merge sequentially into Vec arrays

**Edge Cases**:
- Missing files in manifest → Error immediately
- Conflicting ordering constraints → Validation error
- Circular includes → Detect and error

---

### Strategy 3: TOML-Based Includes

**Pattern**: Extend `fraiseql.toml` with schema includes

```toml
[schema]
name = "my_api"
version = "2.0.0"
database_target = "postgresql"

[schema.includes]
types = ["types/**/*.json"]
queries = ["queries/**/*.json"]
mutations = ["mutations/**/*.json"]

[database]
url = "postgresql://localhost/mydb"

[security]
default_policy = "authenticated"
# ... security config
```

**CLI Usage**:
```bash
fraiseql compile fraiseql.toml
# No additional flags needed - includes in TOML
```

**Advantages**:
- Single source of truth (TOML file)
- Glob patterns for flexibility
- Maintains existing CLI interface
- Clear separation: TOML = config + schema locations

**Implementation**:
1. Parse TOML config
2. Extract `schema.includes` section
3. Resolve globs for each category
4. Load and merge files by category
5. Apply operational config from TOML

**Edge Cases**:
- No includes specified → Fall back to single-file mode
- Overlapping globs → Deduplicate by path
- Invalid patterns → Error with helpful message

---

### Strategy 4: Hybrid Approach (RECOMMENDED)

**Pattern**: Combine TOML includes with auto-discovery fallback

```
project/
├── fraiseql.toml          # Config + optional includes
├── schema/
│   ├── types/
│   │   ├── auth/
│   │   │   ├── user.json
│   │   │   └── session.json
│   │   └── content/
│   │       ├── post.json
│   │       └── comment.json
│   ├── queries/
│   │   ├── auth_queries.json
│   │   └── content_queries.json
│   └── mutations/
│       └── content_mutations.json
└── sdk/
    ├── python/
    │   └── types.json     # Generated by SDK
    └── nodejs/
        └── types.json     # Generated by SDK
```

**TOML Configuration** (Flexible):
```toml
[schema]
name = "my_api"
version = "2.0.0"
database_target = "postgresql"

# Option A: Explicit includes
[schema.includes]
types = ["schema/types/**/*.json", "sdk/*/types.json"]
queries = ["schema/queries/**/*.json"]
mutations = ["schema/mutations/**/*.json"]

# Option B: Directory auto-discovery (if includes not specified)
# schema_dir = "schema/"

[database]
url = "postgresql://localhost/mydb"

[security]
default_policy = "authenticated"
```

**CLI Usage** (Multiple modes):
```bash
# Mode 1: TOML with explicit includes
fraiseql compile fraiseql.toml

# Mode 2: TOML + auto-discovery directory
fraiseql compile fraiseql.toml --schema-dir schema/

# Mode 3: Single file (backward compatible)
fraiseql compile fraiseql.toml --types types.json

# Mode 4: Multiple explicit files
fraiseql compile fraiseql.toml \
  --types schema/types/*.json \
  --queries schema/queries/*.json
```

**Advantages**:
- **Maximum flexibility**: Users choose complexity level
- **Backward compatible**: Single-file mode still works
- **Scalable**: Simple projects use simple structure, complex projects use advanced features
- **Progressive adoption**: Start simple, add organization as needed

**Precedence Rules**:
1. Explicit `--types`, `--queries` flags (highest priority)
2. `schema.includes` in TOML
3. `--schema-dir` auto-discovery
4. Error if none specified

---

## Implementation Plan

### Phase 25 Cycle 1: Core Multi-File Loading

**RED**: Write tests for multi-file loading
```rust
#[test]
fn test_merge_multiple_type_files() {
    // Create temp directory with 3 type files
    // Merge all files
    // Verify all types present in result
    // Verify no duplicates
}

#[test]
fn test_merge_respects_alphabetical_order() {
    // Files: a.json, b.json, c.json
    // Verify merge order is deterministic
}
```

**GREEN**: Implement basic multi-file loader
```rust
// crates/fraiseql-cli/src/schema/multi_file_loader.rs

pub struct MultiFileLoader;

impl MultiFileLoader {
    /// Load and merge all JSON files from directory
    pub fn load_from_directory(dir_path: &str) -> Result<Value> {
        let mut types = Vec::new();
        let mut queries = Vec::new();
        let mut mutations = Vec::new();

        for entry in WalkDir::new(dir_path)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.path().extension() == Some(OsStr::new("json")))
        {
            let content = fs::read_to_string(entry.path())?;
            let value: Value = serde_json::from_str(&content)?;

            // Merge types
            if let Some(Value::Array(t)) = value.get("types") {
                types.extend(t.clone());
            }

            // Merge queries
            if let Some(Value::Array(q)) = value.get("queries") {
                queries.extend(q.clone());
            }

            // Merge mutations
            if let Some(Value::Array(m)) = value.get("mutations") {
                mutations.extend(m.clone());
            }
        }

        Ok(json!({
            "types": types,
            "queries": queries,
            "mutations": mutations,
        }))
    }
}
```

**REFACTOR**: Extract deduplication logic
```rust
fn deduplicate_by_name(items: &mut Vec<Value>, category: &str) -> Result<()> {
    let mut seen = HashSet::new();
    let mut duplicates = Vec::new();

    for item in items.iter() {
        if let Some(name) = item.get("name").and_then(|v| v.as_str()) {
            if !seen.insert(name.to_string()) {
                duplicates.push(name.to_string());
            }
        }
    }

    if !duplicates.is_empty() {
        return Err(anyhow!(
            "Duplicate {} found: {}",
            category,
            duplicates.join(", ")
        ));
    }

    Ok(())
}
```

**CLEANUP**: Add docs, lint, commit

---

### Phase 25 Cycle 2: TOML Includes Support

**RED**: Write tests for TOML includes
```rust
#[test]
fn test_toml_includes_loads_files() {
    // Create TOML with includes section
    // Create matching JSON files
    // Verify all files loaded
}

#[test]
fn test_toml_includes_supports_globs() {
    // TOML: types = ["types/**/*.json"]
    // Create nested directory structure
    // Verify all matched files loaded
}
```

**GREEN**: Extend TOML schema
```rust
// crates/fraiseql-cli/src/config/mod.rs

#[derive(Debug, Deserialize)]
pub struct TomlSchema {
    pub schema: SchemaMetadata,
    pub database: DatabaseConfig,
    pub security: SecurityConfig,

    // NEW: Schema includes
    #[serde(default)]
    pub includes: SchemaIncludes,

    // ... existing fields
}

#[derive(Debug, Deserialize, Default)]
pub struct SchemaIncludes {
    #[serde(default)]
    pub types: Vec<String>,

    #[serde(default)]
    pub queries: Vec<String>,

    #[serde(default)]
    pub mutations: Vec<String>,
}

impl SchemaIncludes {
    pub fn resolve_globs(&self) -> Result<ResolvedIncludes> {
        let types = self.expand_patterns(&self.types)?;
        let queries = self.expand_patterns(&self.queries)?;
        let mutations = self.expand_patterns(&self.mutations)?;

        Ok(ResolvedIncludes { types, queries, mutations })
    }

    fn expand_patterns(&self, patterns: &[String]) -> Result<Vec<PathBuf>> {
        let mut paths = Vec::new();

        for pattern in patterns {
            for entry in glob(pattern)? {
                paths.push(entry?);
            }
        }

        // Sort for determinism
        paths.sort();

        Ok(paths)
    }
}
```

**REFACTOR**: Merge with existing merger
```rust
impl SchemaMerger {
    pub fn merge_with_includes(toml_path: &str) -> Result<IntermediateSchema> {
        let toml_schema = TomlSchema::from_file(toml_path)?;
        let includes = toml_schema.includes.resolve_globs()?;

        // Load all included files
        let mut merged_value = MultiFileLoader::load_from_paths(&includes)?;

        // Merge with TOML config
        Self::merge_values(&merged_value, &toml_schema)
    }
}
```

**CLEANUP**: Docs, lint, commit

---

### Phase 25 Cycle 3: CLI Enhancement

**RED**: Write tests for new CLI flags
```rust
#[test]
fn test_cli_schema_dir_flag() {
    // fraiseql compile fraiseql.toml --schema-dir schema/
    // Verify auto-discovery works
}

#[test]
fn test_cli_multiple_types_flag() {
    // fraiseql compile fraiseql.toml --types a.json --types b.json
    // Verify both files loaded
}
```

**GREEN**: Update compile command
```rust
// crates/fraiseql-cli/src/commands/compile.rs

#[derive(Parser)]
pub struct CompileCommand {
    /// Path to fraiseql.toml
    pub config_path: String,

    /// Path to types.json (single file, backward compatible)
    #[arg(long)]
    pub types: Option<String>,

    /// Directory for auto-discovery of schema files
    #[arg(long)]
    pub schema_dir: Option<String>,

    /// Multiple type files (repeatable)
    #[arg(long = "type-file")]
    pub type_files: Vec<String>,

    /// Multiple query files (repeatable)
    #[arg(long = "query-file")]
    pub query_files: Vec<String>,

    /// Multiple mutation files (repeatable)
    #[arg(long = "mutation-file")]
    pub mutation_files: Vec<String>,

    /// Output path for compiled schema
    #[arg(short, long, default_value = "schema.compiled.json")]
    pub output: String,
}

impl CompileCommand {
    pub fn run(&self) -> Result<()> {
        let schema = if !self.type_files.is_empty()
            || !self.query_files.is_empty()
            || !self.mutation_files.is_empty()
        {
            // Mode 1: Explicit file lists
            SchemaMerger::merge_explicit_files(
                &self.config_path,
                &self.type_files,
                &self.query_files,
                &self.mutation_files,
            )?
        } else if let Some(schema_dir) = &self.schema_dir {
            // Mode 2: Auto-discovery
            SchemaMerger::merge_from_directory(&self.config_path, schema_dir)?
        } else if let Some(types_path) = &self.types {
            // Mode 3: Single file (backward compatible)
            SchemaMerger::merge_files(types_path, &self.config_path)?
        } else {
            // Mode 4: TOML includes only
            SchemaMerger::merge_with_includes(&self.config_path)?
        };

        // Write compiled schema
        let compiled = serde_json::to_string_pretty(&schema)?;
        fs::write(&self.output, compiled)?;

        println!("✅ Schema compiled to {}", self.output);
        Ok(())
    }
}
```

**REFACTOR**: Extract mode selection logic

**CLEANUP**: Update help text, docs, commit

---

### Phase 25 Cycle 4: Conflict Detection & Resolution

**RED**: Write tests for conflicts
```rust
#[test]
fn test_duplicate_type_names_error() {
    // File1: User type
    // File2: User type (different definition)
    // Should error with both file paths
}

#[test]
fn test_circular_reference_detection() {
    // Type A references Type B
    // Type B references Type A
    // Should detect and error
}

#[test]
fn test_missing_type_reference_error() {
    // Query references Type "Foo"
    // Type "Foo" not defined in any file
    // Should error with query location
}
```

**GREEN**: Implement conflict detection
```rust
pub struct ConflictDetector;

impl ConflictDetector {
    pub fn check_duplicates(
        items: &[Value],
        category: &str,
        file_map: &HashMap<String, String>,
    ) -> Result<()> {
        let mut name_to_file = HashMap::new();

        for item in items {
            if let Some(name) = item.get("name").and_then(|v| v.as_str()) {
                if let Some(existing_file) = name_to_file.get(name) {
                    let current_file = file_map.get(name).unwrap();
                    return Err(anyhow!(
                        "Duplicate {} '{}' found in:\n  - {}\n  - {}",
                        category,
                        name,
                        existing_file,
                        current_file
                    ));
                }
                name_to_file.insert(name.to_string(), file_map.get(name).unwrap().clone());
            }
        }

        Ok(())
    }

    pub fn check_references(schema: &IntermediateSchema) -> Result<()> {
        let type_names: HashSet<_> = schema.types.iter()
            .map(|t| t.name.as_str())
            .collect();

        // Check query return types
        for query in &schema.queries {
            if !type_names.contains(query.return_type.as_str()) {
                return Err(anyhow!(
                    "Query '{}' references undefined type '{}'",
                    query.name,
                    query.return_type
                ));
            }
        }

        // Check mutation return types
        for mutation in &schema.mutations {
            if !type_names.contains(mutation.return_type.as_str()) {
                return Err(anyhow!(
                    "Mutation '{}' references undefined type '{}'",
                    mutation.name,
                    mutation.return_type
                ));
            }
        }

        Ok(())
    }
}
```

**REFACTOR**: Integrate with validator

**CLEANUP**: Docs, commit

---

### Phase 25 Cycle 5: Documentation & Examples

**RED**: Create example projects
- Simple monolithic: `examples/simple-monolithic/`
- Medium modular: `examples/medium-modular/`
- Complex nested: `examples/complex-nested/`

**GREEN**: Write documentation
```markdown
# Multi-File Schema Composition

## Simple (Monolithic)

Use single file for small projects:

\`\`\`bash
fraiseql compile fraiseql.toml --types schema.json
\`\`\`

## Medium (Modular)

Split by domain:

\`\`\`
schema/
├── auth.json
├── users.json
└── posts.json
\`\`\`

\`\`\`bash
fraiseql compile fraiseql.toml --schema-dir schema/
\`\`\`

## Complex (Nested)

Organize by feature and type:

\`\`\`
schema/
├── types/
│   ├── auth/
│   │   ├── user.json
│   │   └── session.json
│   └── content/
│       ├── post.json
│       └── comment.json
├── queries/
│   ├── auth_queries.json
│   └── content_queries.json
└── mutations/
    └── content_mutations.json
\`\`\`

\`\`\`toml
[schema.includes]
types = ["schema/types/**/*.json"]
queries = ["schema/queries/**/*.json"]
mutations = ["schema/mutations/**/*.json"]
\`\`\`

\`\`\`bash
fraiseql compile fraiseql.toml
\`\`\`
```

**REFACTOR**: Update existing examples

**CLEANUP**: Commit all docs

---

### Phase 25 Cycle 6: Integration Testing

**RED**: Write end-to-end tests
```rust
#[test]
fn test_e2e_simple_monolithic() {
    // Single types.json + fraiseql.toml
    // Compile and verify
}

#[test]
fn test_e2e_medium_modular() {
    // Multiple files in single directory
    // Compile and verify all types/queries present
}

#[test]
fn test_e2e_complex_nested() {
    // Deeply nested directory structure
    // TOML includes with globs
    // Compile and verify complete schema
}

#[test]
fn test_e2e_cross_file_references() {
    // Type in file A
    // Query in file B referencing type from A
    // Verify reference resolution works
}
```

**GREEN**: Ensure all tests pass

**REFACTOR**: Extract test helpers

**CLEANUP**: Final commit for Phase 25

---

## File Organization Patterns

### Pattern 1: Flat Structure (Small Projects)
```
project/
├── fraiseql.toml
└── schema.json
```

### Pattern 2: By Domain (Medium Projects)
```
project/
├── fraiseql.toml
└── schema/
    ├── users.json
    ├── posts.json
    ├── comments.json
    └── analytics.json
```

### Pattern 3: By Type Category (Large Projects)
```
project/
├── fraiseql.toml
└── schema/
    ├── types/
    │   ├── user.json
    │   ├── post.json
    │   └── comment.json
    ├── queries/
    │   ├── user_queries.json
    │   └── post_queries.json
    └── mutations/
        └── mutations.json
```

### Pattern 4: Hierarchical (Enterprise Projects)
```
project/
├── fraiseql.toml
└── schema/
    ├── types/
    │   ├── core/
    │   │   ├── primitives.json
    │   │   └── base_types.json
    │   ├── auth/
    │   │   ├── user.json
    │   │   ├── role.json
    │   │   └── permission.json
    │   ├── content/
    │   │   ├── post.json
    │   │   ├── comment.json
    │   │   └── media.json
    │   └── analytics/
    │       ├── metric.json
    │       └── event.json
    ├── queries/
    │   ├── auth_queries.json
    │   ├── content_queries.json
    │   └── analytics_queries.json
    └── mutations/
        ├── auth_mutations.json
        └── content_mutations.json
```

---

## Migration Guide

### From Phase 24 (Single File)

**Before**:
```bash
fraiseql compile fraiseql.toml --types types.json
```

**After** (No changes required - backward compatible):
```bash
fraiseql compile fraiseql.toml --types types.json
```

### Migrating to Multi-File

**Step 1**: Create directory structure
```bash
mkdir -p schema/types schema/queries schema/mutations
```

**Step 2**: Split existing `types.json`
```bash
# Manual split or script
# types.json → schema/types/user.json, schema/types/post.json, etc.
```

**Step 3**: Update compilation command
```bash
fraiseql compile fraiseql.toml --schema-dir schema/
```

**Step 4** (Optional): Use TOML includes
```toml
[schema.includes]
types = ["schema/types/**/*.json"]
queries = ["schema/queries/**/*.json"]
```

---

## Success Criteria

- [ ] Multi-file loading works via `--schema-dir`
- [ ] TOML includes support with glob patterns
- [ ] CLI supports multiple modes (single, multi, includes)
- [ ] Duplicate detection with helpful error messages
- [ ] Cross-file reference validation
- [ ] Deterministic merge order (alphabetical)
- [ ] Backward compatible with single-file mode
- [ ] Documentation with 4 example patterns
- [ ] Integration tests for all patterns
- [ ] Zero clippy warnings
- [ ] Migration guide for existing users

---

## Dependencies

- **Requires**: Phase 24 complete (schema merger fixed)
- **Crates needed**: `walkdir` for directory traversal, `glob` for pattern matching

---

## Status

[ ] Not Started | [ ] In Progress | [ ] Complete

---

**Last Updated**: February 1, 2026
**Version**: 1.0-design
