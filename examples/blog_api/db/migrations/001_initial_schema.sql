-- Blog API Schema with Sacred Trinity Pattern

-- Create extension for UUID generation if not exists
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- User table (write side)
CREATE TABLE IF NOT EXISTS tb_user (
    -- Sacred Trinity
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_user UUID DEFAULT gen_random_uuid() NOT NULL,
    identifier TEXT, -- Will store the user's email as business identifier

    -- User data
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    bio TEXT,
    avatar_url VARCHAR(500),
    is_active BOOLEAN DEFAULT true,
    roles TEXT[] DEFAULT ARRAY['user'],

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints following naming convention
    CONSTRAINT pk_tb_user PRIMARY KEY (id),
    CONSTRAINT uq_tb_user_pk UNIQUE (pk_user),
    CONSTRAINT uq_tb_user_identifier UNIQUE (identifier) WHERE identifier IS NOT NULL,
    CONSTRAINT uq_tb_user_email UNIQUE (email)
);

-- Post table (write side)
CREATE TABLE IF NOT EXISTS tb_post (
    -- Sacred Trinity
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_post UUID DEFAULT gen_random_uuid() NOT NULL,
    identifier TEXT, -- Will store the slug as business identifier

    -- Post data
    fk_user UUID NOT NULL,
    title VARCHAR(500) NOT NULL,
    slug VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    excerpt TEXT,
    tags TEXT[] DEFAULT ARRAY[]::TEXT[],
    is_published BOOLEAN DEFAULT false,
    published_at TIMESTAMPTZ,
    view_count INTEGER DEFAULT 0,

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints following naming convention
    CONSTRAINT pk_tb_post PRIMARY KEY (id),
    CONSTRAINT uq_tb_post_pk UNIQUE (pk_post),
    CONSTRAINT uq_tb_post_identifier UNIQUE (identifier) WHERE identifier IS NOT NULL,
    CONSTRAINT uq_tb_post_slug UNIQUE (slug),
    CONSTRAINT fk_tb_post_user FOREIGN KEY (fk_user)
        REFERENCES tb_user(pk_user) ON DELETE CASCADE
);

-- Comment table (write side)
CREATE TABLE IF NOT EXISTS tb_comment (
    -- Sacred Trinity
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_comment UUID DEFAULT gen_random_uuid() NOT NULL,
    identifier TEXT, -- Optional identifier for comments

    -- Comment data
    fk_post UUID NOT NULL,
    fk_user UUID NOT NULL,
    fk_parent_comment UUID,
    content TEXT NOT NULL,
    is_edited BOOLEAN DEFAULT false,

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints following naming convention
    CONSTRAINT pk_tb_comment PRIMARY KEY (id),
    CONSTRAINT uq_tb_comment_pk UNIQUE (pk_comment),
    CONSTRAINT uq_tb_comment_identifier UNIQUE (identifier) WHERE identifier IS NOT NULL,
    CONSTRAINT fk_tb_comment_post FOREIGN KEY (fk_post)
        REFERENCES tb_post(pk_post) ON DELETE CASCADE,
    CONSTRAINT fk_tb_comment_user FOREIGN KEY (fk_user)
        REFERENCES tb_user(pk_user) ON DELETE CASCADE,
    CONSTRAINT fk_tb_comment_parent FOREIGN KEY (fk_parent_comment)
        REFERENCES tb_comment(pk_comment) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_tb_user_email ON tb_user(email);
CREATE INDEX idx_tb_user_active ON tb_user(is_active);

CREATE INDEX idx_tb_post_user ON tb_post(fk_user);
CREATE INDEX idx_tb_post_slug ON tb_post(slug);
CREATE INDEX idx_tb_post_published ON tb_post(is_published);
CREATE INDEX idx_tb_post_created ON tb_post(created_at);
CREATE INDEX idx_tb_post_tags ON tb_post USING gin(tags);

CREATE INDEX idx_tb_comment_post ON tb_comment(fk_post);
CREATE INDEX idx_tb_comment_user ON tb_comment(fk_user);
CREATE INDEX idx_tb_comment_parent ON tb_comment(fk_parent_comment);

-- Input types for mutations
CREATE TYPE post_input AS (
    title VARCHAR(500),
    content TEXT,
    excerpt TEXT,
    tags TEXT[],
    is_published BOOLEAN
);

CREATE TYPE comment_input AS (
    content TEXT,
    fk_parent_comment UUID
);

-- Post mutation functions
CREATE OR REPLACE FUNCTION fn_create_post(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_data post_input
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_pk UUID;
    v_slug TEXT;
    v_payload_after JSONB;
    v_fields TEXT[] := ARRAY['title', 'content', 'excerpt', 'tags', 'is_published'];
BEGIN
    -- 1. Input validation
    IF input_data.title IS NULL OR length(trim(input_data.title)) = 0 THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            NULL,
            'NOOP',
            'noop:invalid_title',
            v_fields,
            'Title is required',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_create',
                'reason', 'missing_required_field',
                'field', 'title'
            )
        );
    END IF;

    -- 2. Generate slug from title
    v_slug := lower(regexp_replace(trim(input_data.title), '[^a-zA-Z0-9]+', '-', 'g'));

    -- Check if slug already exists
    IF EXISTS (SELECT 1 FROM tb_post WHERE slug = v_slug) THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            NULL,
            'NOOP',
            'noop:duplicate_slug',
            v_fields,
            'A post with this title already exists',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_create',
                'reason', 'duplicate_slug',
                'slug', v_slug
            )
        );
    END IF;

    -- Check if user exists
    IF NOT EXISTS (SELECT 1 FROM tb_user WHERE pk_user = input_fk_user) THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            NULL,
            'NOOP',
            'noop:user_not_found',
            v_fields,
            'User not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_create',
                'reason', 'user_not_found',
                'user_id', input_fk_user
            )
        );
    END IF;

    -- 3. Direct insert into tb_ table (NO TRIGGERS)
    INSERT INTO tb_post (
        pk_post,
        identifier,
        fk_user,
        title,
        slug,
        content,
        excerpt,
        tags,
        is_published,
        published_at,
        created_at,
        updated_at
    ) VALUES (
        gen_random_uuid(),
        v_slug,
        input_fk_user,
        input_data.title,
        v_slug,
        input_data.content,
        COALESCE(input_data.excerpt, left(input_data.content, 200)),
        COALESCE(input_data.tags, ARRAY[]::TEXT[]),
        COALESCE(input_data.is_published, false),
        CASE WHEN input_data.is_published THEN NOW() ELSE NULL END,
        NOW(),
        NOW()
    )
    RETURNING id, pk_post INTO v_id, v_pk;

    -- 4. Get final state
    SELECT jsonb_build_object(
        'id', p.pk_post,
        'title', p.title,
        'slug', p.slug,
        'content', p.content,
        'excerpt', p.excerpt,
        'tags', p.tags,
        'is_published', p.is_published,
        'published_at', p.published_at,
        'created_at', p.created_at,
        'updated_at', p.updated_at
    ) INTO v_payload_after
    FROM tb_post p
    WHERE p.id = v_id;

    -- 5. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'post',
        v_pk,
        'INSERT',
        'new',
        v_fields,
        'Post created successfully',
        NULL,
        v_payload_after,
        jsonb_build_object(
            'trigger', 'api_create'
        )
    );
END;
$$;

CREATE OR REPLACE FUNCTION fn_update_post(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_pk_post UUID,
    input_data post_input
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_fields TEXT[] := ARRAY['title', 'content', 'excerpt', 'tags', 'is_published'];
    v_payload_before JSONB;
    v_payload_after JSONB;
    v_slug TEXT;
    v_old_slug TEXT;
    v_changed_fields TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- 1. Check if post exists and get current state
    SELECT
        id,
        slug,
        jsonb_build_object(
            'id', pk_post,
            'title', title,
            'slug', slug,
            'content', content,
            'excerpt', excerpt,
            'tags', tags,
            'is_published', is_published,
            'published_at', published_at,
            'created_at', created_at,
            'updated_at', updated_at
        ) INTO v_id, v_old_slug, v_payload_before
    FROM tb_post
    WHERE pk_post = input_pk_post;

    IF NOT FOUND THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            input_pk_post,
            'NOOP',
            'noop:not_found',
            v_fields,
            'Post not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'post_not_found'
            )
        );
    END IF;

    -- 2. Input validation
    IF input_data.title IS NOT NULL AND length(trim(input_data.title)) = 0 THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            input_pk_post,
            'NOOP',
            'noop:invalid_title',
            v_fields,
            'Title cannot be empty',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'empty_title'
            )
        );
    END IF;

    -- 3. Generate new slug if title changed
    IF input_data.title IS NOT NULL THEN
        v_slug := lower(regexp_replace(trim(input_data.title), '[^a-zA-Z0-9]+', '-', 'g'));
        -- Check slug uniqueness only if it changed
        IF v_slug <> v_old_slug AND EXISTS (SELECT 1 FROM tb_post WHERE slug = v_slug) THEN
            RETURN core.log_and_return_mutation(
                input_pk_organization,
                input_fk_user,
                'post',
                input_pk_post,
                'NOOP',
                'noop:duplicate_slug',
                v_fields,
                'A post with this title already exists',
                v_payload_before,
                NULL,
                jsonb_build_object(
                    'trigger', 'api_update',
                    'reason', 'duplicate_slug',
                    'slug', v_slug
                )
            );
        END IF;
        v_changed_fields := array_append(v_changed_fields, 'title');
        v_changed_fields := array_append(v_changed_fields, 'slug');
    END IF;

    -- Track changed fields
    IF input_data.content IS NOT NULL THEN
        v_changed_fields := array_append(v_changed_fields, 'content');
    END IF;
    IF input_data.excerpt IS NOT NULL THEN
        v_changed_fields := array_append(v_changed_fields, 'excerpt');
    END IF;
    IF input_data.tags IS NOT NULL THEN
        v_changed_fields := array_append(v_changed_fields, 'tags');
    END IF;
    IF input_data.is_published IS NOT NULL THEN
        v_changed_fields := array_append(v_changed_fields, 'is_published');
        v_changed_fields := array_append(v_changed_fields, 'published_at');
    END IF;

    -- 4. Update the post
    UPDATE tb_post SET
        title = COALESCE(input_data.title, title),
        slug = COALESCE(v_slug, slug),
        content = COALESCE(input_data.content, content),
        excerpt = COALESCE(input_data.excerpt, excerpt),
        tags = COALESCE(input_data.tags, tags),
        is_published = COALESCE(input_data.is_published, is_published),
        published_at = CASE
            WHEN input_data.is_published IS NOT NULL AND input_data.is_published AND published_at IS NULL
            THEN NOW()
            ELSE published_at
        END,
        updated_at = NOW()
    WHERE id = v_id
    RETURNING jsonb_build_object(
        'id', pk_post,
        'title', title,
        'slug', slug,
        'content', content,
        'excerpt', excerpt,
        'tags', tags,
        'is_published', is_published,
        'published_at', published_at,
        'created_at', created_at,
        'updated_at', updated_at
    ) INTO v_payload_after;

    -- 5. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'post',
        input_pk_post,
        'UPDATE',
        'updated',
        v_changed_fields,
        'Post updated successfully',
        v_payload_before,
        v_payload_after,
        jsonb_build_object(
            'trigger', 'api_update'
        )
    );
END;
$$;

CREATE OR REPLACE FUNCTION fn_delete_post(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_pk_post UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_payload_before JSONB;
    v_fields TEXT[] := ARRAY['all'];
BEGIN
    -- 1. Check if post exists and get current state
    SELECT
        id,
        jsonb_build_object(
            'id', pk_post,
            'title', title,
            'slug', slug,
            'content', content,
            'excerpt', excerpt,
            'tags', tags,
            'is_published', is_published,
            'published_at', published_at,
            'created_at', created_at,
            'updated_at', updated_at
        ) INTO v_id, v_payload_before
    FROM tb_post
    WHERE pk_post = input_pk_post;

    IF NOT FOUND THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            input_pk_post,
            'NOOP',
            'noop:not_found',
            v_fields,
            'Post not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_delete',
                'reason', 'post_not_found'
            )
        );
    END IF;

    -- 2. Check for dependent records (comments)
    IF EXISTS (SELECT 1 FROM tb_comment WHERE fk_post = input_pk_post) THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'post',
            input_pk_post,
            'NOOP',
            'noop:has_comments',
            v_fields,
            'Cannot delete post with existing comments',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_delete',
                'reason', 'has_dependent_comments'
            )
        );
    END IF;

    -- 3. Delete the post
    DELETE FROM tb_post WHERE id = v_id;

    -- 4. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'post',
        input_pk_post,
        'DELETE',
        'deleted',
        v_fields,
        'Post deleted successfully',
        v_payload_before,
        NULL,
        jsonb_build_object(
            'trigger', 'api_delete'
        )
    );
END;
$$;

-- Comment mutation functions
CREATE OR REPLACE FUNCTION fn_create_comment(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_fk_post UUID,
    input_data comment_input
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_pk UUID;
    v_fields TEXT[] := ARRAY['content', 'parent_comment'];
    v_payload_after JSONB;
BEGIN
    -- 1. Input validation
    IF input_data.content IS NULL OR length(trim(input_data.content)) = 0 THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            NULL,
            'NOOP',
            'noop:invalid_content',
            v_fields,
            'Content is required',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_create',
                'reason', 'missing_required_field',
                'field', 'content'
            )
        );
    END IF;

    -- 2. Check if post exists
    IF NOT EXISTS (SELECT 1 FROM tb_post WHERE pk_post = input_fk_post) THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            NULL,
            'NOOP',
            'noop:post_not_found',
            v_fields,
            'Post not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_create',
                'reason', 'post_not_found',
                'post_id', input_fk_post
            )
        );
    END IF;

    -- 3. Check parent comment if provided
    IF input_data.fk_parent_comment IS NOT NULL THEN
        IF NOT EXISTS (
            SELECT 1
            FROM tb_comment
            WHERE pk_comment = input_data.fk_parent_comment
              AND fk_post = input_fk_post
        ) THEN
            RETURN core.log_and_return_mutation(
                input_pk_organization,
                input_fk_user,
                'comment',
                NULL,
                'NOOP',
                'noop:parent_not_found',
                v_fields,
                'Parent comment not found or belongs to different post',
                NULL,
                NULL,
                jsonb_build_object(
                    'trigger', 'api_create',
                    'reason', 'parent_comment_not_found',
                    'parent_id', input_data.fk_parent_comment
                )
            );
        END IF;
    END IF;

    -- 4. Insert comment
    INSERT INTO tb_comment (
        pk_comment,
        fk_post,
        fk_user,
        fk_parent_comment,
        content,
        created_at,
        updated_at
    ) VALUES (
        gen_random_uuid(),
        input_fk_post,
        input_fk_user,
        input_data.fk_parent_comment,
        trim(input_data.content),
        NOW(),
        NOW()
    )
    RETURNING id, pk_comment INTO v_id, v_pk;

    -- 5. Get final state
    SELECT jsonb_build_object(
        'id', c.pk_comment,
        'content', c.content,
        'is_edited', c.is_edited,
        'fk_post', c.fk_post,
        'fk_user', c.fk_user,
        'fk_parent_comment', c.fk_parent_comment,
        'created_at', c.created_at,
        'updated_at', c.updated_at
    ) INTO v_payload_after
    FROM tb_comment c
    WHERE c.id = v_id;

    -- 6. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'comment',
        v_pk,
        'INSERT',
        'new',
        v_fields,
        'Comment created successfully',
        NULL,
        v_payload_after,
        jsonb_build_object(
            'trigger', 'api_create'
        )
    );
END;
$$;

CREATE OR REPLACE FUNCTION fn_update_comment(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_pk_comment UUID,
    input_data comment_input
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_fields TEXT[] := ARRAY['content'];
    v_payload_before JSONB;
    v_payload_after JSONB;
BEGIN
    -- 1. Check if comment exists and get current state
    SELECT
        id,
        jsonb_build_object(
            'id', pk_comment,
            'content', content,
            'is_edited', is_edited,
            'fk_post', fk_post,
            'fk_user', fk_user,
            'fk_parent_comment', fk_parent_comment,
            'created_at', created_at,
            'updated_at', updated_at
        ) INTO v_id, v_payload_before
    FROM tb_comment
    WHERE pk_comment = input_pk_comment;

    IF NOT FOUND THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:not_found',
            v_fields,
            'Comment not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'comment_not_found'
            )
        );
    END IF;

    -- 2. Verify ownership
    IF (v_payload_before->>'fk_user')::UUID != input_fk_user THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:not_owner',
            v_fields,
            'Only the comment author can edit it',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'not_comment_owner'
            )
        );
    END IF;

    -- 3. Input validation
    IF input_data.content IS NULL OR length(trim(input_data.content)) = 0 THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:invalid_content',
            v_fields,
            'Content cannot be empty',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'empty_content'
            )
        );
    END IF;

    -- 4. Cannot change parent comment
    IF input_data.fk_parent_comment IS NOT NULL THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:cannot_change_parent',
            v_fields,
            'Cannot change parent comment',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_update',
                'reason', 'parent_change_not_allowed'
            )
        );
    END IF;

    -- 5. Update comment
    UPDATE tb_comment SET
        content = trim(input_data.content),
        is_edited = TRUE,
        updated_at = NOW()
    WHERE id = v_id
    RETURNING jsonb_build_object(
        'id', pk_comment,
        'content', content,
        'is_edited', is_edited,
        'fk_post', fk_post,
        'fk_user', fk_user,
        'fk_parent_comment', fk_parent_comment,
        'created_at', created_at,
        'updated_at', updated_at
    ) INTO v_payload_after;

    -- 6. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'comment',
        input_pk_comment,
        'UPDATE',
        'updated',
        v_fields,
        'Comment updated successfully',
        v_payload_before,
        v_payload_after,
        jsonb_build_object(
            'trigger', 'api_update'
        )
    );
END;
$$;

CREATE OR REPLACE FUNCTION fn_delete_comment(
    input_pk_organization UUID,
    input_fk_user UUID,
    input_pk_comment UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id INTEGER;
    v_payload_before JSONB;
    v_fields TEXT[] := ARRAY['all'];
BEGIN
    -- 1. Check if comment exists and get current state
    SELECT
        id,
        data INTO v_id, v_payload_before
    FROM v_comment
    WHERE id = input_pk_comment;

    IF NOT FOUND THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:not_found',
            v_fields,
            'Comment not found',
            NULL,
            NULL,
            jsonb_build_object(
                'trigger', 'api_delete',
                'reason', 'comment_not_found'
            )
        );
    END IF;

    -- 2. Verify ownership
    IF (v_payload_before->'author'->>'id')::UUID != input_fk_user THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:not_owner',
            v_fields,
            'Only the comment author can delete it',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_delete',
                'reason', 'not_comment_owner'
            )
        );
    END IF;

    -- 3. Check for child comments
    IF EXISTS (SELECT 1 FROM tb_comment WHERE fk_parent_comment = input_pk_comment) THEN
        RETURN core.log_and_return_mutation(
            input_pk_organization,
            input_fk_user,
            'comment',
            input_pk_comment,
            'NOOP',
            'noop:has_replies',
            v_fields,
            'Cannot delete comment with replies',
            v_payload_before,
            NULL,
            jsonb_build_object(
                'trigger', 'api_delete',
                'reason', 'has_child_comments'
            )
        );
    END IF;

    -- 4. Delete the comment
    DELETE FROM tb_comment WHERE id = v_id;

    -- 5. Return success result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_fk_user,
        'comment',
        input_pk_comment,
        'DELETE',
        'deleted',
        v_fields,
        'Comment deleted successfully',
        v_payload_before,
        NULL,
        jsonb_build_object(
            'trigger', 'api_delete'
        )
    );
END;
$$;

-- Query-side views with composition
-- Base views return denormalized data as JSONB
-- Complex views compose data from simpler views

-- User view (base)
CREATE OR REPLACE VIEW v_user AS
SELECT
    u.pk_user AS id,
    jsonb_build_object(
        'id', u.pk_user,
        'identifier', u.identifier,
        'email', u.email,
        'name', u.name,
        'bio', u.bio,
        'avatar_url', u.avatar_url,
        'is_active', u.is_active,
        'roles', u.roles,
        'created_at', u.created_at,
        'updated_at', u.updated_at
    ) AS data
FROM tb_user u;

-- Post view composed with author data
CREATE OR REPLACE VIEW v_post AS
SELECT
    p.pk_post AS id,
    jsonb_build_object(
        'id', p.pk_post,
        'identifier', p.identifier,
        'title', p.title,
        'slug', p.slug,
        'content', p.content,
        'excerpt', p.excerpt,
        'tags', p.tags,
        'is_published', p.is_published,
        'published_at', p.published_at,
        'view_count', p.view_count,
        'created_at', p.created_at,
        'updated_at', p.updated_at,
        'author', u.data - 'email' - 'roles' - 'is_active' - 'bio'  -- Only include necessary author fields
    ) AS data
FROM tb_post p
JOIN v_user u ON u.id = p.fk_user;

-- Comment view composed with author, post and parent data
CREATE OR REPLACE VIEW v_comment AS
WITH RECURSIVE comment_tree AS (
    -- Base case: comments without parents
    SELECT
        c.pk_comment,
        c.id,
        c.identifier,
        c.content,
        c.is_edited,
        c.fk_post,
        c.fk_user,
        c.fk_parent_comment,
        c.created_at,
        c.updated_at,
        0 AS depth,
        ARRAY[c.id] AS path
    FROM tb_comment c
    WHERE c.fk_parent_comment IS NULL

    UNION ALL

    -- Recursive case: child comments
    SELECT
        c.pk_comment,
        c.id,
        c.identifier,
        c.content,
        c.is_edited,
        c.fk_post,
        c.fk_user,
        c.fk_parent_comment,
        c.created_at,
        c.updated_at,
        ct.depth + 1,
        ct.path || c.id
    FROM tb_comment c
    JOIN comment_tree ct ON ct.pk_comment = c.fk_parent_comment
    WHERE NOT c.id = ANY(ct.path) -- Prevent cycles
)
SELECT
    c.pk_comment AS id,
    jsonb_build_object(
        'id', c.pk_comment,
        'identifier', c.identifier,
        'content', c.content,
        'is_edited', c.is_edited,
        'depth', c.depth,
        'path', c.path,
        'created_at', c.created_at,
        'updated_at', c.updated_at,
        'post', p.data - 'content' - 'excerpt' - 'tags' - 'view_count' - 'author', -- Only include necessary post fields
        'author', u.data - 'email' - 'roles' - 'is_active' - 'bio', -- Only include necessary author fields
        'parent_comment', CASE
            WHEN pc.id IS NOT NULL THEN jsonb_build_object(
                'id', pc.id,
                'content', (pc.data->>'content')::text,
                'author', pc.data->'author'
            )
            ELSE NULL
        END
    ) AS data
FROM comment_tree c
JOIN v_post p ON p.id = c.fk_post
JOIN v_user u ON u.id = c.fk_user
LEFT JOIN v_comment pc ON pc.id = c.fk_parent_comment;
