"""
Integration tests for native error arrays in mutation responses.

Tests that error arrays are automatically populated on ALL mutation error responses,
without requiring MutationResultBase.

WP-034 Phase 1 - Feature implemented in v1.8.0-beta.4 (2025-12-09)
"""

import pytest
from fraiseql.types.errors import Error


class TestAutoGeneratedErrors:
    """Test automatic error array generation from status strings."""

    @pytest.mark.asyncio
    async def test_auto_generated_errors_from_status(self, blog_simple_graphql_client, blog_simple_db_connection):
        """
        Test that error responses automatically include errors array
        populated from status string, WITHOUT using MutationResultBase.
        """
        db = blog_simple_db_connection
        # Setup: Create a mutation function that returns validation error
        await db.execute("""
            CREATE OR REPLACE FUNCTION test_auto_error()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error(
                    'Validation failed',
                    'User',
                    NULL
                );
            END;
            $$;
        """)

        # Execute mutation
        query = """
            mutation {
                testAutoError {
                    code
                    status
                    message
                    errors {
                        code
                        identifier
                        message
                        details
                    }
                }
            }
        """
        result = await blog_simple_graphql_client.execute(query)

        # Assertions
        assert result.get("errors") is None, f"GraphQL errors occurred: {result.get('errors')}"
        data = result["data"]["testAutoError"]

        assert data["code"] == 400
        assert data["status"] == "failed:validation"
        assert data["message"] == "Validation failed"

        # âœ… THIS IS THE KEY TEST - errors array should exist and be populated
        assert "errors" in data, "errors field missing from response"
        assert data["errors"] is not None, "errors field is None"
        assert len(data["errors"]) == 1, f"Expected 1 error, got {len(data['errors'])}"
        assert data["errors"][0]["code"] == 400
        assert data["errors"][0]["identifier"] == "validation"
        assert data["errors"][0]["message"] == "Validation failed"
        assert data["errors"][0]["details"] is None

    @pytest.mark.asyncio
    async def test_auto_generated_errors_multiple_status_formats(
        self, blog_simple_graphql_client, blog_simple_db_connection
    ):
        """
        Test error generation from different status string formats:
        - failed:validation -> identifier="validation"
        - noop:not_found -> identifier="not_found"
        - failed:authorization -> identifier="authorization"
        - failed -> identifier="general_error"
        """
        db = blog_simple_db_connection
        test_cases = [
            ("failed:validation", "validation", 400),
            ("noop:not_found", "not_found", 404),
            ("failed:authorization", "authorization", 403),
            ("failed", "general_error", 500),
        ]

        for status, expected_id, expected_code in test_cases:
            # Create function for this test case
            func_name = f"test_status_{expected_id}"
            await db.execute(f"""
                CREATE OR REPLACE FUNCTION {func_name}()
                RETURNS mutation_response
                LANGUAGE plpgsql
                AS $$
                BEGIN
                    RETURN (
                        '{status}',
                        'Test message',
                        NULL,
                        'TestType',
                        NULL,
                        NULL,
                        NULL,
                        NULL
                    )::mutation_response;
                END;
                $$;
            """)

            # Execute query
            query = f"""
                mutation {{
                    {func_name.replace("_", "")}() {{
                        code
                        errors {{
                            identifier
                        }}
                    }}
                }}
            """
            result = await blog_simple_graphql_client.execute(query)

            assert result.get("errors") is None, f"GraphQL errors for {status}: {result.errors}"
            data = result["data"][func_name.replace("_", "")]

            # Verify error array generated
            assert "errors" in data, f"errors field missing for status '{status}'"
            assert data["errors"] is not None, f"errors is None for status '{status}'"
            assert len(data["errors"]) > 0, f"errors array empty for status '{status}'"
            assert data["errors"][0]["identifier"] == expected_id, (
                f"Expected identifier '{expected_id}' for status '{status}', got '{data['errors'][0]['identifier']}'"
            )


class TestExplicitErrors:
    """Test explicit error arrays via metadata.errors."""

    @pytest.mark.asyncio
    async def test_explicit_errors_override_auto_generation(self, blog_simple_graphql_client, blog_simple_db_connection):
        """
        Test that explicit errors in metadata.errors override auto-generation.
        This supports Pattern 2 (explicit validation errors).
        """
        db = blog_simple_db_connection
        await db.execute("""
            CREATE OR REPLACE FUNCTION test_explicit_errors()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN (
                    'failed:validation',
                    'Multiple validation errors',
                    NULL,
                    'User',
                    NULL,
                    NULL,
                    NULL,
                    jsonb_build_object(
                        'errors', jsonb_build_array(
                            jsonb_build_object(
                                'code', 400,
                                'identifier', 'email_invalid',
                                'message', 'Email format is invalid',
                                'details', jsonb_build_object('field', 'email')
                            ),
                            jsonb_build_object(
                                'code', 400,
                                'identifier', 'password_weak',
                                'message', 'Password must be at least 8 characters',
                                'details', jsonb_build_object('field', 'password')
                            )
                        )
                    )
                )::mutation_response;
            END;
            $$;
        """)

        query = """
            mutation {
                testExplicitErrors {
                    code
                    message
                    errors {
                        code
                        identifier
                        message
                        details
                    }
                }
            }
        """
        result = await blog_simple_graphql_client.execute(query)

        assert result.get("errors") is None, f"GraphQL errors occurred: {result.errors}"
        data = result["data"]["testExplicitErrors"]

        # Should have 2 explicit errors, NOT auto-generated single error
        assert "errors" in data, "errors field missing"
        assert data["errors"] is not None, "errors is None"
        assert len(data["errors"]) == 2, f"Expected 2 explicit errors, got {len(data['errors'])}"

        # Verify first error
        assert data["errors"][0]["identifier"] == "email_invalid"
        assert data["errors"][0]["message"] == "Email format is invalid"
        assert data["errors"][0]["details"]["field"] == "email"

        # Verify second error
        assert data["errors"][1]["identifier"] == "password_weak"
        assert data["errors"][1]["message"] == "Password must be at least 8 characters"
        assert data["errors"][1]["details"]["field"] == "password"


class TestBackwardCompatibility:
    """Test backward compatibility with MutationResultBase."""

    @pytest.mark.asyncio
    async def test_backward_compatibility_with_mutation_result_base(
        self, blog_simple_graphql_client, blog_simple_db_connection
    ):
        """
        Test that MutationResultBase still works (for backward compatibility).
        This ensures existing code using the base class continues to function.
        """
        db = blog_simple_db_connection
        await db.execute("""
            CREATE OR REPLACE FUNCTION test_with_base()
            RETURNS mutation_response
            LANGUAGE plpgsql
            AS $$
            BEGIN
                RETURN mutation_validation_error(
                    'Validation failed',
                    'User',
                    NULL
                );
            END;
            $$;
        """)

        query = """
            mutation {
                testWithBase {
                    code
                    status
                    message
                    errors {
                        code
                        identifier
                        message
                    }
                }
            }
        """
        result = await blog_simple_graphql_client.execute(query)

        # Should still work - errors populated
        assert result.get("errors") is None, f"GraphQL errors occurred: {result.errors}"
        data = result["data"]["testWithBase"]

        assert "errors" in data, "errors field missing with MutationResultBase pattern"
        assert data["errors"] is not None, "errors is None"
        assert len(data["errors"]) == 1, f"Expected 1 error, got {len(data['errors'])}"
        assert data["errors"][0]["identifier"] == "validation"
