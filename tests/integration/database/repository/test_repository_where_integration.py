"""Test FraiseQLRepository integration with where types and operator-based filtering.

This test suite ensures that the repository can handle where types generated by
safe_create_where_type, including operator-based filtering like {eq: value, gt: value}.
"""

from datetime import UTC, date, datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID, uuid4

import pytest

pytestmark = pytest.mark.database

# Import database fixtures for this database test

from fixtures.database.database_conftest import *  # noqa: F403

import fraiseql
from fraiseql.db import FraiseQLRepository, register_type_for_view
from fraiseql.sql.where_generator import safe_create_where_type


# Test types
@fraiseql.type
class Product:
    id: UUID
    name: str
    price: Decimal
    stock: int
    created_at: datetime
    is_active: bool
    category: Optional[str] = None


@fraiseql.type
class Order:
    id: UUID
    product_id: UUID
    quantity: int
    total: Decimal
    order_date: date
    status: str


# Generate where types
ProductWhere = safe_create_where_type(Product)
OrderWhere = safe_create_where_type(Order)


class TestRepositoryWhereIntegration:
    """Test suite for repository where type integration."""

    @pytest.fixture
    async def setup_test_views(self, db_pool):
        """Create test views with proper structure."""
        # Register types for views (for development mode)
        register_type_for_view("test_product_view", Product)
        register_type_for_view("test_order_view", Order)

        async with db_pool.connection() as conn:
            # Create tables
            await conn.execute(
                """
                CREATE TABLE IF NOT EXISTS test_products (
                    id UUID PRIMARY KEY,
                    name TEXT NOT NULL,
                    price DECIMAL(10,2) NOT NULL,
                    stock INTEGER NOT NULL,
                    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
                    is_active BOOLEAN NOT NULL,
                    category TEXT
                )
            """
            )

            await conn.execute(
                """
                CREATE TABLE IF NOT EXISTS test_orders (
                    id UUID PRIMARY KEY,
                    product_id UUID NOT NULL,
                    quantity INTEGER NOT NULL,
                    total DECIMAL(10,2) NOT NULL,
                    order_date DATE NOT NULL,
                    status TEXT NOT NULL
                )
            """
            )

            # Create views with JSONB data column
            await conn.execute(
                """
                CREATE OR REPLACE VIEW test_product_view AS
                SELECT
                    id, name, price, stock, created_at, is_active, category,
                    jsonb_build_object(
                        'id', id,
                        'name', name,
                        'price', price,
                        'stock', stock,
                        'created_at', created_at,
                        'is_active', is_active,
                        'category', category
                    ) as data
                FROM test_products
            """
            )

            await conn.execute(
                """
                CREATE OR REPLACE VIEW test_order_view AS
                SELECT
                    id, product_id, quantity, total, order_date, status,
                    jsonb_build_object(
                        'id', id,
                        'product_id', product_id,
                        'quantity', quantity,
                        'total', total,
                        'order_date', order_date,
                        'status', status
                    ) as data
                FROM test_orders
            """
            )

            # Insert test data
            product_id = uuid4()
            await conn.execute(
                """
                INSERT INTO test_products (id, name, price, stock, created_at, is_active, category)
                VALUES
                    (%s, 'Widget A', 19.99, 100, '2024-01-01 10:00:00+00', true, 'widgets'),
                    (%s, 'Widget B', 29.99, 50, '2024-01-02 10:00:00+00', true, 'widgets'),
                    (%s, 'Gadget X', 99.99, 10, '2024-01-03 10:00:00+00', false, 'gadgets'),
                    (%s, 'Gadget Y', 149.99, 5, '2024-01-04 10:00:00+00', true, null)
            """,
                (uuid4(), uuid4(), uuid4(), product_id),
            )

            await conn.execute(
                """
                INSERT INTO test_orders (id, product_id, quantity, total, order_date, status)
                VALUES
                    (%s, %s, 2, 39.98, '2024-01-05', 'completed'),
                    (%s, %s, 1, 19.99, '2024-01-06', 'pending'),
                    (%s, %s, 3, 89.97, '2024-01-07', 'completed')
            """,
                (uuid4(), product_id, uuid4(), product_id, uuid4(), product_id),
            )

        yield

        # Cleanup
        async with db_pool.connection() as conn:
            await conn.execute("DROP VIEW IF EXISTS test_product_view")
            await conn.execute("DROP VIEW IF EXISTS test_order_view")
            await conn.execute("DROP TABLE IF EXISTS test_orders")
            await conn.execute("DROP TABLE IF EXISTS test_products")

    @pytest.mark.asyncio
    async def test_find_with_simple_where_equality(self, db_pool, setup_test_views):
        """Test finding records with simple equality operator."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Create where filter
        where = ProductWhere(name={"eq": "Widget A"})

        # Find products
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 1
        assert isinstance(results[0], Product)
        assert results[0].name == "Widget A"
        assert results[0].price == Decimal("19.99")

    @pytest.mark.asyncio
    async def test_find_with_comparison_operators(self, db_pool, setup_test_views):
        """Test finding records with comparison operators."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Test greater than
        where = ProductWhere(price={"gt": 50})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 2
        assert all(r.price > 50 for r in results)

        # Test less than or equal
        where = ProductWhere(stock={"lte": 50})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 3
        assert all(r.stock <= 50 for r in results)

    @pytest.mark.asyncio
    async def test_find_with_multiple_operators(self, db_pool, setup_test_views):
        """Test finding records with multiple operators on same field."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Price between 20 and 100
        where = ProductWhere(price={"gte": 20, "lt": 100})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 2
        assert all(20 <= r.price < 100 for r in results)

    @pytest.mark.asyncio
    async def test_find_with_multiple_fields(self, db_pool, setup_test_views):
        """Test finding records with filters on multiple fields."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Active widgets
        where = ProductWhere(category={"eq": "widgets"}, is_active={"eq": True})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 2
        assert all(r.category == "widgets" and r.is_active for r in results)

    @pytest.mark.asyncio
    async def test_find_with_null_handling(self, db_pool, setup_test_views):
        """Test finding records with null value handling."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Find products with null category
        where = ProductWhere(category={"isnull": True})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 1
        assert results[0].category is None

        # Find products with non-null category
        where = ProductWhere(category={"isnull": False})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 3
        assert all(r.category is not None for r in results)

    @pytest.mark.asyncio
    async def test_find_with_date_filtering(self, db_pool, setup_test_views):
        """Test finding records with date/datetime filtering."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Find products created after a date (Jan 2 midnight)
        # Should get products from Jan 3 and Jan 4 (created at 10:00)
        where = ProductWhere(
            created_at={"gt": datetime(2024, 1, 2, 11, 0, 0, tzinfo=UTC)}
        )  # After Jan 2 10:00
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 2  # Jan 3 and Jan 4

        # Find orders on specific date
        where = OrderWhere(order_date={"eq": date(2024, 1, 6)})
        results = await repo.find("test_order_view", where=where)

        assert len(results) == 1
        assert results[0].status == "pending"

    @pytest.mark.asyncio
    async def test_find_one_with_where(self, db_pool, setup_test_views):
        """Test find_one with where type filtering."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        where = ProductWhere(name={"eq": "Widget B"})
        result = await repo.find_one("test_product_view", where=where)

        assert result is not None
        assert isinstance(result, Product)
        assert result.name == "Widget B"
        assert result.price == Decimal("29.99")

    @pytest.mark.asyncio
    async def test_combining_where_with_kwargs(self, db_pool, setup_test_views):
        """Test combining where type with additional kwargs filters."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Where type for price filter
        where = ProductWhere(price={"lt": 100})

        # Additional kwargs filter
        results = await repo.find("test_product_view", where=where, is_active=True)

        assert len(results) == 2
        assert all(r.price < 100 and r.is_active for r in results)

    @pytest.mark.asyncio
    async def test_production_mode_returns_dicts(self, db_pool, setup_test_views):
        """Test that production mode returns raw dicts."""
        repo = FraiseQLRepository(db_pool, context={"mode": "production"})

        where = ProductWhere(category={"eq": "widgets"})
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 2
        assert all(isinstance(r, dict) for r in results)
        assert all(r["category"] == "widgets" for r in results)

    @pytest.mark.asyncio
    async def test_empty_where_returns_all(self, db_pool, setup_test_views):
        """Test that empty where object returns all records."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Empty where
        where = ProductWhere()
        results = await repo.find("test_product_view", where=where)

        assert len(results) == 4  # All products

    @pytest.mark.asyncio
    async def test_unsupported_operator_is_ignored(self, db_pool, setup_test_views):
        """Test that unsupported operators are ignored gracefully."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # The where generator skips unsupported operators
        where = ProductWhere()
        where.name = {"invalid_op": "value", "eq": "Widget A"}  # invalid_op is ignored

        # Should still work with the valid operator
        results = await repo.find("test_product_view", where=where)
        assert len(results) == 1
        assert results[0].name == "Widget A"

    @pytest.mark.asyncio
    async def test_complex_nested_where(self, db_pool, setup_test_views):
        """Test complex scenarios with nested where conditions."""
        repo = FraiseQLRepository(db_pool, context={"mode": "development"})

        # Find completed orders for products over $50
        product_where = ProductWhere(price={"gt": 50})
        expensive_products = await repo.find("test_product_view", where=product_where)

        product_ids = [p.id for p in expensive_products]

        # Now find orders for these products
        # This tests that UUID comparison works
        order_where = OrderWhere(status={"eq": "completed"})
        orders = await repo.find("test_order_view", where=order_where)

        # Filter in Python for this test (in real usage you'd use IN operator)
        relevant_orders = [o for o in orders if o.product_id in product_ids]

        assert len(relevant_orders) >= 0  # Depends on test data
