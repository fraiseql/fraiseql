package com.fraiseql.schema

import kotlinx.serialization.json.*
import java.io.File

/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */

data class TypeDefinition(
    val fields: Map<String, FieldDefinition>,
    val description: String? = null
)

data class FieldDefinition(
    val type: String,
    val nullable: Boolean = false,
    val description: String? = null,
    val scope: String? = null,
    val scopes: List<String>? = null
)

/**
 * Central registry for GraphQL type definitions
 */
object SchemaRegistry {
    private val types = mutableMapOf<String, TypeDefinition>()

    fun register(name: String, definition: TypeDefinition) {
        types[name] = definition
    }

    fun getTypeNames(): List<String> = types.keys.toList()

    fun getType(name: String): TypeDefinition? = types[name]

    fun clear() = types.clear()
}

/**
 * Schema API for type registration and export
 */
object Schema {
    /**
     * Register a type definition
     * @param name The type name
     * @param fields Map of field name to field definition
     * @param description Optional type description
     */
    fun registerType(name: String, fields: Map<String, Any>, description: String? = null) {
        val fieldDefs = mutableMapOf<String, FieldDefinition>()

        for ((fieldName, fieldConfig) in fields) {
            @Suppress("UNCHECKED_CAST")
            val config = fieldConfig as? Map<String, Any>
            if (config != null) {
                val type = config["type"] as? String ?: "String"
                val nullable = config["nullable"] as? Boolean ?: false
                val fieldDesc = config["description"] as? String

                // Extract scope information
                val scope = config["scope"] as? String
                @Suppress("UNCHECKED_CAST")
                val scopes = config["scopes"] as? List<String>

                // Validate scopes if present
                if (scope != null) {
                    validateScope(scope, name, fieldName)
                }
                if (scopes != null) {
                    if (scopes.isEmpty()) {
                        throw RuntimeException("Field $name.$fieldName has empty scopes array")
                    }
                    for (s in scopes) {
                        if (s.isEmpty()) {
                            throw RuntimeException("Field $name.$fieldName has empty scope in scopes array")
                        }
                        validateScope(s, name, fieldName)
                    }
                }

                // Ensure not both scope and scopes are specified
                if (scope != null && scopes != null) {
                    throw RuntimeException("Field $name.$fieldName cannot have both scope and scopes")
                }

                fieldDefs[fieldName] = FieldDefinition(
                    type = type,
                    nullable = nullable,
                    description = fieldDesc,
                    scope = scope,
                    scopes = scopes
                )
            }
        }

        SchemaRegistry.register(name, TypeDefinition(fieldDefs, description))
    }

    /**
     * Export minimal schema with only types (TOML workflow)
     *
     * Returns JSON containing only the "types" section.
     * All operational configuration (queries, mutations, federation, security, observers)
     * comes from fraiseql.toml and is merged during compilation.
     *
     * @param pretty Pretty-print JSON (true = formatted, false = compact)
     * @return JSON string with types only
     */
    fun exportTypes(pretty: Boolean = true): String {
        val typeNames = SchemaRegistry.getTypeNames()

        // Build minimal schema with only types
        val types = mutableListOf<JsonObject>()
        for (typeName in typeNames) {
            val typeInfo = SchemaRegistry.getType(typeName) ?: continue

            val fieldsArray = mutableListOf<JsonObject>()
            for ((fieldName, field) in typeInfo.fields) {
                val fieldObj = buildJsonObject {
                    put("name", fieldName)
                    put("type", field.type)
                    put("nullable", field.nullable)

                    // Export scope information
                    if (field.scope != null) {
                        put("scope", field.scope)
                    }
                    if (field.scopes != null) {
                        putJsonArray("scopes") {
                            field.scopes.forEach { add(it) }
                        }
                    }
                }
                fieldsArray.add(fieldObj)
            }

            val typeObj = buildJsonObject {
                put("name", typeName)
                putJsonArray("fields") {
                    fieldsArray.forEach { add(it) }
                }
                if (typeInfo.description != null) {
                    put("description", typeInfo.description)
                }
            }
            types.add(typeObj)
        }

        val minimalSchema = buildJsonObject {
            putJsonArray("types") {
                types.forEach { add(it) }
            }
        }

        // Export as JSON
        return if (pretty) {
            Json.encodeToString(JsonElement.serializer(), minimalSchema)
                .let { Json { prettyPrint = true }.encodeToString(Json.parseToJsonElement(it)) }
        } else {
            Json.encodeToString(JsonElement.serializer(), minimalSchema)
        }
    }

    /**
     * Export minimal types to a file
     *
     * @param outputPath File path for types.json
     */
    fun exportTypesFile(outputPath: String) {
        try {
            val typesJson = exportTypes(true)

            // Ensure directory exists
            val file = File(outputPath)
            file.parentFile?.mkdirs()

            // Write file
            file.writeText(typesJson)

            // Print summary
            val typesCount = SchemaRegistry.getTypeNames().size
            println("âœ… Types exported to $outputPath")
            println("   Types: $typesCount")
            println()
            println("ðŸŽ¯ Next steps:")
            println("   1. fraiseql compile fraiseql.toml --types $outputPath")
            println("   2. This merges types with TOML configuration")
            println("   3. Result: schema.compiled.json with types + all config")
        } catch (e: Exception) {
            throw RuntimeException("Failed to write types file: $outputPath")
        }
    }

    /**
     * Reset schema registry (useful for testing)
     */
    fun reset() {
        SchemaRegistry.clear()
    }

    /**
     * Get all registered type names
     * @return List of type names
     */
    fun getTypeNames(): List<String> {
        return SchemaRegistry.getTypeNames()
    }

    /**
     * Validate scope format: action:resource
     * Valid patterns:
     * - * (global wildcard)
     * - action:resource (read:user.email, write:User.salary)
     * - action:* (admin:*, read:*)
     */
    private fun validateScope(scope: String, typeName: String, fieldName: String) {
        if (scope.isEmpty()) {
            throw RuntimeException("Field $typeName.$fieldName has empty scope")
        }

        // Global wildcard is always valid
        if (scope == "*") {
            return
        }

        // Must contain at least one colon
        if (!scope.contains(":")) {
            throw RuntimeException(
                "Field $typeName.$fieldName has invalid scope '$scope' (missing colon)"
            )
        }

        val parts = scope.split(":", limit = 2)
        if (parts.size != 2) {
            throw RuntimeException(
                "Field $typeName.$fieldName has invalid scope '$scope'"
            )
        }

        val action = parts[0]
        val resource = parts[1]

        // Validate action: [a-zA-Z_][a-zA-Z0-9_]*
        if (!isValidAction(action)) {
            throw RuntimeException(
                "Field $typeName.$fieldName has invalid action in scope '$scope' (must be alphanumeric + underscore)"
            )
        }

        // Validate resource: [a-zA-Z_][a-zA-Z0-9_.]*|*
        if (!isValidResource(resource)) {
            throw RuntimeException(
                "Field $typeName.$fieldName has invalid resource in scope '$scope' (must be alphanumeric + underscore + dot, or *)"
            )
        }
    }

    /**
     * Check if action matches [a-zA-Z_][a-zA-Z0-9_]*
     */
    private fun isValidAction(action: String): Boolean {
        if (action.isEmpty()) {
            return false
        }

        // First character must be letter or underscore
        val firstChar = action[0]
        if (!firstChar.isLetter() && firstChar != '_') {
            return false
        }

        // Rest must be letters, digits, or underscores
        for (i in 1 until action.length) {
            val ch = action[i]
            if (!ch.isLetterOrDigit() && ch != '_') {
                return false
            }
        }

        return true
    }

    /**
     * Check if resource matches [a-zA-Z_][a-zA-Z0-9_.]*|*
     */
    private fun isValidResource(resource: String): Boolean {
        if (resource == "*") {
            return true
        }

        if (resource.isEmpty()) {
            return false
        }

        // First character must be letter or underscore
        val firstChar = resource[0]
        if (!firstChar.isLetter() && firstChar != '_') {
            return false
        }

        // Rest must be letters, digits, underscores, or dots
        for (i in 1 until resource.length) {
            val ch = resource[i]
            if (!ch.isLetterOrDigit() && ch != '_' && ch != '.') {
                return false
            }
        }

        return true
    }
}
