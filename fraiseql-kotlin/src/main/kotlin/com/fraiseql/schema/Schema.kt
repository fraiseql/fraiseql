package com.fraiseql.schema

import kotlinx.serialization.json.*
import java.io.File

/**
 * Facade for schema management and minimal types export (TOML-based workflow)
 *
 * This class provides a high-level API for:
 * - Registering types for export to types.json
 * - Exporting minimal schema (types only, no operational config)
 *
 * The TOML workflow separates:
 * - types.json: Generated by language SDKs (this class)
 * - fraiseql.toml: Configuration (queries, mutations, federation, security, observers)
 * - schema.compiled.json: Result of merging types.json + fraiseql.toml
 */

data class TypeDefinition(
    val fields: Map<String, FieldDefinition>,
    val description: String? = null
)

data class FieldDefinition(
    val type: String,
    val nullable: Boolean = false,
    val description: String? = null
)

/**
 * Central registry for GraphQL type definitions
 */
object SchemaRegistry {
    private val types = mutableMapOf<String, TypeDefinition>()

    fun register(name: String, definition: TypeDefinition) {
        types[name] = definition
    }

    fun getTypeNames(): List<String> = types.keys.toList()

    fun getType(name: String): TypeDefinition? = types[name]

    fun clear() = types.clear()
}

/**
 * Schema API for type registration and export
 */
object Schema {
    /**
     * Register a type definition
     * @param name The type name
     * @param fields Map of field name to field definition
     * @param description Optional type description
     */
    fun registerType(name: String, fields: Map<String, Any>, description: String? = null) {
        val fieldDefs = mutableMapOf<String, FieldDefinition>()

        for ((fieldName, fieldConfig) in fields) {
            @Suppress("UNCHECKED_CAST")
            val config = fieldConfig as? Map<String, Any>
            if (config != null) {
                val type = config["type"] as? String ?: "String"
                val nullable = config["nullable"] as? Boolean ?: false
                val fieldDesc = config["description"] as? String

                fieldDefs[fieldName] = FieldDefinition(
                    type = type,
                    nullable = nullable,
                    description = fieldDesc
                )
            }
        }

        SchemaRegistry.register(name, TypeDefinition(fieldDefs, description))
    }

    /**
     * Export minimal schema with only types (TOML workflow)
     *
     * Returns JSON containing only the "types" section.
     * All operational configuration (queries, mutations, federation, security, observers)
     * comes from fraiseql.toml and is merged during compilation.
     *
     * @param pretty Pretty-print JSON (true = formatted, false = compact)
     * @return JSON string with types only
     */
    fun exportTypes(pretty: Boolean = true): String {
        val typeNames = SchemaRegistry.getTypeNames()

        // Build minimal schema with only types
        val types = mutableListOf<JsonObject>()
        for (typeName in typeNames) {
            val typeInfo = SchemaRegistry.getType(typeName) ?: continue

            val fieldsArray = mutableListOf<JsonObject>()
            for ((fieldName, field) in typeInfo.fields) {
                val fieldObj = buildJsonObject {
                    put("name", fieldName)
                    put("type", field.type)
                    put("nullable", field.nullable)
                }
                fieldsArray.add(fieldObj)
            }

            val typeObj = buildJsonObject {
                put("name", typeName)
                putJsonArray("fields") {
                    fieldsArray.forEach { add(it) }
                }
                if (typeInfo.description != null) {
                    put("description", typeInfo.description)
                }
            }
            types.add(typeObj)
        }

        val minimalSchema = buildJsonObject {
            putJsonArray("types") {
                types.forEach { add(it) }
            }
        }

        // Export as JSON
        return if (pretty) {
            Json.encodeToString(JsonElement.serializer(), minimalSchema)
                .let { Json { prettyPrint = true }.encodeToString(Json.parseToJsonElement(it)) }
        } else {
            Json.encodeToString(JsonElement.serializer(), minimalSchema)
        }
    }

    /**
     * Export minimal types to a file
     *
     * @param outputPath File path for types.json
     */
    fun exportTypesFile(outputPath: String) {
        try {
            val typesJson = exportTypes(true)

            // Ensure directory exists
            val file = File(outputPath)
            file.parentFile?.mkdirs()

            // Write file
            file.writeText(typesJson)

            // Print summary
            val typesCount = SchemaRegistry.getTypeNames().size
            println("âœ… Types exported to $outputPath")
            println("   Types: $typesCount")
            println()
            println("ðŸŽ¯ Next steps:")
            println("   1. fraiseql compile fraiseql.toml --types $outputPath")
            println("   2. This merges types with TOML configuration")
            println("   3. Result: schema.compiled.json with types + all config")
        } catch (e: Exception) {
            throw RuntimeException("Failed to write types file: $outputPath")
        }
    }

    /**
     * Reset schema registry (useful for testing)
     */
    fun reset() {
        SchemaRegistry.clear()
    }

    /**
     * Get all registered type names
     * @return List of type names
     */
    fun getTypeNames(): List<String> {
        return SchemaRegistry.getTypeNames()
    }
}
