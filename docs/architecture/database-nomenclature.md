# Database Nomenclature Specification

## Core Naming Conventions

### Table Prefixes

| Prefix | Purpose | Description | Example |
|--------|---------|-------------|---------|
| `tb_` | Core Tables | Write-side command tables containing source of truth data | `tb_users`, `tb_products` |
| `v_` | Views | Read-side query views with computed/joined data | `v_user_profile`, `v_product_catalog` |
| `tv_` | Table Views | Projection tables with cached JSON data (updateable) | `tv_user_dashboard`, `tv_product_search` |
| `tl_` | Lookup Tables | Reference data and enumerations | `tl_country`, `tl_status` |
| `mv_` | Materialized Views | Standard PostgreSQL materialized views for reporting | `mv_monthly_stats` |

### ID Pattern (The Sacred Trinity)

Every core table (`tb_*`) MUST implement the trinity pattern:

```sql
CREATE TABLE tb_entity (
    -- 1. Internal sequence for debugging and ordering
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,

    -- 2. External UUID primary key for API exposure
    pk_entity UUID DEFAULT gen_random_uuid() NOT NULL,

    -- 3. Business identifier for human readability
    identifier TEXT,

    -- Constraints
    CONSTRAINT pk_tb_entity PRIMARY KEY (id),
    CONSTRAINT uq_tb_entity_pk UNIQUE (pk_entity),
    CONSTRAINT uq_tb_entity_identifier UNIQUE (identifier) WHERE identifier IS NOT NULL
);
```

### Foreign Key Conventions

| Pattern | Usage | Example |
|---------|-------|---------|
| `fk_[table]` | Standard foreign key reference | `fk_user`, `fk_product` |
| `fk_[table]_[role]` | Role-specific foreign key | `fk_user_creator`, `fk_user_approver` |

### Column Naming Standards

| Pattern | Type | Example |
|---------|------|---------|
| `is_[state]` | Boolean flags | `is_active`, `is_deleted`, `is_verified` |
| `has_[feature]` | Feature flags | `has_2fa`, `has_premium` |
| `can_[action]` | Permission flags | `can_edit`, `can_delete` |
| `[entity]_at` | Timestamps | `created_at`, `updated_at`, `deleted_at` |
| `[entity]_by` | Actor references | `created_by`, `approved_by` |
| `[entity]_count` | Counters | `login_count`, `view_count` |

### Index Naming

| Pattern | Purpose | Example |
|---------|---------|---------|
| `idx_[table]_[column(s)]` | Standard index | `idx_tb_users_email` |
| `idx_[table]_[column]_[condition]` | Conditional index | `idx_tb_users_email_active` |
| `idx_[table]_search` | Full-text search | `idx_tb_products_search` |

### Constraint Naming

| Pattern | Type | Example |
|---------|------|---------|
| `pk_[table]` | Primary key | `pk_tb_users` |
| `uq_[table]_[column(s)]` | Unique constraint | `uq_tb_users_email` |
| `ck_[table]_[rule]` | Check constraint | `ck_tb_users_age_positive` |
| `fk_[table]_[ref_table]_[column]` | Foreign key | `fk_tb_orders_tb_users_user_id` |

## Architectural Patterns

### CQRS Separation

#### Command Side (Write)
- Tables: `tb_*` prefix
- Focus: Transactional integrity, normalization
- Access: Write operations only

#### Query Side (Read)
- Objects: `v_*` views, `tv_*` projection tables
- Focus: Denormalized, optimized for queries
- Access: Read operations only

### Bounded Architecture with Lazy Caching

```sql
-- 1. Core table (Command side)
CREATE TABLE tb_product (...);

-- 2. Query view (Real-time)
CREATE VIEW v_product AS
SELECT pk_product AS id, jsonb_build_object(...) AS data
FROM tb_product;

-- 3. Projection table (Cached)
CREATE TABLE tv_product (
    id UUID PRIMARY KEY,
    data JSONB NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Cache invalidation trigger (ONLY on tv_ tables)
CREATE TRIGGER trg_product_version
AFTER INSERT OR UPDATE OR DELETE ON tv_product
FOR EACH STATEMENT
EXECUTE FUNCTION turbo.fn_increment_version('product');
```

### CRITICAL: Trigger Philosophy

**NEVER place triggers on tb_ base tables**. All mutations to base tables must be through explicit function calls:

1. **Command Side (tb_ tables)**: NO TRIGGERS
   - All operations via explicit functions: `create_product()`, `update_product()`, `delete_product()`
   - Clear control flow and debuggability
   - Predictable side effects

2. **Query Side (tv_ tables)**: ONLY cache invalidation triggers
   - Single purpose: increment domain version for cache invalidation
   - Triggered after projection updates
   - No business logic in triggers

**Data Flow**:
1. Application calls mutation function (e.g., `create_product()`)
2. Function updates `tb_*` base tables directly
3. Function calls `refresh_product()` to update `tv_product`
4. Trigger on `tv_product` increments domain version
5. Cache invalidation cascades automatically

## Mutation Patterns

### Function-Based Architecture

**ALL mutations to tb_ tables MUST go through explicit functions**:

```sql
-- Standard mutation function pattern
CREATE OR REPLACE FUNCTION create_order(
    input_pk_organization UUID,
    input_created_by UUID,
    input_data app.order_input
) RETURNS app.mutation_result
LANGUAGE plpgsql AS $$
DECLARE
    v_id UUID;
    v_payload_before JSONB;
    v_payload_after JSONB;
BEGIN
    -- 1. Validate inputs
    -- 2. Insert into tb_ table (NO TRIGGERS will fire)
    INSERT INTO tb_order (...) VALUES (...) RETURNING pk_order INTO v_id;

    -- 3. Explicitly refresh projection
    PERFORM app.refresh_single_order(v_id);

    -- 4. Capture final state
    SELECT data INTO v_payload_after FROM v_order WHERE id = v_id;

    -- 5. Return standardized result
    RETURN core.log_and_return_mutation(
        input_pk_organization,
        input_created_by,
        'order',
        v_id,
        'INSERT',
        'new',
        ARRAY['all'],
        'Order created successfully',
        NULL,  -- no before state for create
        v_payload_after,
        jsonb_build_object('trigger', 'api_create')
    );
END;
$$;
```

### Mutation Result Structure

```sql
CREATE TYPE app.mutation_result AS (
    id UUID,                    -- Entity ID
    updated_fields TEXT[],      -- Changed fields
    status TEXT,                -- Status code
    message TEXT,               -- Human message
    object_data JSONB,         -- Complete object from tv_/v_
    extra_metadata JSONB       -- Additional context
);
```

### Status Codes

- `new`: Created successfully
- `updated`: Modified
- `deleted`: Hard deleted
- `noop:not_found`: Entity doesn't exist
- `noop:duplicate`: Already exists
- `noop:no_changes`: No fields changed
- `noop:invalid_*`: Validation failure

## Function Naming

| Pattern | Purpose | Example |
|---------|---------|---------|
| `fn_[action]_[entity]` | Standard functions | `fn_get_user`, `fn_create_order` |
| `fn_[entity]_[action]` | Entity-focused | `fn_user_authenticate`, `fn_order_calculate_total` |
| `trg_[table]_[event]` | Trigger functions | `trg_tb_users_before_insert` |
| `sp_[process]` | Stored procedures | `sp_monthly_billing` |

## Migration File Naming

```
migrations/
├── 001_initial_schema.sql
├── 002_core_tables.sql
├── 003_views.sql
├── 004_functions.sql
├── 005_indexes.sql
└── 006_seed_data.sql
```

## Enforcement Rules

1. **No Mixed Prefixes**: Never mix prefixes (e.g., no `v_tb_users`)
2. **Consistent Casing**: Always use snake_case, never camelCase or PascalCase
3. **No Abbreviations**: Prefer clarity over brevity (`user_account` not `usr_acct`)
4. **Explicit Relationships**: Always name foreign keys explicitly
5. **Timestamp Consistency**: Always use `TIMESTAMPTZ` with `_at` suffix
6. **UUID Format**: Always use UUID v4 for external identifiers
7. **JSON Pattern**: Projection tables (`tv_*`) must have a `data JSONB` column

## Examples

### Complete Table Definition

```sql
CREATE TABLE tb_order (
    -- Sacred Trinity
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_order UUID DEFAULT gen_random_uuid() NOT NULL,
    identifier TEXT NOT NULL, -- ORD-2024-001234

    -- Foreign keys
    fk_user UUID NOT NULL,

    -- Business data
    total_amount DECIMAL(10,2) NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',

    -- Flags
    is_paid BOOLEAN DEFAULT FALSE,
    is_shipped BOOLEAN DEFAULT FALSE,
    has_discount BOOLEAN DEFAULT FALSE,

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID,

    -- Constraints
    CONSTRAINT pk_tb_order PRIMARY KEY (id),
    CONSTRAINT uq_tb_order_pk UNIQUE (pk_order),
    CONSTRAINT uq_tb_order_identifier UNIQUE (identifier),
    CONSTRAINT fk_tb_order_user FOREIGN KEY (fk_user)
        REFERENCES tb_user(pk_user),
    CONSTRAINT ck_tb_order_amount_positive CHECK (total_amount >= 0)
);

-- Indexes
CREATE INDEX idx_tb_order_user ON tb_order(fk_user);
CREATE INDEX idx_tb_order_status ON tb_order(status)
    WHERE status IN ('pending', 'processing');

-- Query side view
CREATE VIEW v_order AS
SELECT
    o.pk_order AS id,
    jsonb_build_object(
        'user_id', o.fk_user,
        'total_amount', o.total_amount,
        'status', o.status,
        'is_paid', o.is_paid,
        'is_shipped', o.is_shipped,
        'created_at', o.created_at
    ) AS data
FROM tb_order o
WHERE o.is_deleted = FALSE;

-- Projection table
CREATE TABLE tv_order (
    id UUID PRIMARY KEY,
    data JSONB NOT NULL,
    search_vector tsvector,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_tv_order_search ON tv_order USING gin(search_vector);
```

---

*Version: 2.0.0 | Based on PrintOptim Database Manifesto v3.0*
