# Concepts & Glossary

Key concepts and terminology in FraiseQL.

## Core Concepts

### CQRS (Command Query Responsibility Segregation)

Separating read and write operations for optimal performance:

**Traditional vs FraiseQL:**
```
Traditional Approach:                    FraiseQL Approach:
┌─────────────────┐                     ┌─────────────────────────────────────┐
│   GraphQL       │                     │         GraphQL API                 │
│   API           │                     ├──────────────────┬──────────────────┤
├─────────┬───────┤                     │   QUERIES        │   MUTATIONS      │
│ Query   │ Mut. │                     │   (Reads)        │   (Writes)       │
├─────────┼───────┤                     ├──────────────────┼──────────────────┤
│ ORM     │ ORM   │                     │  v_* views       │  fn_* functions  │
│ Read    │ Write │                     │  tv_* tables     │  tb_* tables     │
└─────────┴───────┘                     └──────────────────┴──────────────────┘
Same code path                          Separate optimized paths
```

- **Commands (Writes)**: Mutations that modify data
- **Queries (Reads)**: Queries that fetch data from optimized views

**Benefits**:
- Optimized read paths with PostgreSQL views
- ACID transactions for writes
- Independent scaling of reads and writes

### JSONB View Pattern

FraiseQL's core pattern for GraphQL types - database views return pre-composed JSONB:

**Data Flow:**
```
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│  tb_user        │  →   │   v_user         │  →   │  GraphQL        │
│ (base table)    │      │  (JSONB view)    │      │  Response       │
│                 │      │                  │      │                 │
│ pk_user: 1      │      │ SELECT           │      │ {               │
│ id: uuid-123    │      │ jsonb_build_     │      │   "id": "uuid"  │
│ identifier:     │      │   object(        │      │   "identifier": │
│   "alice"       │      │    'id', id,     │      │     "alice"     │
│ name: "Alice"   │      │    'identifier', │      │   "name": "..." │
│ email: a@b.com  │      │     identifier,  │      │ }               │
│                 │      │    'name', name  │      │                 │
└─────────────────┘      └──────────────────┘      └─────────────────┘
```

**SQL Example (with Trinity Identifiers):**
```sql
-- Base table with trinity identifiers
CREATE TABLE tb_user (
    pk_user INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- Internal
    id UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,         -- Public API
    identifier TEXT UNIQUE NOT NULL,                            -- Human-readable
    name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL
);

-- JSONB view exposes only public identifiers
CREATE VIEW v_user AS
SELECT
    id,  -- Direct column for efficient WHERE filtering (WHERE id = $1)
    jsonb_build_object(
        'id', id,                    -- Public UUID (exposed in GraphQL)
        'identifier', identifier,    -- Human-readable slug (exposed in GraphQL)
        'name', name,
        'email', email
        -- Note: pk_user NOT in view (internal only)
    ) as data
FROM tb_user;
```

**Python Type Definition:**
```python
import fraiseql
from uuid import UUID

@fraiseql.type(sql_source="v_user")
class User:
    """User with trinity identifiers."""
    id: UUID              # Public API identifier (stable, secure)
    identifier: str       # Human-readable slug (SEO-friendly)
    name: str
    email: str
    # Note: pk_user is NOT exposed in GraphQL type
```

**Why This Pattern?**
- ✅ **PostgreSQL composes JSONB** - One query, no N+1 problems
- ✅ **Rust transforms efficiently** - Compiled performance for field selection
- ✅ **Explicit field control** - Only fields in JSONB are accessible
- ✅ **Security by design** - Can't accidentally expose hidden columns
- ✅ **Trinity identifiers** - Three ID types for different purposes (see below)

### Trinity Identifiers

FraiseQL's pattern of using three identifier types per entity for optimal performance and usability:

**The Three Identifiers:**

```sql
CREATE TABLE tb_post (
    -- 1. pk_* - Internal primary key (NEVER exposed to GraphQL)
    pk_post INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    -- 2. id - Public API identifier (ALWAYS exposed, stable)
    id UUID DEFAULT gen_random_uuid() UNIQUE NOT NULL,

    -- 3. identifier - Human-readable slug (OPTIONAL, for SEO)
    identifier TEXT UNIQUE,

    -- Other fields
    title TEXT NOT NULL,
    content TEXT
);
```

**Purpose of Each Identifier:**

| Identifier Type | Purpose | Example | Exposed in API? | Use Case |
|----------------|---------|---------|-----------------|----------|
| **pk_post** | Fast integer joins in PostgreSQL | `1234` | ❌ Never | Database performance (JOINs, indexes) |
| **id** | Stable public API identifier | `550e8400-e29b-41d4-a716-446655440000` | ✅ Always | GraphQL queries, external integrations |
| **identifier** | Human-readable SEO slug | `"my-first-post"` | ✅ Optional | URLs, user-facing references |

**Why Three Identifiers?**

1. **Performance (pk_*):**
   - Integer primary keys are faster for JOINs than UUIDs
   - Smaller indexes, better cache locality
   - Sequential IDs optimize B-tree performance
   - **Never exposed** to prevent enumeration attacks

2. **Stability (id):**
   - UUIDs don't reveal database size or creation order
   - Can be generated client-side (distributed systems)
   - Stable even if slug changes
   - Safe for public APIs

3. **Usability (identifier):**
   - SEO-friendly URLs: `/posts/my-first-post` vs `/posts/550e8400...`
   - Human-readable references
   - Can change without breaking API (id stays stable)
   - Optional (not all entities need slugs)

**View column pattern:**

```sql
-- Leaf view (nothing references it) - only needs id for filtering
CREATE VIEW v_user AS
SELECT
    id,  -- For WHERE id = $1 filtering
    jsonb_build_object(
        'id', id,
        'name', name
    ) as data
FROM tb_user;

-- Referenced view - needs id AND pk_* for parent views to JOIN
CREATE VIEW v_post AS
SELECT
    id,       -- For WHERE id = $1 filtering
    pk_post,  -- For parent views to JOIN
    jsonb_build_object(
        'id', id,
        'identifier', identifier,
        'title', title,
        'content', content
    ) as data
FROM tb_post;

-- Parent view composing nested data using pk_post
CREATE VIEW v_user_with_posts AS
SELECT
    id,  -- For WHERE id = $1 filtering
    jsonb_build_object(
        'id', u.id,
        'name', u.name,
        'posts', (
            SELECT jsonb_agg(p.data)
            FROM v_post p
            JOIN tb_post tp ON tp.pk_post = p.pk_post
            WHERE tp.user_id = tb_user.pk_user
        )
    ) as data
FROM tb_user u;
```

**Rule:**
- **Always include `id`** (public identifier) for WHERE filtering
- **Include `pk_*`** only if other views need to JOIN to this view
- **Never include `pk_*` in JSONB** (internal only)

```python
import fraiseql
from uuid import UUID

@fraiseql.type(sql_source="v_post")
class Post:
    id: UUID          # Public API - stable forever
    identifier: str   # Human-readable - can change
    title: str
    content: str
    # pk_post NOT exposed - internal only
```

**Querying by Different Identifiers:**

```graphql
# Query by public UUID
query {
  post(id: "550e8400-e29b-41d4-a716-446655440000") {
    title
  }
}

# Query by human-readable identifier
query {
  post(identifier: "my-first-post") {
    title
  }
}

# pk_post is NEVER queryable from GraphQL (security)
```

**Best Practices:**

✅ **Always use trinity pattern** for entities with public APIs
✅ **Never expose pk_*** in GraphQL types (security risk)
✅ **Use id for API contracts** (stable, never changes)
✅ **Use identifier for URLs** (human-friendly, can update)
✅ **Index all three** for query performance:
```sql
CREATE INDEX idx_post_pk ON tb_post(pk_post);        -- Primary key (automatic)
CREATE UNIQUE INDEX idx_post_id ON tb_post(id);      -- API lookups
CREATE UNIQUE INDEX idx_post_identifier ON tb_post(identifier);  -- URL lookups
```

### Hybrid Tables

Tables with separate write and read paths:
- Writes go to normalized tables
- Reads come from denormalized views

See [Hybrid Tables Example](../../examples/hybrid_tables/)

### DataLoader Pattern

Automatic batching to prevent N+1 queries:

```python
from fraiseql import field

@field
def posts(user: User) -> List[Post]:
    """Get posts for user."""
    pass  # Implementation handled by framework
```

## GraphQL Concepts

### Type

Define your data models with trinity identifiers:

```python
import fraiseql
from uuid import UUID

@fraiseql.type(sql_source="v_user")
class User:
    """User type with trinity identifiers."""
    id: UUID          # Public API identifier (always exposed)
    identifier: str   # Human-readable slug (SEO-friendly)
    name: str
    email: str
    # pk_user is NOT exposed (internal only)
```

**Without trinity pattern (simpler entities):**
```python
import fraiseql

@fraiseql.type(sql_source="v_note")
class Note:
    """Simple note without slug."""
    id: int           # Can use simple int if no public API needed
    title: str
    content: str
```

### Query

Read operations:

```python
import fraiseql

async def get_users(info) -> list[User]:
    """Get all users."""
    db = info.context["db"]
    return await db.find(User)
```

### Mutation

Write operations (two patterns supported):

**Simple pattern (function-based):**
```python
import fraiseql

@fraiseql.mutation
async def create_user(info, input: CreateUserInput) -> User:
    """Simple mutation that returns the type directly."""
    db = info.context["db"]
    # Call PostgreSQL function with business logic
    result = await db.call_function("fn_create_user", input.name, input.email)
    return User(**result)
```

**Class-based pattern (with success/failure):**
```python
import fraiseql

@fraiseql.mutation
class CreateUser:
    """Create a new user with explicit success/failure handling."""
    input: CreateUserInput
    success: CreateUserSuccess
    failure: ValidationError

    async def resolve(self, info):
        db = info.context["db"]
        # Call PostgreSQL function - all business logic in database
        result = await db.call_function(
            "fn_create_user",
            self.input.name,
            self.input.email
        )

        # PostgreSQL function returns JSONB with success/error indicator
        if result["success"]:
            return CreateUserSuccess(
                user=User(**result["user"]),
                message=result.get("message", "User created")
            )
        return ValidationError(
            message=result["error"],
            code=result.get("code", "VALIDATION_ERROR")
        )
```

**Corresponding PostgreSQL function:**
```sql
CREATE OR REPLACE FUNCTION fn_create_user(
    p_name TEXT,
    p_email TEXT
) RETURNS JSONB AS $$
DECLARE
    v_user_id UUID;
BEGIN
    -- Validation: Check email format using regex
    -- Pattern: local-part@domain.tld (basic RFC 5322 compliance)
    IF p_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$' THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Invalid email format',
            'code', 'INVALID_EMAIL'
        );
    END IF;

    -- Insert user
    INSERT INTO tb_user (name, email)
    VALUES (p_name, p_email)
    RETURNING id INTO v_user_id;

    -- Audit log
    INSERT INTO audit_log (action, details)
    VALUES ('user_created', jsonb_build_object('user_id', v_user_id));

    -- Return success with user data
    RETURN jsonb_build_object(
        'success', true,
        'user', jsonb_build_object(
            'id', v_user_id,
            'name', p_name,
            'email', p_email
        ),
        'message', 'User created successfully'
    );
END;
$$ LANGUAGE plpgsql;
```

### Connection

Relay-style cursor-based pagination (built-in):

```python
import fraiseql
from fraiseql.types.generic import Connection

@fraiseql.connection(
    node_type=User,
    default_page_size=20,
    max_page_size=100
)
async def users(info, first: int | None = None, after: str | None = None) -> Connection[User]:
    """Get paginated users - pagination handled automatically."""
    # Framework calls db.paginate() automatically
    # Returns Connection with nodes, pageInfo, totalCount
```

**Configuration options:**
- `node_type`: The type being paginated (required)
- `view_name`: Database view (defaults to `v_<function_name>`)
- `default_page_size`: Default results per page (default: 20)
- `max_page_size`: Maximum allowed page size (default: 100)
- `cursor_field`: Field for cursor (default: "id")
- `include_total_count`: Include total count (default: True)

**Returned Connection type includes:**
- `nodes`: List of items (User[])
- `pageInfo`: Pagination info (hasNextPage, hasPreviousPage, startCursor, endCursor)
- `totalCount`: Total number of items (optional)

## Database Concepts

### View

Read-optimized database views that compose JSONB for GraphQL:

**Simple view (without trinity pattern):**
```sql
CREATE VIEW v_note AS
SELECT
    id,
    jsonb_build_object(
        'id', id,
        'title', title,
        'content', content,
        'created_at', created_at
    ) as data
FROM tb_note
WHERE deleted_at IS NULL;
```

**View with trinity identifiers:**
```sql
CREATE VIEW v_user AS
SELECT
    id,  -- For WHERE id = $1 filtering
    jsonb_build_object(
        'id', id,                    -- Public UUID
        'identifier', identifier,    -- Human-readable slug
        'name', name,
        'email', email,
        'created_at', created_at
    ) as data
FROM tb_user
WHERE deleted_at IS NULL;
```

**View that will be referenced by others (includes pk_*):**
```sql
CREATE VIEW v_post AS
SELECT
    id,       -- For WHERE id = $1 filtering
    pk_post,  -- For parent views to JOIN
    jsonb_build_object(
        'id', id,
        'title', title,
        'content', content
    ) as data
FROM tb_post;
```

**Key points:**
- **Always include `id`** as direct column for efficient WHERE filtering
- **Include `pk_*`** only if other views need to JOIN/reference this view
- **Never include `pk_*` in JSONB** data column (internal only)
- `data` column contains complete GraphQL response
- Only fields in JSONB are exposed to GraphQL

### Materialized View

Pre-computed aggregations:

```sql
CREATE MATERIALIZED VIEW user_stats AS
SELECT
    user_id,
    COUNT(*) as post_count,
    MAX(created_at) as last_post_at
FROM posts
GROUP BY user_id;
```

### Index

Performance optimization:

```sql
CREATE INDEX idx_users_email ON users(email);
```

## Performance Concepts

### Query Complexity

Limiting query depth and breadth:

```python
from fraiseql import ComplexityConfig

config = ComplexityConfig(
    max_complexity=1000,
    max_depth=10
)
```

### APQ (Automatic Persisted Queries)

Caching GraphQL queries by hash to reduce bandwidth:

```python
from fraiseql import FraiseQLConfig

# Memory backend (default)
config = FraiseQLConfig(apq_storage_backend="memory")

# PostgreSQL backend (multi-instance coordination)
config = FraiseQLConfig(
    apq_storage_backend="postgresql",
    apq_storage_schema="apq_cache"
)
```

**Benefits:**
- Client sends query hash instead of full query text
- Bandwidth reduction for large queries
- Works with FraiseQL's Rust pipeline for optimal performance

### Rust JSON Pipeline

FraiseQL's exclusive architecture: PostgreSQL → Rust → HTTP

**Traditional frameworks:**
```
PostgreSQL → Rows → ORM → Python objects → JSON serialize → Response
            ╰────────── Python overhead ──────────╯
```

**FraiseQL:**
```
PostgreSQL → JSONB → Rust transform → HTTP Response
            ╰────── 7-10x faster ──────╯
```

**Why Rust?**
- **Compiled performance** - No Python serialization overhead
- **7-10x faster JSON processing** - Rust handles field selection
- **Zero-copy path** - Direct bytes to HTTP response
- **No GIL contention** - Parallel request processing

**Architectural advantage:**
- PostgreSQL composes JSONB once (no N+1 queries)
- Rust selects only requested fields (respects GraphQL query)
- No Python in the hot path (compiled speed for every request)

## Security Concepts

### Explicit Field Exposure (Security by Architecture)

FraiseQL prevents accidental data leaks through explicit JSONB view contracts:

**The ORM security problem:**
```python
# Traditional ORM - ALL columns loaded
class User(Base):
    id = Column(Integer)
    email = Column(String)
    password_hash = Column(String)  # Oops! Sensitive!
    api_key = Column(String)        # Oops! Sensitive!

# Easy to forget excluding fields
# One mistake = data leak
```

**FraiseQL's explicit whitelisting:**
```sql
-- Only safe fields in JSONB view
CREATE VIEW v_user AS
SELECT
    pk_user,
    jsonb_build_object(
        'id', id,
        'email', email
        -- password_hash CANNOT be queried
        -- api_key CANNOT be queried
        -- Impossible to accidentally expose!
    ) as data
FROM tb_user;
```

**Security benefits:**
- ✅ **Whitelist-only** - Only fields in JSONB are accessible
- ✅ **Database-enforced** - PostgreSQL is the security boundary
- ✅ **Two-layer protection** - SQL view + Python type
- ✅ **No accidental exposure** - Can't query fields not in view
- ✅ **Trinity protection** - pk_* never exposed (prevents enumeration)

### Recursion Depth Protection

Views define maximum nesting depth structurally:

```sql
-- View defines max depth (no circular references possible)
CREATE VIEW v_user AS
SELECT
    pk_user,
    jsonb_build_object(
        'id', id,
        'posts', (
            SELECT jsonb_agg(jsonb_build_object(
                'id', p.id,
                'title', p.title
                -- NO 'author' field here
                -- Recursion IMPOSSIBLE
            ))
            FROM tb_post p
            WHERE p.user_id = tb_user.id
            LIMIT 100  -- Array size limit
        )
    ) as data
FROM tb_user;
```

**Protection:**
- ✅ **Fixed depth** - Attackers can't exceed view definition
- ✅ **No middleware needed** - GraphQL schema validates automatically
- ✅ **Array size limits** - LIMIT clauses prevent huge responses
- ✅ **One query** - No N+1 bomb attacks possible

### Field-Level Authorization

Control access at the field level:

```python
import fraiseql

@fraiseql.field
@fraiseql.authorized(roles=["admin"])
def sensitive_field(user: User, info) -> str:
    """Only admins can access this field."""
    return user.sensitive_data
```

### Rate Limiting

Prevent abuse:

```python
from fraiseql.auth import RateLimitConfig

rate_limit = RateLimitConfig(
    requests_per_minute=100
)
```

### Introspection Control

Disable schema introspection in production:

```python
config = FraiseQLConfig(
    introspection_enabled=False
)
```

## Related

- [Core Documentation](README.md)
- [Examples](../../examples/)
- [API Reference](../reference/)
