<!-- Skip to main content -->
---

title: Schema Conventions Specification
description: FraiseQL enforces opinionated PostgreSQL schema conventions that enable automatic compilation, efficient filtering, and optimal performance. These conventions a
keywords: ["format", "compliance", "schema", "protocol", "specification", "standard"]
tags: ["documentation", "reference"]
---

# Schema Conventions Specification

**Version:** 1.0
**Status:** Draft
**Audience:** Database architects, schema designers, DBAs

---

## 1. Overview

FraiseQL enforces opinionated PostgreSQL schema conventions that enable automatic compilation, efficient filtering, and optimal performance. These conventions are **mandatory** for FraiseQL to function.

**Core principle:** The database schema is the source of truth. The authoring layer declares which views to expose as GraphQL types.

---

## 2. Naming Conventions

### 2.1 Table Naming

| Pattern | Purpose | Example | Notes |
|---------|---------|---------|-------|
| `tb_{entity}` | Write table (normalized) | `tb_user`, `tb_post`, `tb_order_item` | Singular entity name |
| `tb_{entity}_relationship` | Junction/bridge tables | `tb_user_role`, `tb_product_tag` | For many-to-many |

**Rules:**

- Must be lowercase
- Must use snake_case
- No abbreviations (use `tb_customer`, not `tb_cust`)
- Entity name should be singular
- Table exists only if there's a write model for the entity

### 2.2 View Naming

| Pattern | Purpose | Example |
|---------|---------|---------|
| `v_{entity}` | Base projection (JSON plane) | `v_user`, `v_post` |
| `v_{entities}_by_{parent}` | Pre-aggregated composition | `v_posts_by_user`, `v_order_items_by_order` |
| `tv_{entity}` | Table-backed view (JSON plane) | `tv_user_summary` |
| `mv_{entity}` | Materialized view (cached) | `mv_user_stats` |
| `va_{entity}` | Logical view (Arrow plane) | `va_user`, `va_post` |
| `ta_{entity}` | Table-backed view (Arrow plane) | `ta_user`, `ta_orders` |

**Rules:**

- Base views MUST produce a `data` JSONB column
- Pre-aggregated views group by foreign key
- Arrow views are flat, single-level only
- View names must be lowercase snake_case

**When to use each pattern:**

See [View Selection Guide](../architecture/database/view-selection-guide.md) for detailed decision trees:

- `v_*` vs `tv_*`: Logical vs table-backed for JSON/GraphQL queries
- `va_*` vs `ta_*`: Logical vs table-backed for Arrow/Analytics queries

**Quick decision:**

- Simple queries → `v_*` (JSON) or `va_*` (Arrow)
- Complex queries with 3+ JOINs → `tv_*` (JSON)
- Large datasets (>1M rows) → `ta_*` (Arrow)

### 2.3 Function Naming (Stored Procedures)

| Pattern | Purpose | Example |
|---------|---------|---------|
| `fn_{action}_{entity}` | Write function (mutation) | `fn_create_user`, `fn_update_post`, `fn_delete_order` |
| `fn_{verb}_{entity}_{detail}` | Complex operations | `fn_archive_user_posts`, `fn_transfer_order_items` |

**Rules:**

- Must be lowercase snake_case
- Action verbs: `create`, `update`, `delete`, `upsert`, `archive`, etc.
- Function must return JSON with result data
- Function is transaction-safe

### 2.4 Constraint Naming

| Type | Pattern | Example |
|------|---------|---------|
| Primary Key | `{table}_pkey` | `tb_user_pkey` (PostgreSQL default) |
| Foreign Key | `fk_{table}_{referenced_table}` | `fk_post_user` |
| Unique | `{table}_{columns}_key` | `tb_user_email_key` |
| Check | `ck_{table}_{condition}` | `ck_order_amount_positive` |
| Index | `idx_{table}_{columns}` | `idx_post_created_at` |

---

## 3. Column Conventions

### 3.1 Primary & Foreign Keys

```sql
<!-- Code example in SQL -->
-- Write table (tb_*)
CREATE TABLE tb_user (
    pk_user BIGINTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    identifier TEXT NOT NULL UNIQUE,
    ...
);

-- Related write table
CREATE TABLE tb_post (
    pk_post INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    fk_user BIGINTEGER NOT NULL REFERENCES tb_user(pk_user),
    ...
);
```text
<!-- Code example in TEXT -->

**Rules:**

- Primary key: `pk_{entity}` (INTEGER, auto-generated)
- Foreign key: `fk_{entity}` (INTEGER, NOT NULL, references pk_*)
- Public ID: `id` (UUID, exposed via GraphQL)
- Surrogate key: `identifier` (TEXT, human-readable, indexed)

**Why this dual-key strategy?**

| Key | Type | Purpose | Index |
|-----|------|---------|-------|
| `pk_user` | INT | Internal joins, max performance | PRIMARY KEY |
| `id` | UUID | External references, federation | UNIQUE |
| `identifier` | TEXT | Human-readable URLs | UNIQUE |

### 3.2 Filterable Foreign Keys in Views

```sql
<!-- Code example in SQL -->
-- View includes native FK columns for efficient filtering
CREATE VIEW v_post AS
SELECT
    pk_post,
    fk_user,
    id,
    identifier,
    (SELECT id FROM tb_user WHERE pk_user = fk_user) AS user_id,
    jsonb_build_object(
        'id', id,
        'title', title,
        'userId', (SELECT id FROM tb_user WHERE pk_user = fk_user),
        'createdAt', created_at
    ) AS data
FROM tb_post
WHERE deleted_at IS NULL;

-- Index the foreign key column for fast filtering
CREATE INDEX idx_v_post_user_id ON v_post(user_id);
```text
<!-- Code example in TEXT -->

**Rules:**

- Related views expose `{parent}_id` as native column
- This column is UUID (matches public `id`)
- Always indexed for fast filtering
- Appears in both `data` JSONB and as native column

### 3.3 Deep Path Filter Columns

For frequently-filtered nested paths, add denormalized columns:

```sql
<!-- Code example in SQL -->
CREATE VIEW v_order AS
SELECT
    pk_order,
    id,
    identifier,

    -- Direct relationships
    user_id,

    -- Deep paths (denormalized for filtering)
    items__product__category_id,
    items__product__vendor_id,
    items__product__tag_ids,

    jsonb_build_object(...) AS data
FROM ...
LEFT JOIN LATERAL (
    SELECT
        array_agg(DISTINCT c.id) AS items__product__category_id,
        array_agg(DISTINCT v.id) AS items__product__vendor_id,
        array_agg(DISTINCT t.id) AS items__product__tag_ids
    FROM tb_order_item oi
    JOIN tb_product p ON p.pk_product = oi.fk_product
    LEFT JOIN tb_category c ON c.pk_category = p.fk_category
    LEFT JOIN tb_vendor v ON v.pk_vendor = p.fk_vendor
    LEFT JOIN tb_product_tag pt ON pt.fk_product = p.pk_product
    LEFT JOIN tb_tag t ON t.pk_tag = pt.fk_tag
    WHERE oi.fk_order = o.pk_order
) paths ON true;

-- Index each path column
CREATE INDEX idx_v_order_items__product__category_id
  ON v_order USING GIN(items__product__category_id);
```text
<!-- Code example in TEXT -->

**Rules:**

- Column name = GraphQL filter path with `__` separators
- Singular relationships: UUID type
- Array relationships: UUID[] type
- Must be indexed (B-tree for UUID, GIN for UUID[])
- Compiler introspects these columns automatically

### 3.4 Audit Columns

All tables MUST include audit columns:

```sql
<!-- Code example in SQL -->
CREATE TABLE tb_user (
    pk_user BIGINTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    id UUID NOT NULL UNIQUE DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,

    -- Audit columns
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by INTEGER REFERENCES tb_user(pk_user),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER REFERENCES tb_user(pk_user),
    deleted_at TIMESTAMPTZ,
    deleted_by INTEGER REFERENCES tb_user(pk_user),

    CHECK (updated_at >= created_at),
    CHECK (deleted_at >= created_at)
);

-- Trigger to update updated_at
CREATE TRIGGER trigger_tb_user_updated_at
BEFORE UPDATE ON tb_user
FOR EACH ROW
EXECUTE FUNCTION update_timestamp();
```text
<!-- Code example in TEXT -->

**Rules:**

- `created_at`: TIMESTAMPTZ, NOT NULL, default CURRENT_TIMESTAMP
- `created_by`: INTEGER FK to user (nullable if system creates it)
- `updated_at`: TIMESTAMPTZ, NOT NULL, updated by trigger
- `updated_by`: INTEGER FK to user
- `deleted_at`: TIMESTAMPTZ, NULL if active (soft delete)
- `deleted_by`: INTEGER FK to user
- Add CHECK constraints to prevent invalid timestamps

**Usage:**

- Views filter on `WHERE deleted_at IS NULL` for soft delete
- Cache invalidation uses `updated_at` as signal
- CDC events use audit columns for timestamps

### 3.5 Projection Data Column

All views MUST include a `data` JSONB column:

```sql
<!-- Code example in SQL -->
CREATE VIEW v_user AS
SELECT
    pk_user,
    id,
    identifier,
    jsonb_build_object(
        'id', id,
        'identifier', identifier,
        'email', email,
        'name', name,
        'createdAt', created_at,
        'updatedAt', updated_at
    ) AS data
FROM tb_user
WHERE deleted_at IS NULL;
```text
<!-- Code example in TEXT -->

**Rules:**

- Column must be named `data`
- Type: JSONB
- Contains fully-formed projection in GraphQL field case
- Must be at the END of SELECT (last column)
- Never null (use `{}` for empty objects, `[]` for empty arrays)

**Field naming in JSONB:**

- Convert snake_case to camelCase
- `created_at` → `createdAt`
- `user_id` → `userId`
- Avoid nested objects; flatten or use pre-aggregated views

### 3.6 Reserved Column Names

These columns are reserved by FraiseQL and MUST NOT be used elsewhere:

```text
<!-- Code example in TEXT -->
pk_*         — Primary key (internal only)
fk_*         — Foreign key (internal only)
id           — Public identifier (UUID)
identifier   — Human-readable slug
*_id         — Filterable FK in views (UUID or UUID[])
*__*         — Deep path columns (path separators)
data         — Projection JSONB
created_at   — Audit column
created_by   — Audit column
updated_at   — Audit column
updated_by   — Audit column
deleted_at   — Audit column (soft delete)
deleted_by   — Audit column
```text
<!-- Code example in TEXT -->

---

## 4. View Patterns

### 4.1 Base Entity View

```sql
<!-- Code example in SQL -->
CREATE VIEW v_user AS
SELECT
    pk_user,                              -- Internal key
    id,                                   -- Public ID
    identifier,                           -- Slug
    jsonb_build_object(                   -- Projection
        'id', id,
        'identifier', identifier,
        'email', email,
        'name', name,
        'createdAt', created_at
    ) AS data
FROM tb_user
WHERE deleted_at IS NULL;                 -- Soft delete
```text
<!-- Code example in TEXT -->

**Must include:**

- `pk_*` for internal reference
- `id` for public identity
- `identifier` for URLs
- `data` JSONB with camelCase fields
- Soft delete filter

### 4.2 Related Entity View with Foreign Key

```sql
<!-- Code example in SQL -->
CREATE VIEW v_post AS
SELECT
    pk_post,
    fk_user,
    id,
    identifier,
    (SELECT id FROM tb_user WHERE pk_user = fk_user) AS user_id,
    jsonb_build_object(
        'id', id,
        'identifier', identifier,
        'title', title,
        'userId', (SELECT id FROM tb_user WHERE pk_user = fk_user),
        'createdAt', created_at
    ) AS data
FROM tb_post
WHERE deleted_at IS NULL;

-- Index the FK column for filtering
CREATE INDEX idx_v_post_user_id ON v_post(user_id);
```text
<!-- Code example in TEXT -->

**Must include:**

- Native `{parent}_id` column for filtering
- Index on FK columns
- FK value in `data` JSONB for clients

### 4.3 Pre-aggregated Composition View

```sql
<!-- Code example in SQL -->
-- Group related entities by parent key
CREATE VIEW v_posts_by_user AS
SELECT
    fk_user,
    jsonb_agg(data ORDER BY created_at DESC) AS posts
FROM v_post
GROUP BY fk_user;

-- Composition view joins base + pre-aggregated
CREATE VIEW v_user_with_posts AS
SELECT
    u.pk_user,
    u.id,
    u.identifier,
    u.data || jsonb_build_object(
        'posts', COALESCE(p.posts, '[]'::jsonb)
    ) AS data
FROM v_user u
LEFT JOIN v_posts_by_user p ON p.fk_user = u.pk_user;
```text
<!-- Code example in TEXT -->

**Rules:**

- Pre-aggregated views are NOT exposed directly to GraphQL
- Used only for efficient composition
- Join on internal `fk_*` columns
- Compose using JSONB merge (`||`)

### 4.3.1 Analytical Fact Tables

For analytical workloads, FraiseQL supports **fact tables** with the `tf_` prefix:

**Fact tables** (`tf_*`):

- Transactional/event data at any granularity
- Measures: SQL columns (numeric types for fast aggregation)
- Dimensions: JSONB `dimensions` column (flexible grouping)
- Denormalized filters: Indexed SQL columns (customer_id, occurred_at)
- Pre-aggregated versions use descriptive suffixes: `tf_sales_daily`, `tf_events_monthly`

**Dimension tables** (`td_*`):

- Reference data used at ETL time to denormalize into fact tables
- Never joined at query time (FraiseQL does not support joins)
- Managed by DBA/data team

**Example:**

```sql
<!-- Code example in SQL -->
-- Fact table: Raw sales transactions (finest granularity)
CREATE TABLE tf_sales (
    id BIGSERIAL PRIMARY KEY,
    -- Measures (SQL columns for fast aggregation)
    revenue DECIMAL(10,2) NOT NULL,
    quantity INT NOT NULL,
    -- Dimensions (JSONB for flexible GROUP BY)
    dimensions JSONB NOT NULL,
    -- Denormalized filters (indexed for fast WHERE)
    customer_id UUID NOT NULL,
    occurred_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_sales_customer ON tf_sales(customer_id);
CREATE INDEX idx_sales_occurred ON tf_sales(occurred_at);
CREATE INDEX idx_sales_dimensions_gin ON tf_sales USING GIN(dimensions);

-- Pre-aggregated fact table: Daily granularity (same structure, different granularity)
CREATE TABLE tf_sales_daily (
    id BIGSERIAL PRIMARY KEY,
    day DATE NOT NULL UNIQUE,
    -- Pre-aggregated measures
    revenue DECIMAL(10,2) NOT NULL,      -- SUM(revenue)
    quantity INT NOT NULL,               -- SUM(quantity)
    transaction_count INT NOT NULL,      -- COUNT(*)
    -- Dimensions (can still group within daily aggregates)
    dimensions JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_sales_daily_day ON tf_sales_daily(day);
CREATE INDEX idx_sales_daily_dimensions_gin ON tf_sales_daily USING GIN(dimensions);

-- Dimension table: Product catalog (for ETL denormalization)
CREATE TABLE td_products (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    category VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ETL process denormalizes td_products into tf_sales.dimensions
-- Example: dimensions->>'product_name', dimensions->>'product_category'
```text
<!-- Code example in TEXT -->

**Key architectural principle**: FraiseQL does NOT support joins. All dimensional data must be denormalized into the `dimensions` JSONB column at ETL time. The DBA/data team manages ETL pipelines; FraiseQL provides the GraphQL query interface.

**Related documentation**: See `docs/specs/analytical-schema-conventions.md` for complete analytical naming conventions, and `docs/architecture/analytics/fact-dimension-pattern.md` for detailed patterns.

### 4.4 Arrow Plane View (Flat, Single-Level)

```sql
<!-- Code example in SQL -->
CREATE VIEW av_user AS
SELECT
    pk_user,
    id,
    identifier,
    email,
    name,
    created_at,
    updated_at
FROM tb_user
WHERE deleted_at IS NULL;

CREATE VIEW av_post AS
SELECT
    pk_post,
    fk_user,
    id,
    identifier,
    (SELECT id FROM tb_user WHERE pk_user = fk_user) AS user_id,
    title,
    content,
    created_at
FROM tb_post
WHERE deleted_at IS NULL;
```text
<!-- Code example in TEXT -->

**Rules:**

- Single level only (no nesting)
- Each entity = separate Arrow batch
- FK columns included for client-side joins
- Columnar, not JSONB
- Suitable for analytics/BI tools

---

## 5. Stored Procedures (Mutations)

### 5.1 Mutation Response Contract

All stored procedures (mutations) MUST return a standardized JSON response matching this structure:

```json
<!-- Code example in JSON -->
{
  "status": "success|error|noop",
  "message": "Human-readable message",
  "entity_id": "uuid-string",
  "entity_type": "User",
  "entity": {
    "id": "uuid",
    "identifier": "slug",
    "name": "...",
    "email": "..."
  },
  "updated_fields": ["field1", "field2"],
  "cascade": {
    "updated": [
      {
        "__typename": "User",
        "id": "uuid",
        "operation": "CREATED|UPDATED",
        "entity": { ... }
      }
    ],
    "deleted": [
      {
        "__typename": "User",
        "id": "uuid",
        "operation": "DELETED"
      }
    ],
    "invalidations": [
      {
        "query_name": "users",
        "strategy": "INVALIDATE|REPLACE|APPEND",
        "scope": "PREFIX|EXACT|SUFFIX"
      }
    ],
    "metadata": {
      "timestamp": "2026-01-11T...",
      "transaction_id": "txid",
      "depth": 1,
      "affected_count": 1
    }
  },
  "metadata": {
    "trigger": "api_create|api_update|api_delete",
    "reason": "entity_created|entity_updated|conflict|not_found",
    "input_payload": { ... }
  }
}
```text
<!-- Code example in TEXT -->

**Response fields (all required):**

| Field | Type | Description |
|-------|------|-------------|
| `status` | TEXT | `success`, `error`, or `noop` |
| `message` | TEXT | Human-readable message for client |
| `entity_id` | TEXT | UUID of affected entity |
| `entity_type` | TEXT | Entity type name (e.g., "User") |
| `entity` | JSONB | The mutated entity (full view data) |
| `updated_fields` | ARRAY | Fields that were actually changed |
| `cascade` | JSONB | Cache invalidation + cascaded updates |
| `metadata` | JSONB | Operation metadata and input |

**Cascade structure:**

| Key | Type | Description |
|-----|------|-------------|
| `updated` | ARRAY | Entities that were created/updated with `operation` and `__typename` |
| `deleted` | ARRAY | Entities that were deleted |
| `invalidations` | ARRAY | Cache keys to invalidate with strategy |
| `metadata` | OBJECT | Timestamp, transaction_id, depth, affected_count |

**Status values:**

| Status | Meaning |
|--------|---------|
| `success` | Mutation completed successfully |
| `error` | Mutation failed (validation, constraint, etc.) |
| `noop` | No changes applied (idempotent, already exists, etc.) |

**Note:** The mutation response above is the **public-facing API response**. Internally, all mutations are also logged to `tb_entity_change_log` with a full Debezium envelope for complete audit trails. See **section 6: Mutation Logging & Audit Tables** for details. This enables:

- Complete audit trail of all entity writes
- CDC event emission for real-time systems
- Observability and performance monitoring
- Error diagnostics and debugging
- Multi-source mutation tracking (GraphQL, batch imports, ETL, direct SQL)

### 5.2 Basic Create Function (PostgreSQL)

```sql
<!-- Code example in SQL -->
CREATE FUNCTION fn_create_user(
    tenant_id UUID,
    user_id UUID,
    payload JSONB
)
RETURNS TEXT  -- Returns JSON response (portable format)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_new_id UUID := gen_random_uuid();
    v_entity JSONB;
    v_response JSONB;
BEGIN
    -- Insert new user
    INSERT INTO tb_user (id, email, name, created_by)
    VALUES (
        v_new_id,
        payload->>'email',
        payload->>'name',
        user_id
    );

    -- Fetch full projection
    SELECT data INTO v_entity
    FROM v_user
    WHERE id = v_new_id;

    -- Build response
    v_response := jsonb_build_object(
        'status', 'success',
        'message', 'User created successfully',
        'entity_id', v_new_id::text,
        'entity_type', 'User',
        'entity', v_entity,
        'updated_fields', ARRAY['email', 'name'],
        'cascade', jsonb_build_object(
            'updated', jsonb_build_array(
                jsonb_build_object(
                    '__typename', 'User',
                    'id', v_new_id::text,
                    'operation', 'CREATED',
                    'entity', v_entity
                )
            ),
            'invalidations', jsonb_build_array(
                jsonb_build_object(
                    'query_name', 'users',
                    'strategy', 'INVALIDATE',
                    'scope', 'PREFIX'
                )
            ),
            'metadata', jsonb_build_object(
                'timestamp', NOW()::text,
                'depth', 1,
                'affected_count', 1
            )
        ),
        'metadata', jsonb_build_object(
            'trigger', 'api_create',
            'reason', 'entity_created',
            'input_payload', payload
        )
    );

    RETURN v_response::TEXT;
EXCEPTION WHEN OTHERS THEN
    v_response := jsonb_build_object(
        'status', 'error',
        'message', SQLERRM,
        'entity_id', NULL,
        'entity_type', 'User',
        'entity', NULL,
        'updated_fields', ARRAY[]::TEXT[],
        'cascade', NULL,
        'metadata', jsonb_build_object(
            'trigger', 'api_create',
            'reason', 'error',
            'input_payload', payload
        )
    );
    RETURN v_response::TEXT;
END;
$$;
```text
<!-- Code example in TEXT -->

**Rules:**

- Function name: `fn_{action}_{entity}`
- Parameters: `tenant_id UUID`, `user_id UUID` (from auth context), `payload JSONB` (input)
- Return type: **TEXT** (JSON serialized, portable across databases)
- Must handle errors with try-catch, return error status
- Entity must be full projection from view
- Cascade field is REQUIRED (even if empty for simple mutations)

### 5.3 Update Function with Audit

```sql
<!-- Code example in SQL -->
CREATE FUNCTION fn_update_user(
    tenant_id UUID,
    user_id UUID,
    payload JSONB
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_id UUID := (payload->>'id')::UUID;
    v_entity JSONB;
    v_before JSONB;
    v_updated_fields TEXT[];
    v_response JSONB;
BEGIN
    -- Fetch BEFORE snapshot
    SELECT data INTO v_before FROM v_user WHERE id = v_id;
    IF v_before IS NULL THEN
        RETURN jsonb_build_object(
            'status', 'noop',
            'message', 'User not found',
            'entity_id', v_id::text,
            'entity_type', 'User',
            'entity', NULL,
            'updated_fields', ARRAY[]::TEXT[],
            'cascade', NULL,
            'metadata', jsonb_build_object('trigger', 'api_update', 'reason', 'not_found')
        )::TEXT;
    END IF;

    -- Update fields conditionally
    UPDATE tb_user
    SET
        name = COALESCE(payload->>'name', name),
        updated_by = user_id,
        updated_at = NOW()
    WHERE id = v_id;

    -- Track which fields actually changed
    v_updated_fields := ARRAY(
        SELECT key FROM jsonb_each_text(payload)
        WHERE key != 'id'
    );

    -- Fetch AFTER snapshot
    SELECT data INTO v_entity FROM v_user WHERE id = v_id;

    -- Build response
    v_response := jsonb_build_object(
        'status', 'success',
        'message', 'User updated successfully',
        'entity_id', v_id::text,
        'entity_type', 'User',
        'entity', v_entity,
        'updated_fields', v_updated_fields,
        'cascade', jsonb_build_object(
            'updated', jsonb_build_array(
                jsonb_build_object(
                    '__typename', 'User',
                    'id', v_id::text,
                    'operation', 'UPDATED',
                    'entity', v_entity
                )
            ),
            'invalidations', jsonb_build_array(
                jsonb_build_object(
                    'query_name', 'users',
                    'strategy', 'INVALIDATE',
                    'scope', 'PREFIX'
                )
            ),
            'metadata', jsonb_build_object(
                'timestamp', NOW()::text,
                'depth', 1,
                'affected_count', 1
            )
        ),
        'metadata', jsonb_build_object(
            'trigger', 'api_update',
            'reason', 'entity_updated',
            'input_payload', payload
        )
    );

    RETURN v_response::TEXT;
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'status', 'error',
        'message', SQLERRM,
        'entity_id', v_id::text,
        'entity_type', 'User',
        'entity', NULL,
        'updated_fields', ARRAY[]::TEXT[],
        'cascade', NULL,
        'metadata', jsonb_build_object('trigger', 'api_update', 'reason', 'error')
    )::TEXT;
END;
$$;
```text
<!-- Code example in TEXT -->

**Rules:**

- Extract entity ID from payload
- Fetch BEFORE snapshot for comparison
- Update only fields present in payload
- Track which fields actually changed
- Fetch AFTER snapshot
- Include both snapshots in cascade
- Always return standard response format

### 5.4 Delete Function (Soft Delete)

```sql
<!-- Code example in SQL -->
CREATE FUNCTION fn_delete_user(
    tenant_id UUID,
    user_id UUID,
    payload JSONB
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_id UUID := (payload->>'id')::UUID;
    v_response JSONB;
BEGIN
    UPDATE tb_user
    SET
        deleted_at = NOW(),
        deleted_by = user_id
    WHERE id = v_id AND deleted_at IS NULL;

    IF NOT FOUND THEN
        v_response := jsonb_build_object(
            'status', 'noop',
            'message', 'User already deleted or not found',
            'entity_id', v_id::text,
            'entity_type', 'User',
            'entity', NULL,
            'updated_fields', ARRAY[]::TEXT[],
            'cascade', jsonb_build_object(
                'deleted', jsonb_build_array(
                    jsonb_build_object(
                        '__typename', 'User',
                        'id', v_id::text,
                        'operation', 'DELETED'
                    )
                )
            ),
            'metadata', jsonb_build_object('trigger', 'api_delete', 'reason', 'not_found')
        );
    ELSE
        v_response := jsonb_build_object(
            'status', 'success',
            'message', 'User deleted successfully',
            'entity_id', v_id::text,
            'entity_type', 'User',
            'entity', NULL,
            'updated_fields', ARRAY['deleted_at', 'deleted_by'],
            'cascade', jsonb_build_object(
                'deleted', jsonb_build_array(
                    jsonb_build_object(
                        '__typename', 'User',
                        'id', v_id::text,
                        'operation', 'DELETED'
                    )
                ),
                'invalidations', jsonb_build_array(
                    jsonb_build_object(
                        'query_name', 'users',
                        'strategy', 'INVALIDATE',
                        'scope', 'PREFIX'
                    )
                )
            ),
            'metadata', jsonb_build_object('trigger', 'api_delete', 'reason', 'entity_deleted')
        );
    END IF;

    RETURN v_response::TEXT;
EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'status', 'error',
        'message', SQLERRM,
        'entity_id', v_id::text,
        'entity_type', 'User',
        'entity', NULL,
        'updated_fields', ARRAY[]::TEXT[],
        'cascade', NULL,
        'metadata', jsonb_build_object('trigger', 'api_delete', 'reason', 'error')
    )::TEXT;
END;
$$;
```text
<!-- Code example in TEXT -->

**Rules:**

- Soft delete: set `deleted_at` and `deleted_by`
- Never hard-delete from `tb_*`
- Use `deleted` array in cascade (no `updated`)
- Deleted entities have no entity data
- Return `operation: DELETED` in cascade

### 5.5 Database-Specific Optimizations (Optional)

This spec defines the **response contract** that all databases must follow.

**PostgreSQL can further optimize:**

- See: `docs/specs/stored-procedures-postgresql.md`
- Use composite types for efficiency
- Two-layer architecture (app.*wrapper → core.* implementation)
- Built-in mutation logging and CDC
- Industry-standard stored procedure patterns

**Other databases:**

- SQLite: See `docs/specs/stored-procedures-sqlite.md`
- MySQL: See `docs/specs/stored-procedures-mysql.md`
- Each maintains the JSON response contract above

---

## 6. Mutation Logging & Audit Tables

### 6.1 Entity Change Log Table

The `tb_entity_change_log` table provides a **centralized, source-agnostic audit log** for all entity writes across the system, whether from GraphQL mutations, batch imports, ETL processes, direct SQL, or any other source.

```sql
<!-- Code example in SQL -->
CREATE TABLE core.tb_entity_change_log (
    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    pk_entity_change_log UUID NOT NULL DEFAULT gen_random_uuid(),

    fk_customer_org UUID NOT NULL,      -- Multi-tenant isolation
    fk_contact UUID,                     -- User ID who made the change (nullable)

    object_type TEXT NOT NULL,           -- Entity type (User, Post, Order, etc.)
    object_id UUID NOT NULL,             -- Entity UUID being modified

    modification_type TEXT NOT NULL CHECK (
        modification_type IN ('INSERT', 'UPDATE', 'DELETE', 'NOOP')
    ),

    change_status TEXT NOT NULL CHECK (
        change_status ~ '^(new|existing|updated|deleted|synced|completed|ok|done|success|failed:[a-z_]+|noop:[a-z_]+|conflict:[a-z_]+|duplicate:[a-z_]+|validation:[a-z_]+|not_found|forbidden|unauthorized|blocked:[a-z_]+)$'
    ),

    object_data JSONB NOT NULL,          -- Debezium envelope (see 6.2)
    extra_metadata JSONB DEFAULT '{}'::jsonb,

    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_entity_log_object ON core.tb_entity_change_log (object_type, object_id);
CREATE INDEX idx_entity_log_org ON core.tb_entity_change_log (fk_customer_org, created_at);
CREATE INDEX idx_entity_log_status ON core.tb_entity_change_log (change_status);
```text
<!-- Code example in TEXT -->

**Purpose:**

- Centralized audit log for all entity writes (GraphQL mutations, batch imports, ETL, direct SQL, triggers, etc.)
- Source of truth for observability and debugging
- Enables CDC event emission for real-time systems
- Powers admin timelines, analytics, and compliance audits
- **Source-agnostic:** Tracks any write operation regardless of origin

### 6.2 Debezium Envelope Format

The `object_data` JSONB column contains a **Debezium-style change envelope** for compatibility with CDC systems:

```json
<!-- Code example in JSON -->
{
  "before": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "old@example.com",
    "updated_at": "2026-01-11T14:00:00Z"
  },
  "after": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "new@example.com",
    "updated_at": "2026-01-11T15:00:00Z"
  },
  "op": "u",
  "source": {
    "table": "tb_user",
    "schema": "public",
    "db": "production",
    "organization": "550e8400-e29b-41d4-a716-446655440001",
    "ts_ms": 1704067200000
  }
}
```text
<!-- Code example in TEXT -->

**Operation Codes:**

- `"c"` — Create (INSERT)
- `"u"` — Update (UPDATE)
- `"d"` — Delete (DELETE)
- `"r"` — Read/Noop (NOOP, no change)

**Field Semantics:**

- `before` — Entity state before modification (null for INSERT)
- `after` — Entity state after modification (null for DELETE)
- `op` — Database operation code
- `source` — Metadata about the change source (table, schema, organization, timestamp)

### 6.3 Status Taxonomy

The `change_status` field uses **structured, machine-readable status codes** for pattern matching and aggregation:

| Category | Pattern | Examples | Use Case |
|----------|---------|----------|----------|
| Success | Plain word | `new`, `existing`, `updated`, `deleted`, `synced`, `completed`, `success` | Operation succeeded |
| Error | `failed:{reason}` | `failed:not_found`, `failed:validation`, `failed:constraint` | Operation failed |
| Conflict | `conflict:{reason}` | `conflict:already_exists`, `conflict:duplicate_email` | Data conflict detected |
| Validation | `validation:{reason}` | `validation:invalid_format`, `validation:missing_field` | Validation error |
| No-op | `noop:{reason}` | `noop:unchanged`, `noop:already_synced`, `noop:duplicate` | No change made |
| Blocked | `blocked:{reason}` | `blocked:permission_denied`, `blocked:rate_limit` | Operation prevented |

### 6.4 Helper Functions

**log_mutation_event()** — Writes change to `tb_entity_change_log`

```sql
<!-- Code example in SQL -->
CREATE OR REPLACE FUNCTION log_mutation_event(
    input_fk_customer_org UUID,
    input_fk_contact UUID,
    input_object_type TEXT,
    input_object_id UUID,
    input_modification_type TEXT,
    input_change_status TEXT,
    input_payload_before JSONB DEFAULT NULL,
    input_payload_after JSONB DEFAULT NULL,
    input_source_table TEXT DEFAULT NULL,
    input_source_schema TEXT DEFAULT 'public',
    input_extra_metadata JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID
LANGUAGE plpgsql
AS $$
BEGIN
    -- Builds Debezium envelope and inserts into change log
    -- Returns pk_entity_change_log for tracing
    ...
END;
$$;
```text
<!-- Code example in TEXT -->

**build_mutation_response()** — Constructs mutation response without logging

```sql
<!-- Code example in SQL -->
CREATE OR REPLACE FUNCTION core.build_mutation_response(
    input_change_status TEXT,
    input_message TEXT,
    input_entity_id UUID,
    input_entity_type TEXT,
    input_custom_entity JSONB,
    input_fields TEXT[] DEFAULT ARRAY[]::TEXT[],
    input_cascade_data JSONB DEFAULT NULL,
    input_extra_metadata JSONB DEFAULT '{}'::JSONB
)
RETURNS app.mutation_response
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
    -- Pure function: builds and returns mutation_response type
    -- No side effects; safe to call multiple times
    RETURN (
        input_change_status,
        input_message,
        input_entity_id::TEXT,
        input_entity_type,
        input_custom_entity,
        input_fields,
        input_cascade_data,
        input_extra_metadata
    )::app.mutation_response;
END;
$$;
```text
<!-- Code example in TEXT -->

**log_and_return_mutation()** — Combined helper (logs + returns response)

```sql
<!-- Code example in SQL -->
CREATE OR REPLACE FUNCTION core.log_and_return_mutation(
    input_tenant_id UUID,
    input_user_id UUID,
    input_entity_type TEXT,
    input_entity_id UUID,
    input_modification_type TEXT,
    input_change_status TEXT,
    input_fields TEXT[],
    input_message TEXT,
    input_payload_before JSONB DEFAULT NULL,
    input_payload_after JSONB DEFAULT NULL,
    input_cascade_data JSONB DEFAULT NULL,
    input_extra_metadata JSONB DEFAULT '{}'::JSONB
)
RETURNS app.mutation_response
LANGUAGE plpgsql
AS $$
BEGIN
    -- Step 1: Log the mutation (side effect)
    PERFORM log_mutation_event(
        input_tenant_id,
        input_user_id,
        input_entity_type,
        input_entity_id,
        input_modification_type,
        input_change_status,
        input_payload_before,
        input_payload_after,
        input_entity_type,
        'public',
        input_extra_metadata
    );

    -- Step 2: Build and return response (pure function)
    RETURN core.build_mutation_response(
        input_change_status,
        input_message,
        input_entity_id,
        input_entity_type,
        COALESCE(input_payload_after, input_payload_before),
        input_fields,
        input_cascade_data,
        input_extra_metadata
    );
END;
$$;
```text
<!-- Code example in TEXT -->

### 6.5 Usage Patterns

**Standard mutation with automatic logging:**

```sql
<!-- Code example in SQL -->
CREATE OR REPLACE FUNCTION fn_create_user(
    input_tenant_id UUID,
    input_user_id UUID,
    input_email TEXT,
    input_name TEXT
)
RETURNS app.mutation_response
LANGUAGE plpgsql
AS $$
DECLARE
    v_new_user_id UUID;
    v_before JSONB := NULL;
    v_after JSONB;
BEGIN
    -- Create user
    INSERT INTO tb_user (email, name)
    VALUES (input_email, input_name)
    RETURNING id INTO v_new_user_id;

    -- Fetch created state
    SELECT jsonb_build_object(
        'id', id,
        'email', email,
        'name', name,
        'createdAt', created_at
    ) INTO v_after
    FROM tb_user WHERE id = v_new_user_id;

    -- Log and return
    RETURN core.log_and_return_mutation(
        input_tenant_id,
        input_user_id,
        'User',
        v_new_user_id,
        'INSERT',
        'new',
        ARRAY['id', 'email', 'name', 'createdAt'],
        'User created successfully',
        v_before,
        v_after,
        NULL,
        jsonb_build_object('trigger', 'api_create')
    );
END;
$$;
```text
<!-- Code example in TEXT -->

**Custom error response:**

```sql
<!-- Code example in SQL -->
-- Check for conflict
IF EXISTS (SELECT 1 FROM tb_user WHERE email = input_email) THEN
    PERFORM log_mutation_event(
        input_tenant_id,
        input_user_id,
        'User',
        '00000000-0000-0000-0000-000000000000',
        'NOOP',
        'conflict:already_exists',
        NULL,
        jsonb_build_object('email', input_email),
        'tb_user',
        'public',
        jsonb_build_object('attempted_email', input_email)
    );

    RETURN core.build_mutation_response(
        'conflict:already_exists',
        'User with this email already exists',
        '00000000-0000-0000-0000-000000000000',
        'User',
        jsonb_build_object('email', input_email, 'error', 'duplicate'),
        ARRAY[]::TEXT[],
        NULL,
        jsonb_build_object('trigger', 'api_create', 'conflict_reason', 'duplicate_email')
    );
END IF;
```text
<!-- Code example in TEXT -->

### 6.6 Separation of Concerns Pattern

This design separates **side effects (logging)** from **pure functions (response building)**:

- `log_mutation_event()` — Side effect only; writes to database
- `build_mutation_response()` — Pure function; no side effects
- `log_and_return_mutation()` — Combines both for typical mutations

**Benefits:**

- Testable: Each function can be tested independently
- Flexible: Can log without returning, or return without logging if needed
- Clear: Easy to understand what each function does
- Follows functional programming principles

---

## 7. Many-to-Many Relationships

### 7.1 Junction Table

```sql
<!-- Code example in SQL -->
CREATE TABLE tb_user_role (
    pk_user_role INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    fk_user BIGINTEGER NOT NULL REFERENCES tb_user(pk_user) ON DELETE CASCADE,
    fk_role INTEGER NOT NULL REFERENCES tb_role(pk_role),
    assigned_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(fk_user, fk_role)
);
```text
<!-- Code example in TEXT -->

### 7.2 View for Array Aggregation

```sql
<!-- Code example in SQL -->
-- Aggregate role IDs per user
CREATE VIEW v_user_role_ids_by_user AS
SELECT
    fk_user,
    array_agg(fk_role) AS role_ids,
    array_agg(r.id) AS role_ids_uuid
FROM tb_user_role ur
JOIN tb_role r ON r.pk_role = ur.fk_role
GROUP BY fk_user;

-- Include in user view
CREATE VIEW v_user AS
SELECT
    u.pk_user,
    u.id,
    u.identifier,
    COALESCE(ur.role_ids_uuid, ARRAY[]::UUID[]) AS role_ids,
    jsonb_build_object(
        'id', u.id,
        'identifier', u.identifier,
        'email', u.email,
        'roleIds', COALESCE(ur.role_ids_uuid, ARRAY[]::UUID[])
    ) AS data
FROM tb_user u
LEFT JOIN v_user_role_ids_by_user ur ON ur.fk_user = u.pk_user
WHERE u.deleted_at IS NULL;
```text
<!-- Code example in TEXT -->

**Rules:**

- Junction table uses internal keys (`fk_*`)
- View aggregates to UUID array
- Include both array column AND in JSONB
- Index the array column for GIN filtering

---

## 8. Indexing Strategy

### 8.1 Essential Indexes

```sql
<!-- Code example in SQL -->
-- On write table
CREATE INDEX idx_tb_user_id ON tb_user(id);
CREATE INDEX idx_tb_user_identifier ON tb_user(identifier);
CREATE INDEX idx_tb_user_created_at ON tb_user(created_at);
CREATE UNIQUE INDEX idx_tb_user_email ON tb_user(email) WHERE deleted_at IS NULL;

-- On related table
CREATE INDEX idx_tb_post_fk_user ON tb_post(fk_user);
CREATE INDEX idx_tb_post_id ON tb_post(id);
CREATE INDEX idx_tb_post_created_at ON tb_post(created_at);

-- On view for filtering
CREATE INDEX idx_v_post_user_id ON v_post(user_id);
CREATE INDEX idx_v_post_created_at ON v_post(created_at);

-- On array/JSONB columns (GIN)
CREATE INDEX idx_v_order_items__product__category_id
  ON v_order USING GIN(items__product__category_id);
CREATE INDEX idx_v_user_role_ids
  ON v_user USING GIN(role_ids);
CREATE INDEX idx_v_post_data_gin
  ON v_post USING GIN(data);
```text
<!-- Code example in TEXT -->

**Rules:**

- B-tree on: public `id`, `identifier`, audit columns, FK columns
- UNIQUE on: `id` and `identifier`
- GIN on: array columns, deep path columns, `data` JSONB (optional)
- Index what will be filtered

---

## 9. View Materialization Strategy

### 9.1 When to Materialize

Use materialized views for:

- Complex aggregations (slow joins)
- Deep denormalization needed for filtering
- Rarely-changing data (stats, summaries)
- High-cardinality pre-aggregations

```sql
<!-- Code example in SQL -->
CREATE MATERIALIZED VIEW mv_user_stats AS
SELECT
    fk_user,
    COUNT(DISTINCT fk_post) AS post_count,
    COUNT(DISTINCT fk_comment) AS comment_count,
    MAX(post.created_at) AS latest_post_at
FROM tb_user u
LEFT JOIN tb_post ON tb_post.fk_user = u.pk_user
LEFT JOIN tb_comment ON tb_comment.fk_user = u.pk_user
GROUP BY fk_user;

-- Refresh strategy
CREATE INDEX idx_mv_user_stats_fk_user ON mv_user_stats(fk_user);

-- Refresh manually or on schedule
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_stats;
```text
<!-- Code example in TEXT -->

**Rules:**

- Name: `mv_{entity}`
- Index on grouping columns
- Refresh strategy documented
- Use CONCURRENTLY to avoid locks

---

## 10. Validation Checklist

When creating a schema for FraiseQL:

- [ ] All write tables prefixed `tb_*`
- [ ] All read views prefixed `v_*`
- [ ] All functions prefixed `fn_*`
- [ ] Primary keys: `pk_{entity}` (INTEGER)
- [ ] Foreign keys: `fk_{entity}` (INTEGER)
- [ ] Public IDs: `id` (UUID)
- [ ] Surrogates: `identifier` (TEXT, indexed)
- [ ] All views have `data` JSONB column
- [ ] Related entity views expose `{parent}_id`
- [ ] Deep path columns follow `entity__path__field` pattern
- [ ] All tables have audit columns
- [ ] All views filter on `deleted_at IS NULL`
- [ ] Pre-aggregated views named `v_{entities}_by_{parent}`
- [ ] Arrow views named `av_{entity}` and are flat
- [ ] Mutation functions return JSONB
- [ ] All relevant columns indexed
- [ ] JSONB fields use camelCase
- [ ] No nullable JSONB (use {} or [])

---

*End of Schema Conventions Specification*
