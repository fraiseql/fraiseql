# Response to FraiseQL Team: SpecQL Composite Type Generation Strategy

**Date**: 2025-11-08
**From**: SpecQL Meta-Framework Team
**To**: FraiseQL AutoDiscovery Team
**Re**: Composite Type Input Generation Issue

---

## Executive Summary

âœ… **SpecQL WILL generate the composite type pattern you need!**

The SpecQL generator is being designed to produce **exactly** the PostgreSQL schema pattern described in your issue document. Here's what will be in the database for FraiseQL to introspect:

---

## ðŸŽ¯ What SpecQL Will Generate

### Input: Lightweight SpecQL (User writes ~20 lines)

```yaml
# entities/contact.yaml
entity: Contact
schema: crm

fields:
  email: text
  company: ref(Company)           # â† Just "company"
  status: enum(lead, qualified)

actions:
  - name: create_contact
    steps:
      - validate: email IS NOT NULL
      - insert: Contact
```

---

### Output: Complete PostgreSQL Schema (~2000 lines)

#### 1. Composite Input Type (App Layer - External API Contract)

```sql
-- ============================================================================
-- INPUT TYPE: app.type_create_contact_input
-- Generated by Team B: Composite Type Generator
-- ============================================================================
CREATE TYPE app.type_create_contact_input AS (
    email TEXT,
    company_id UUID,      -- âœ… UUID (external API uses UUIDs, not INTEGER!)
    status TEXT
);

-- FraiseQL metadata for introspection
COMMENT ON TYPE app.type_create_contact_input IS
  '@fraiseql:input name=CreateContactInput';

-- Field-level metadata (nullable, required, etc.)
COMMENT ON COLUMN app.type_create_contact_input.email IS
  '@fraiseql:field name=email,type=String!,required=true';

COMMENT ON COLUMN app.type_create_contact_input.company_id IS
  '@fraiseql:field name=companyId,type=UUID,relation=Company';

COMMENT ON COLUMN app.type_create_contact_input.status IS
  '@fraiseql:field name=status,type=ContactStatus,enum=true';
```

**âš ï¸ CRITICAL DESIGN DECISION**:
- Composite types use **UUID** for foreign keys (external API contract)
- Database tables use **INTEGER** for foreign keys (internal storage)
- **Resolution happens in core layer**: `core.company_pk(UUID) â†’ INTEGER`

---

#### 2. Standard Output Type (Generated Once)

```sql
-- ============================================================================
-- OUTPUT TYPE: app.mutation_result
-- Generated by Team B: Standard output type (created once per schema)
-- ============================================================================
CREATE TYPE app.mutation_result AS (
    id UUID,
    updated_fields TEXT[],
    status TEXT,              -- 'success', 'failed:*', 'warning:*'
    message TEXT,
    object_data JSONB,
    extra_metadata JSONB
);

COMMENT ON TYPE app.mutation_result IS
  '@fraiseql:type name=MutationResult';

COMMENT ON COLUMN app.mutation_result.status IS
  'Status codes: success | failed:reason | warning:reason';
```

---

#### 3. App Layer Function (API Gateway)

```sql
-- ============================================================================
-- APP LAYER: app.create_contact (GraphQL/REST Entry Point)
-- Generated by Team C: App Wrapper Generator
-- ============================================================================
CREATE OR REPLACE FUNCTION app.create_contact(
    input_pk_organization UUID,      -- Context: tenant ID (auto-injected)
    input_created_by UUID,            -- Context: user ID (auto-injected)
    input_payload JSONB               -- Business input (maps to composite type)
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    input_data app.type_create_contact_input;
BEGIN
    -- Parse JSONB â†’ Typed composite
    input_data := jsonb_populate_record(
        NULL::app.type_create_contact_input,
        input_payload
    );

    -- Delegate to core business logic
    RETURN crm.create_contact(
        input_pk_organization,
        input_data,          -- âœ… Typed input
        input_payload,       -- Original for audit trail
        input_created_by
    );
END;
$$;

-- FraiseQL mutation metadata
COMMENT ON FUNCTION app.create_contact IS
  '@fraiseql:mutation
name: createContact
description: Create a new contact in the CRM system
input_type: app.type_create_contact_input
success_type: Contact
failure_type: MutationError
context_params: {"organization_id": "input_pk_organization", "user_id": "input_created_by"}';
```

---

#### 4. Core Layer Function (Business Logic)

```sql
-- ============================================================================
-- CORE LAYER: crm.create_contact (Business Logic)
-- Generated by Team C: Core Logic Generator
-- ============================================================================
CREATE OR REPLACE FUNCTION crm.create_contact(
    input_pk_organization UUID,
    input_data app.type_create_contact_input,  -- âœ… Typed input
    input_payload JSONB,                        -- Original for audit
    input_created_by UUID
) RETURNS app.mutation_result
LANGUAGE plpgsql
AS $$
DECLARE
    v_id UUID := gen_random_uuid();
    v_pk_contact INTEGER;
    v_fk_company INTEGER;
BEGIN
    -- === VALIDATION ===
    IF input_data.email IS NULL THEN
        RETURN crm.log_and_return_mutation(
            input_pk_organization,
            input_created_by,
            'contact',
            '00000000-0000-0000-0000-000000000000'::UUID,
            'NOOP',
            'failed:missing_email',
            ARRAY['email']::TEXT[],
            'Email is required',
            NULL, NULL,
            jsonb_build_object('reason', 'validation_email_null')
        );
    END IF;

    -- === UUID â†’ INTEGER RESOLUTION ===
    -- âš ï¸ CRITICAL: Convert UUID (external) to INTEGER (internal FK)
    IF input_data.company_id IS NOT NULL THEN
        v_fk_company := crm.company_pk(input_data.company_id);

        IF v_fk_company IS NULL THEN
            RETURN crm.log_and_return_mutation(
                input_pk_organization,
                input_created_by,
                'contact',
                '00000000-0000-0000-0000-000000000000'::UUID,
                'NOOP',
                'failed:company_not_found',
                ARRAY['company_id']::TEXT[],
                'Company not found',
                NULL, NULL,
                jsonb_build_object('company_id', input_data.company_id)
            );
        END IF;
    END IF;

    -- === BUSINESS LOGIC ===
    INSERT INTO crm.tb_contact (
        id,
        tenant_id,
        email,
        fk_company,          -- âœ… INTEGER (internal FK)
        status,
        created_at,
        created_by
    ) VALUES (
        v_id,
        input_pk_organization,
        input_data.email,
        v_fk_company,        -- âœ… Resolved from UUID â†’ INTEGER
        input_data.status,
        now(),
        input_created_by
    )
    RETURNING pk_contact INTO v_pk_contact;

    -- === AUDIT & RETURN ===
    RETURN crm.log_and_return_mutation(
        input_pk_organization,
        input_created_by,
        'contact',
        v_id,
        'INSERT',
        'success',
        ARRAY(SELECT jsonb_object_keys(input_payload)),
        'Contact created successfully',
        (SELECT row_to_json(c.*) FROM crm.tb_contact c WHERE c.id = v_id)::JSONB,
        NULL
    );
END;
$$;
```

---

#### 5. Helper Functions (UUID â†” INTEGER Resolution)

```sql
-- ============================================================================
-- TRINITY HELPER FUNCTIONS
-- Generated by Team B: Auto-generated for every entity
-- ============================================================================

-- UUID â†’ INTEGER (pk)
CREATE OR REPLACE FUNCTION crm.contact_pk(p_identifier TEXT)
RETURNS INTEGER
LANGUAGE sql STABLE
AS $$
    SELECT pk_contact
    FROM crm.tb_contact
    WHERE id::TEXT = p_identifier
       OR identifier = p_identifier
       OR pk_contact::TEXT = p_identifier
    LIMIT 1;
$$;

-- INTEGER (pk) â†’ UUID
CREATE OR REPLACE FUNCTION crm.contact_id(p_pk INTEGER)
RETURNS UUID
LANGUAGE sql STABLE
AS $$
    SELECT id FROM crm.tb_contact WHERE pk_contact = p_pk;
$$;

-- Similar functions for Company entity
CREATE OR REPLACE FUNCTION crm.company_pk(p_identifier TEXT)
RETURNS INTEGER
LANGUAGE sql STABLE
AS $$
    SELECT pk_company FROM crm.tb_company
    WHERE id::TEXT = p_identifier OR identifier = p_identifier OR pk_company::TEXT = p_identifier
    LIMIT 1;
$$;
```

---

#### 6. Database Table (Internal Structure)

```sql
-- ============================================================================
-- TABLE: crm.tb_contact (Trinity Pattern)
-- Generated by Team B: Table Generator
-- ============================================================================
CREATE TABLE crm.tb_contact (
    -- Trinity pattern (auto-generated)
    pk_contact INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    id UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,
    identifier TEXT UNIQUE,

    -- Multi-tenant context
    tenant_id UUID NOT NULL,

    -- Business fields
    email TEXT NOT NULL,
    fk_company INTEGER,          -- âœ… INTEGER FK (internal)
    status TEXT CHECK (status IN ('lead', 'qualified')),

    -- Audit fields (auto-generated)
    created_at TIMESTAMPTZ DEFAULT now(),
    created_by UUID,
    updated_at TIMESTAMPTZ DEFAULT now(),
    updated_by UUID,
    deleted_at TIMESTAMPTZ,
    deleted_by UUID
);

-- Indexes (auto-generated)
CREATE INDEX idx_tb_contact_id ON crm.tb_contact USING btree (id);
CREATE INDEX idx_tb_contact_tenant ON crm.tb_contact USING btree (tenant_id);
CREATE INDEX idx_tb_contact_company ON crm.tb_contact USING btree (fk_company);
CREATE INDEX idx_tb_contact_status ON crm.tb_contact USING btree (status);

-- Foreign keys (auto-generated)
ALTER TABLE ONLY crm.tb_contact
    ADD CONSTRAINT tb_contact_company_fkey
    FOREIGN KEY (fk_company) REFERENCES crm.tb_company(pk_company);

-- FraiseQL table metadata
COMMENT ON TABLE crm.tb_contact IS
  '@fraiseql:type name=Contact,schema=crm';
```

---

## ðŸ” Answers to Your Questions

### 1. **Nullable Semantics**

**SpecQL Approach**: Use field-level comments + naming convention

```sql
CREATE TYPE app.type_create_contact_input AS (
    email TEXT,           -- Required
    company_id UUID,      -- Optional
    status TEXT           -- Required
);

-- Metadata in comments (PostgreSQL composite types don't support NOT NULL)
COMMENT ON COLUMN app.type_create_contact_input.email IS
  '@fraiseql:field name=email,type=String!,required=true';

COMMENT ON COLUMN app.type_create_contact_input.company_id IS
  '@fraiseql:field name=companyId,type=UUID,required=false';
```

**For FraiseQL**: Parse `required=true/false` from column comments to determine GraphQL `!` suffix.

---

### 2. **Schema Resolution**

**SpecQL Convention**:
- Composite types always in `app` schema
- Functions in their entity schema (`crm`, `management`, etc.)
- Cross-schema references fully qualified

```sql
-- Function in crm schema references app schema type
CREATE FUNCTION crm.create_contact(
    ...
    input_data app.type_create_contact_input  -- âœ… Fully qualified
)
```

**For FraiseQL**: Always look for composite types in `app` schema first.

---

### 3. **Type Name Conventions**

**SpecQL Convention**:
```
Action: create_contact
â†“
Composite Type: app.type_create_contact_input
â†“
GraphQL Input: CreateContactInput
```

**Pattern**: `type_{action_name}_input`

**For FraiseQL**:
- Extract action name from type: `type_create_contact_input` â†’ `create_contact`
- Convert to GraphQL: `create_contact` â†’ `CreateContactInput`

---

### 4. **Array/Nested Types**

**SpecQL Supports**:
```yaml
fields:
  tags: list(text)
  metadata: json
```

**Generates**:
```sql
CREATE TYPE app.type_entity_input AS (
    tags TEXT[],           -- Array fields supported
    metadata JSONB         -- Nested objects as JSONB
);
```

**For FraiseQL**:
- `TEXT[]` â†’ GraphQL `[String!]`
- `JSONB` â†’ GraphQL `JSON` scalar

**Nested composite types**: Not in Phase 1, future enhancement.

---

### 5. **Versioning**

**SpecQL Approach**: Not in initial version. Future enhancement would use:
```sql
CREATE TYPE app.type_create_contact_input_v2 AS (...);

COMMENT ON FUNCTION app.create_contact_v2 IS
  '@fraiseql:mutation input_type=app.type_create_contact_input_v2';
```

**For FraiseQL**: Parse `input_type` annotation to find correct version.

---

### 6. **Performance**

**SpecQL Strategy**:
- Composite types generated at migration time (not runtime)
- ~100-200 composite types expected for typical enterprise schema
- FraiseQL should **cache composite type metadata** on startup
- Invalidate cache on schema changes (listen to PostgreSQL notifications)

**Recommendation**: Pre-load all `app.type_*_input` types during FraiseQL initialization.

---

## ðŸŽ¯ What FraiseQL Needs to Do

### Phase 1: Introspect Composite Types âœ… (Your Current Work)

```python
# Query to find all input types
SELECT
    t.typname AS type_name,
    obj_description(t.oid, 'pg_type') AS comment
FROM pg_type t
JOIN pg_namespace n ON n.oid = t.typnamespace
WHERE n.nspname = 'app'
  AND t.typname LIKE 'type_%_input'
  AND t.typtype = 'c';  -- Composite type

# Query to get composite type attributes
SELECT
    a.attname AS attribute_name,
    format_type(a.atttypid, a.atttypmod) AS pg_type,
    a.attnum AS ordinal_position,
    col_description(c.oid, a.attnum) AS comment
FROM pg_class c
JOIN pg_namespace n ON n.oid = c.relnamespace
JOIN pg_attribute a ON a.attrelid = c.oid
WHERE c.relkind = 'c'
  AND n.nspname = 'app'
  AND c.relname = 'type_create_contact_input'
  AND a.attnum > 0
  AND NOT a.attisdropped
ORDER BY a.attnum;
```

---

### Phase 2: Link Functions to Composite Types âœ…

**Strategy**: Parse `input_type` from function comments, or use convention:

```python
# Query to find mutations
SELECT
    p.proname AS function_name,
    n.nspname AS schema_name,
    pg_get_function_arguments(p.oid) AS parameters,
    obj_description(p.oid, 'pg_proc') AS comment
FROM pg_proc p
JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE n.nspname = 'app'
  AND p.proname NOT LIKE 'pg_%'
  AND EXISTS (
      -- Has JSONB parameter named input_payload
      SELECT 1 FROM pg_proc_arguments(p.oid) pa
      WHERE pa.parameter_name = 'input_payload'
        AND pa.parameter_type = 'jsonb'
  );

# Extract composite type from comment
comment = "@fraiseql:mutation input_type=app.type_create_contact_input ..."

# OR use convention
function_name = "create_contact"
type_name = f"type_{function_name}_input"
```

---

### Phase 3: Auto-Detect Context Parameters âœ…

**SpecQL Convention**:
```sql
-- Context parameters (auto-injected from GraphQL context)
input_pk_organization UUID   â†’ context["organization_id"]
input_created_by UUID         â†’ context["user_id"]

-- Business input (from GraphQL mutation input)
input_payload JSONB           â†’ mutation input (maps to composite type)
```

**FraiseQL Implementation**:
```python
def extract_context_params(function_params):
    context_mapping = {}

    for param in function_params:
        if param.name.startswith('input_pk_'):
            # input_pk_organization â†’ organization_id
            context_key = param.name.replace('input_pk_', '') + '_id'
            context_mapping[context_key] = param.name

        elif param.name == 'input_created_by':
            context_mapping['user_id'] = param.name

    return context_mapping

# Result:
{
    "organization_id": "input_pk_organization",
    "user_id": "input_created_by"
}
```

---

### Phase 4: Generate GraphQL Schema âœ…

**From SpecQL-generated composite type**:
```sql
CREATE TYPE app.type_create_contact_input AS (
    email TEXT,
    company_id UUID,
    status TEXT
);
```

**FraiseQL Generates**:
```graphql
input CreateContactInput {
  email: String!          # From comment: required=true
  companyId: UUID         # Converted to camelCase
  status: ContactStatus   # From comment: enum=true
}

type Mutation {
  createContact(input: CreateContactInput!): MutationResult!
}

type MutationResult {
  id: UUID!
  updatedFields: [String!]!
  status: String!
  message: String
  objectData: JSON
  extraMetadata: JSON
}
```

---

## ðŸš€ Migration Path for FraiseQL

### No Breaking Changes! âœ…

**Existing functions without composite types**: Continue to work with parameter-based generation

```sql
-- Old style (still supported)
CREATE FUNCTION fn_simple_mutation(p_name TEXT, p_value INT) ...
```
â†’ FraiseQL generates input from parameters (current behavior)

**New SpecQL-generated functions**: Use composite types automatically

```sql
-- New style (SpecQL-generated)
CREATE FUNCTION app.create_contact(
    input_pk_organization UUID,
    input_created_by UUID,
    input_payload JSONB
) ...
```
â†’ FraiseQL detects `input_payload JSONB` â†’ introspects composite type

---

## ðŸ“‹ Coordination Checklist

### SpecQL Deliverables to FraiseQL

- [x] **Composite type generation** (`app.type_*_input`)
- [x] **Standard output type** (`app.mutation_result`)
- [x] **FraiseQL annotations** on types and columns
- [x] **Naming conventions** documented
- [x] **UUID field naming** (`company` â†’ `company_id`)
- [x] **Context parameter conventions** (`input_pk_*`, `input_created_by`)

### FraiseQL Implementation Tasks

- [ ] Composite type introspection (Phase 5.1)
- [ ] Input generation from composite types (Phase 5.2)
- [ ] Context parameter auto-detection (Phase 5.3)
- [ ] Annotation-based overrides (Phase 5.4)
- [ ] Integration testing with SpecQL output (Phase 5.5)

---

## ðŸŽ¯ Example: Complete Flow

### User Writes (20 lines)
```yaml
entity: Contact
schema: crm
fields:
  email: text
  company: ref(Company)
  status: enum(lead, qualified)
actions:
  - name: create_contact
```

### SpecQL Generates (2000 lines)
- âœ… `app.type_create_contact_input` composite type
- âœ… `app.mutation_result` output type
- âœ… `app.create_contact()` wrapper function
- âœ… `crm.create_contact()` core logic function
- âœ… `crm.tb_contact` table with Trinity pattern
- âœ… `crm.contact_pk()` and `crm.contact_id()` helpers
- âœ… FraiseQL annotations on all objects

### FraiseQL Introspects
- âœ… Finds `app.type_create_contact_input` composite type
- âœ… Reads field metadata from column comments
- âœ… Links `app.create_contact` function to composite type
- âœ… Extracts context parameters (`organization_id`, `user_id`)

### FraiseQL Generates GraphQL
```graphql
input CreateContactInput {
  email: String!
  companyId: UUID
  status: ContactStatus!
}

type Mutation {
  createContact(input: CreateContactInput!): MutationResult!
}
```

### **Result**: Zero manual code! ðŸŽ‰

---

## ðŸ“ž Contact Points

**SpecQL Team Contact**: Claude Code Development Team
**FraiseQL Team Contact**: AutoFraiseQL Introspection Team

**Questions?**
- SpecQL implementation: Reference `docs/implementation-plans/TEAM_B_APP_CORE_SCHEMA_PLAN.md`
- Database pattern: Reference `docs/architecture/APP_CORE_FUNCTION_PATTERN.md`

---

## âœ… Summary

**Yes, SpecQL will generate exactly what you need!**

1. âœ… **Composite types** with UUID fields for external API
2. âœ… **FraiseQL annotations** on types and columns
3. âœ… **Context parameter conventions** for auto-detection
4. âœ… **Standard naming conventions** for type discovery
5. âœ… **Complete metadata** for GraphQL schema generation

**Timeline**:
- Team B (Composite Types): Week 2 (Nov 11-15)
- Team C (Functions): Week 3 (Nov 18-22)
- Integration Testing: Week 4 (Nov 25-29)
- FraiseQL Integration: Week 5-6 (Dec 2-13)

**You can start implementing your introspection code now** - the database schema pattern is locked in and documented!

---

**Last Updated**: 2025-11-08
**Status**: âœ… Schema Pattern Confirmed
**Next Steps**: Begin FraiseQL Phase 5.1 (Composite Type Introspection)
