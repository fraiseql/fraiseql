# FraiseQL Relay Specification Implementation - PostgreSQL Global View Approach

## Overview

This document outlines a PostgreSQL-first approach to implementing full GraphQL Relay specification compliance in FraiseQL, focusing on Global Object Identification through a unified database view.

## Current FraiseQL Architecture

FraiseQL uses a "Sacred Trinity" pattern for all entities:
- `id` (INTEGER IDENTITY) - Internal database sequence
- `pk_entity` (UUID) - Business primary key
- `identifier` (TEXT) - Human-readable business identifier

Example table structure:
```sql
CREATE TABLE tb_user (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_user UUID DEFAULT gen_random_uuid() NOT NULL,
    identifier TEXT, -- email or username

    -- User data fields
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    bio TEXT,
    -- ... other fields

    CONSTRAINT pk_tb_user PRIMARY KEY (id),
    CONSTRAINT uq_tb_user_pk UNIQUE (pk_user)
);
```

## Proposed Global Node View Solution

### Core Concept: Unified v_nodes View

Instead of type-specific routing logic, create a single view that maps UUIDs to entity data:

```sql
-- Global nodes view - centralized entity lookup by UUID
CREATE OR REPLACE VIEW v_nodes AS
SELECT
    pk_user as id,           -- The UUID (becomes global ID)
    'User' as __typename,    -- GraphQL type name
    'tb_user' as source_table,
    jsonb_build_object(
        '__typename', 'User',
        'id', pk_user,
        'email', email,
        'name', name,
        'bio', bio,
        'avatarUrl', avatar_url,
        'isActive', is_active,
        'roles', roles,
        'createdAt', created_at,
        'updatedAt', updated_at
    ) as data
FROM tb_user
WHERE deleted_at IS NULL

UNION ALL

SELECT
    pk_post as id,
    'Post' as __typename,
    'tb_post' as source_table,
    jsonb_build_object(
        '__typename', 'Post',
        'id', pk_post,
        'authorId', fk_user,
        'title', title,
        'slug', slug,
        'content', content,
        'excerpt', excerpt,
        'tags', tags,
        'isPublished', is_published,
        'publishedAt', published_at,
        'viewCount', view_count,
        'createdAt', created_at,
        'updatedAt', updated_at
    ) as data
FROM tb_post
WHERE deleted_at IS NULL

UNION ALL

SELECT
    pk_comment as id,
    'Comment' as __typename,
    'tb_comment' as source_table,
    jsonb_build_object(
        '__typename', 'Comment',
        'id', pk_comment,
        'postId', fk_post,
        'authorId', fk_user,
        'parentId', fk_parent_comment,
        'content', content,
        'isEdited', is_edited,
        'createdAt', created_at,
        'updatedAt', updated_at
    ) as data
FROM tb_comment
WHERE deleted_at IS NULL;

-- Add index for O(1) lookups
CREATE INDEX idx_v_nodes_id ON v_nodes(id);
```

### Relay Node Resolution

The node resolver becomes trivial:

```sql
-- Simple node resolution by UUID
CREATE OR REPLACE FUNCTION core.resolve_node(node_id UUID)
RETURNS TABLE(__typename TEXT, data JSONB) AS $$
BEGIN
    RETURN QUERY
    SELECT v.__typename, v.data
    FROM v_nodes v
    WHERE v.id = node_id;
END;
$$ LANGUAGE plpgsql;
```

GraphQL resolver:
```python
@fraiseql.query
async def node(info, id: UUID) -> Node | None:
    """Relay Node interface resolver"""
    db = info.context["db"]
    result = await db.execute_function("core.resolve_node", {"node_id": id})

    if not result:
        return None

    typename = result["__typename"]
    data = result["data"]

    # Dynamic type resolution based on __typename
    if typename == "User":
        return User.from_dict(data)
    elif typename == "Post":
        return Post.from_dict(data)
    elif typename == "Comment":
        return Comment.from_dict(data)
    # ... other types

    return None
```

## Global ID Strategy Options

### Option 1: Direct UUID Usage (Recommended)
Use PostgreSQL UUIDs directly as global IDs:
- **Pros**: Simple, no encoding overhead, database-native
- **Cons**: Doesn't include type information in ID itself

```python
# GraphQL schema
type User implements Node {
    id: UUID!  # Direct pk_user UUID
    name: String!
    email: String!
}
```

### Option 2: Encoded Global IDs (Relay Standard)
Encode type + UUID as base64 string:
- **Pros**: Self-describing IDs, pure Relay compliance
- **Cons**: Encoding overhead, more complex

```sql
-- Global ID encoding
CREATE OR REPLACE FUNCTION core.encode_global_id(typename TEXT, local_id UUID)
RETURNS TEXT AS $$
BEGIN
    RETURN encode(concat(typename, ':', local_id::TEXT)::bytea, 'base64');
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

## Relay Mutation Patterns

### Enhanced Mutation Result Type
```sql
-- Relay-compatible mutation result
CREATE TYPE app.relay_mutation_result AS (
    success BOOLEAN,
    client_mutation_id TEXT,
    operation_type TEXT,
    entity_type TEXT,
    entity_id UUID,
    message TEXT,
    error_code TEXT,
    changed_fields TEXT[],
    object_data JSONB,  -- The actual entity data for response
    metadata JSONB
);
```

### Example Relay Mutation
```sql
CREATE OR REPLACE FUNCTION core.relay_create_user(
    input_pk_organization UUID,
    input_created_by UUID,
    input_client_mutation_id TEXT,
    input_data app.type_user_input
) RETURNS app.relay_mutation_result AS $$
DECLARE
    v_user_id UUID;
    v_result app.relay_mutation_result;
BEGIN
    -- Standard business logic...
    v_user_id := gen_random_uuid();

    INSERT INTO tb_user (pk_user, pk_organization, email, name, bio, created_by)
    VALUES (v_user_id, input_pk_organization, input_data.email,
            input_data.name, input_data.bio, input_created_by);

    -- Return Relay-compatible result
    v_result.success := true;
    v_result.client_mutation_id := input_client_mutation_id;
    v_result.operation_type := 'INSERT';
    v_result.entity_type := 'User';
    v_result.entity_id := v_user_id;
    v_result.message := 'User created successfully';

    -- Get the complete entity data from v_nodes view
    SELECT data INTO v_result.object_data
    FROM v_nodes
    WHERE id = v_user_id AND __typename = 'User';

    RETURN v_result;
END;
$$ LANGUAGE plpgsql;
```

### GraphQL Mutation with Relay Pattern
```python
@fraiseql.input
class CreateUserInput:
    clientMutationId: str | None = None
    email: str
    name: str
    bio: str | None = None

@fraiseql.success
class CreateUserPayload:
    clientMutationId: str | None = None
    user: User | None = None
    message: str = "User created successfully"

@mutation(function="relay_create_user")
class CreateUser:
    input: CreateUserInput
    success: CreateUserPayload
    failure: CreateUserError
```

## Performance Considerations

### Indexing Strategy
```sql
-- Core index for node resolution
CREATE INDEX idx_v_nodes_id ON v_nodes(id);

-- Type-specific lookups
CREATE INDEX idx_v_nodes_typename ON v_nodes(__typename);

-- Combined index for filtered queries
CREATE INDEX idx_v_nodes_type_id ON v_nodes(__typename, id);
```

### Query Performance
- **v_nodes view**: Uses UNION ALL for efficiency
- **Index coverage**: Single index covers most node lookups
- **Materialized option**: Could materialize for very high-traffic scenarios

## Integration with Existing FraiseQL Features

### Connection Queries (Already Working)
Current `@connection` decorator works without changes:
```python
@fraiseql.connection(node_type=User)
@fraiseql.query
async def users_connection(info, first: int | None = None) -> Connection[User]:
    pass  # Existing pagination logic unchanged
```

### CQRS Pattern Preservation
- Write operations continue through PostgreSQL functions
- Read operations leverage enhanced views
- Audit logging remains comprehensive
- JSONB data column pattern preserved

## Migration Strategy

### Phase 1: Add v_nodes View
- Create unified view alongside existing v_entity views
- No breaking changes to existing code
- Begin using for node resolution only

### Phase 2: Relay Mutations (Optional)
- Add relay_* versions of mutation functions
- Existing mutations continue working
- Gradual migration of consumers

### Phase 3: Global ID Strategy Decision
- Choose between direct UUIDs vs encoded IDs
- Update client code accordingly
- Provide compatibility helpers

## Benefits of This Approach

1. **PostgreSQL Native**: Leverages UNION views and UUID columns
2. **Centralized**: Single source of truth for all entity resolution
3. **Efficient**: O(1) lookups with proper indexing
4. **Extensible**: Add new entities by extending the UNION
5. **Backward Compatible**: Existing queries continue working
6. **Type Safe**: Each entity includes GraphQL type information
7. **Maintainable**: Clear separation between entity types in SQL

## Questions for Review

1. **Global ID Strategy**: Direct UUIDs vs Base64-encoded IDs?
2. **View Materialization**: Should v_nodes be materialized for performance?
3. **Type Registration**: Need a registry table or is UNION sufficient?
4. **Client Mutation ID**: Required for all mutations or optional?
5. **Breaking Changes**: Any concerns with the migration approach?

---

**Target**: Full GraphQL Relay specification compliance while maintaining FraiseQL's PostgreSQL-first architecture and existing CQRS patterns.
